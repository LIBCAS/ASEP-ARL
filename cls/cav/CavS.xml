<?xml version="1.0" encoding="UTF-8"?>
<Export generator="IRIS" version="26" zv="IRIS for UNIX (Red Hat Enterprise Linux 8 for x86-64) 2023.1.1 (Build 380U)" ts="2024-02-13 16:49:41">
<Class name="User.CavS">
<Description><![CDATA[
<pre>
13.02.24 tt; ImpC86QTC: zalozena metoda pro pravidelny import
05.02.24 tt; doplneno dalsi escapovani
30.01.24 tt; provedeno zaescapovani impact factoru znaku < do exportu xml
10.01.24 tt; RecNeodIpac: pridan parametr na zobrazeni pro superuzivatele a zpracovatele (bez rozliseni prava)
02.01.24 tt; 2 - GetRoleUser - GetAllOperation - pokud mam zpracovatele, pridam priznak  - i k autorite
                 pokud mam zpracovatele, pridam priznak  - i k autorite - vymazeme
02.01.24 tt; VymazNenavCatAutorit: drobna uprava podminky pro hledani navaznosti
01.12.23 tt; na zaklade pozadavku drobne upravy zakazky 2022 (29.11.23) upraveno
             zfVkladatel: provedena zmena, aby se vkladatele zobrazovali komukoli - zalomentovano - sUserR 
22.11.23 tt; generateC52:doplnena smlouva
01.11.23 tt; cs122294 - odstraneni prebytecnych mezer
20.09.23 tt; zfContent: pridan 1. parametr v parametrech - pro zobrazovani souboru v ruznych kontextech
13.09.23 tt; exportXMLOpenAIRE: zalozeno pro export xml do openaire - datacite 
15.08.23 tt; exportDCOpenAIRE: provedena oprava dotahování identifikátorů
17.02.23 tt; znovu obnovena funkčnost kvůli openaire - upraveno hlavicka https na http
16.02.23 tt; znovu obnovena funkčnost kvůli openaire
01.12.22 tt; GetAllOperation: pridana funcnost vytvoreni kopie datasetu 
29.11.22 tt; provedena změna hlavičky pro export do openaire + i2.ws.oai
19.05.22 tt; GetAllOperation: pridáno mošnost pro super -k
26.01.22 jk; zalozeno CreateCavhandle
09.11.21 tt; zfDatumZverejneni: zalozena metoda
02.04.21 tt; FTgetIsUser: provedena uprava logiky pridelovani roli
14.10.20 oi; uprava met. Add856NUSLforOAI() - pridano hodnota "origname" soubrou do podpole 856$f
20.08.20 tt; provedena uprava vymazavani autorit
14.08.20 tt; VymazNenavCatAutorit: zalozena metoda
09.07.20 tt; upraveny podminky pro vymaz autorit
20.03.20 tt; provedeno upraveni bibliografickych citaci pro oai kav
16.10.12 tt; zfContentHlaska: zalozena metoda - Zalozena metoda pro vypsani hlasky pro CAV - kdy neschvaleny zaznam je zobrazen pro hodnoceni
17.03.20 tt; osetreni citace od html znaku
28.02.20 tt; provedena uprava kvuli hodnoceni
25.02.20 tt; predalano pravo na editaci ohlasu na h - clovek, ktery zaznam vytvoril - 7 - upraveno k editaci KNAV-K -zpracovatel 
16.06.20 tt; ohlas muze upravovat zpracovatel zaznamu, ktery jej vytvoril
05.02.19 tt; showRecordXMLKAV: pridana informace o vyuzivani patentu do exportu pro hodnoceni
28.01.20 tt; generateC52: provedena uprava, aby se do C52 vzdy pri zmene generovalo podpole n
24.01.20 tt; pridana podminka pro fultext, i pokud je verze jina ale druhy dokumentu jsou E,L*,P*,Z
21.01.20 tt; showRecordXMLKAVContent: pridano generovani do xml pro KNAV prvku plny_text 
19.12.19 tt; pridana zmena druhu dokumentu - k
17.12.19 tt; ExpSetPracA1: provedena zmena doplneni oddeleni a vyhodnoceni podminky
17.10.19 tt; uzivatel kontrola muze videt smlouvy i spolupracujicich ustavu- zmenena tato podminka
03.10.19 tt; vytvoreno ImpDataEPCAOddel
24.09.19 tt; provedena uprava, aby se oddeleni upravovalo na i,j,k,l - nova funkcnost oddeleni
31.07.19 tt; uprava podminky, aby bylo mozne zmenit i zaznamy do RIVu
28.05.19 tt; pridano pravo na zmenu roku sberu pro zpracovatele a superuzivatele
04.05.19 tt; GetAllOperation: pokud je záznam neoznačen do RIV, tak zpracovatel jej může vždy smazat (nyní u záznamů jiného 
            než aktuálního roku sběru není tato možnost)  - ((sAktRokSb'=sRC26Rok)&& - zbytecna podminka    
26.04.19 tt; pridany rozsirene informace o zaznamech
17.04.19 tt; VymazNenavAutorit: zalozena metoda
01.03.19 tt; generateC52m: pridan priznak pro smlouvu - specialni typ
01.03.19 tt; provedena uprava vyhodnoceni uzivatele kontrola
27.02.19 tt; zfContent: upraveno zobrazeni sloupce hodnoceni
26.02.19 tt; symExpKosik: metoda zalozena                           
01.02.19 tt; pridan uzivatel kontrola - 8 
11.01.19 tt; RecNeodIpac: upravy kvuli zobrazeni lup a dalsi funkcnosti
31.01.18 tt; pokud jsem zpracovatel a clovek z meho ustavu vytvoril nejakou autoritu, muzu editovat
23.01.18 tt; provedena uprava pro druh dokumentu C pro FMT
11.01.18 tt; upraven zobrazovaci format pro DATA content server
28.11.17 tt; CitaceXml: pridana metoda pro export citaci v katalogu
27.11.17 jk; zruseno makro GetParDefaultLang
01.11.17 tt; zfContent: pridan u dat sloupec pristup
26.07.17 tt; repPrehledZaz a repPrehledZazVyp: metoda zalozena
10.05.17 tt; FTgetDataStav: metoda zalozena
14.03.17 tt; pridana logika pro datasety s U95a
12.01.17 tt; RecNeodIpac: prepsana metoda pro zobrazeni neodeslanych zaznamu podle nove logiky indexu
16.12.16 tt; VysSpatneLinky: metoda zalozena
13.12.16 jk; predelana tvorba linku na detail zaznamu v ipacu
08.12.16 tt; upraveno porovnani anonymniho uzivatele - jsou vovoleny cisla, ktere se pri porovnani odfiltruji
30.11.16 jk; cesta na handlenet se cte z konfigurace
30.11.16 tt; zmena adresy
30.11.16 tt; zmena adresy pro handle net
11.11.16 tt; zfContent: pridana volba u zobrazeni velkych dat+
29.06.16 tt; upraveny podminky pro vytvareni handle.net (omezeno 969fN)
16.05.16 tt; uprava vypisu informaci u vystupu uprava pracovist
25.02.16 tt; ImpINCITES: zalozena metoda 
27.11.15 tt; uprava vyhodnoceni prav kvuli I3web formularu  - OHLASY
17.11.15 tt; rightsDatabase: zalozeno 
29.10.15 tt; dublinCoreOpenAIRE: upraven export projektu o 230b
08.09.15 tt; upraven export OpenAire
06.09.15 tt; doi, issn a isbn presunuto na 18
04.09.15 tt; dublinCoreOpenAIRE: zmeny podle zadani
02.09.15 tt; exportDCOpenAIRE: zalozena metoda pro specialni export dc do OPENAIRE - cs29885 
02.06.15 tt; fixMetadata - pridana metoda na upravu metadat statistik
02.04.15 jk; vystup jde do utf-8
24.03.15 tt; generateC52m: uprava logiky
15.03.15 tt; showRecordXMLKAV: pridany anglicky link - link_eng
13.03.15 tt; generateC52m: zalozena metoda pro pregenerovani C52m 
28.01.15 tt; ImpHod2015Auth: doplnena importni metoda C48
             gEpca70Xw: zalozena metoda
             ImpHod2015Kat: doplnena importni metoda C64
16.12.14 tt; CreateHandleNet: upraven link pro smazane zaznamy
13.12.14 tt; showRecordXMLKAV: pridano odstraneni zpecialnich znaku
             showRecordXMLBibCit - zalozeno
             showRecordXMLKAVContent: pridan export 856    
30.11.14 tt; zfContent: pridan spolupracujici zpracovatel do rozsireneho zobrazeni udaju content serveru
30.11.14 tt; symExportOAI2NUSL: pridana uprava,a by se do NUSL odesilali zaznamy, ktere maji 856 bez x nebo s x=N
22.11.14 tt; zfContent: dopracovana podpora zobrazovani recenzi
06.11.14 tt; showRecordXMLKAV: pridany prvek s nazevm eng
04.11.14 tt; showRecordXMLKAVContent: zalozena metoda
03.11.14 tt; generateC52: pridano vytvoreni recenzi a hodnoceni
08.10.14 tt; showRecordXMLKAV: upraveno escapovani citaci
17.08.14 tt; zfContent: pridan preklad textu u tabulky content serveru
28.06.14 tt; showRecordXMLKAVAutori: pridan element researcher_id -  zaznam autority 035$$a, kde $$2WOS + pridan priznak z 70*u=1 - zaznam k hodnoceni
10.06.14 tt; showRecordXMLKAV: drobne upravy ve scheme na pripominky pana Galika
03.06.14 tt; showRecordXMLKAVHodKr a showRecordXMLKAVCitRec a showRecordXMLKAVAutori: 
             zalozeny metody pro export pro KAV
06.02.14 jk; zruseny globalni promenne ictx a lang
20.01.13 tt; showRecordXMLKAV: uprava, aby se plnilo pracoviste u autoru
02.01.14 tt; GenC60Handle: upravena navratova hodnota
09.10.13 tt; Add856NUSLforOAI: upraveny podminky pro poslani linku na zaznam 
03.10.13 tt; Add856NUSLforOAI: uprava linku pro NUSL - pridan parametr ictx
13.08.13 tt; showRecordXMLKAV: zalozena metoda
23.05.13 tt; RecFullText: uprava linku na prikladani souboru z klienta 
20.02.13 tt; zfContent: uprava kvuli validnosti - kp
06.02.13 tt; zfContent: upravena metoda pro generovani externich linku
06.02.13 tt; GenC60Handle a ModifyCavhandle: zalozena metoda 
20.01.13 tt; generateC52: osetren vypis kvuli zobrazovani v IPACu3
10.01.13 tt; generateC52: pridano odmazani C52, pokud se nevytvorila jina/nove
12.12.12 tt; CreateHandleNet: zalozena planovana metoda na zapis do handle net serveru 
12.12.12 tt; genHandleNetR: smazana pro nepotrebnost
09.11.12 tt; genHandleNetR: zalozena metoda
16.10.12 tt; zfContent: zalozena metoda pro zobrazovani rozdilnych tabulek fulltextu
                        podle kontextu uzivatele
07.10.12 tt; generateC52: zalozen symbolik pro pregenerovani C52
07.10.12 tt; SelSymbCont: zalozen symbolik pro vyber zaznamu z content serveru
01.10.12 tt; FTgetIsUser: pridana funkcnost na zjisteni ustavu podle IP adres
             i neprihlaseny uzivatel ziska prava prihlaseneho v ramci ustavu
09.08.12 tt; getNuslRec: zalozena metoda pro selekt dat s fulltextem NUSLU
01.07.12 tt; Add856NUSLforOAI: zalozen symbolik pro dogenerovani fulltextu pro ucely OAI
01.07.12 tt; symExportOAI2NUSL: zapojen symbolik pro generovani 856 na zaklade content serveru
18.05.12 tt; FTgetIsUser: uprav logiky pro anonymni uzivatele - chova se 
             vzdy jako navratova hodnota 3
04.11.11 tt; FTgetEmailHandle a FTgetZpracZaUstav: metoda zalozena
14.10.11 tt; FTgetIsUser: zmena logiky superuzivatele
29.09.11 tt; uprava FTgetIsUser, FTgetUstavU a FTgetUstavU proti spatnym vstupum
23.09.11 ln; oprava FTgetIsUser, FTgetUstavU a FTgetUstavU pri neplatnem zaznamu
22.09.11 tt; FTgetUstavR a FTgetUstavU a FTgetIsUser a FTgetIsAutor: metoda zalozena
27.03.11 tt; symExportOAI2NUSL: nahrazeni hodnoty v C34v
21.03.11 tt; RecFullText: zmena logiky, pridavat souboru se nemaji k BCA a BXXS
09.03.11 tt; RecFullText: metoda zalozena na vlozeni fulltextu
08.11.10 tt; testCheck856x: pridana varianta pro novy zaznam
03.11.10 tt; testCheck856x: formalni oprava chyby, aby se nenacitalo s prazdneho handlu
25.10.10 tt; testCheck856x: dalsi upravy symboliku
25.10.10 tt; symExportOAI2NUSL: upraven filtracni symbolik pro OAI o filtraci 856
19.10.10 lp; filtracni symbolik symExportOAI2NUSL pro export pres OAI-PMH do NUSL
25.08.10 tt; Filt856x: zalozena metoda na filtrovani 856 podle $x
14.10.10 tt; FilterSymbI:zalozeno na zaklade usel.sec.mfilter.testSplitSymb
             filtrovani 856
22.07.10 tt; RecNeodIpac: metoda zalozena
17.05.10 tt; ExpSetPracA1: pridana varianta pro odstraneni oddeleni, prepracovani vkladani 
             oddeleni, aby se vkladaly vsechny opakovani C06 podpole $$h
10.05.10 tt; metoda zalozena ExpSetPracAuth
09.12.09 tt; zalozena trida
</pre>
Uzivatelske funkce a vystupy pro Cav (CavS)]]></Description>
<ClassType/>
<IncludeCode>Common,I2</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Library.RegisteredObject</Super>
<TimeChanged>66883,59950.105368206</TimeChanged>
<TimeCreated>59592,28773.586903</TimeCreated>

<Method name="classNameX">
<Description>
return current class unlike %ClassName this is a class method</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; vraci jmeno tridy
  quit "CavS"
]]></Implementation>
</Method>

<Method name="ExpPublVysl">
<Description><![CDATA[
<pre> Specialni vystup pro cav - CELKOVÉ PUBLIKAČNÍ VÝSLEDKY V AV ČR      pP("TypV")=1
   a  Specialni vystup pro cav - PUBLIKAČNÍ VÝSLEDKY VE VĚDNÍCH OBLASTECH pP("TypV")=2

02.04.15 jk; vystup jde do utf-8
09.12.09 tt; zalozena metoda
</pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pEnvironment,pPar:%String=""]]></FormalSpec>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
  s pP="",OFN="",pErr=""         ; pomocne promenne
  
  ; zpracovani parametru
  d ..repPar(.pP,pPar)
  ; otevreni souboru
  s pErr=pErr_##class(util.ie.CheckBase).repSoub(.pP,.OFN,1)    
  ; vyhodnoceni vybranych zaznamu
  d ..ExpPVGetData(.pP, .OFN, .pErr)
  
  ; zacatek vystupu
  ; 02.04.15 jk; vystup jde do utf-8
  d OFN.WriteLine("<meta http-equiv=""Content-Type"" content=""text/html; charset=utf-8"">")
  d OFN.WriteLine("<html><head></head><body><table border=""1"">")
  
  if (pErr'="")
  { ; Pokud chyba, vypiseme
    for j=1:1:$l(pErr,$c(10))
    { ; vypis chyb do souboru
      d OFN.WriteLine("<tr><td colspan=20 align=""center""><b>"_$p(pErr,$c(10),j)_"</b></td></tr>")    
    }
  }
  else
  { ; pokud nemame chyby, vypiseme tabulky
    ; metoda pro CELKOVÉ PUBLIKAČNÍ VÝSLEDKY V AV ČR      pP("TypV")=1
    d:(pP("TypV")=1) ..ExpPVWCelkPub(.pP, .OFN, .pErr)
    ; metoda pro PUBLIKAČNÍ VÝSLEDKY VE VĚDNÍCH OBLASTECH pP("TypV")=2
    d:(pP("TypV")=2) ..ExpPVWPubObl(.pP, .OFN, .pErr)
  }
  ; konec vystupu
  d OFN.WriteLine("</table></body></html>")   
  
  ; zavreni souboru  
  d ##class(util.ie.CheckBase).repSoub(.stPref,.OFN,0)   
  ; konec
  q ""                           ; konec
]]></Implementation>
</Method>

<Method name="repPar">
<Description><![CDATA[
<pre> Metoda pro nacteni parametru do struktury reportu.
Parametry:  pP   - globalni parametry vystupu
            pPar - parametr prijaty pri volani reportu
            
10.12.09 tt; metoda zalozena
</pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pP:%Binary,pPar]]></FormalSpec>
<PublicList>sOFileWithPath,sExportOpt,sRetMsg,sSelectCrit,sSelectCrit2,sSortFld,cDelimCrit,cDelimSpace,cDelimVals,nRecCount,sClass,sClassList,sSelectCrit2,bCaseSensitive,pnVerboseMode,sSymbExp1,sOFileBase</PublicList>
<Implementation><![CDATA[
  ; nastaveni selekcnich kritirii
  s pP("InPar1")="params: "_pPar                     ; ukladaji se parametry pro vypis 
  s pP("Cesta")=$$$strswap(sOFileWithPath,sOFileBase,$p(pPar," ",1)) ; cesta k aktualnimu souboru
  s pP("InPar2")="sOFileWithPath: "_sOFileWithPath   ; poznamky do vysledneho souboru 
  s pP("InPar3")="sExportOpt: "_sExportOpt
  s pP("InPar4")="sSelectCrit: "_sSelectCrit
  s pP("InPar4_4")=sSelectCrit
  s pP("InPar5")="sSelectCrit2: "_sSelectCrit2
  s pP("InPar6")="sSortFld: "_sSortFld
  s pP("InPar7")="cDelimCrit: "_cDelimCrit
  s pP("InPar8")="cDelimSpace: "_cDelimSpace
  s pP("InPar9")="cDelimVals: "_cDelimVals
  s pP("Prefix")=##class(User.Util).getClassPrefixParam(sClass)
  s pP("TypV")=$p(pPar," ",2)                        ; typ vystupu
  
  for i=1:1  
  { ; toto je cyklus pro cteni selekcnich parametru 
    s sPomPar=$p(sSelectCrit,cDelimCrit,i) q:sPomPar=""
    s sPomPar=##class(User.Util).strswap(sPomPar,"!","")
    s sPomPar=##class(User.Util).strswap(sPomPar,cDelimVals,"~")
    s sPomPar=##class(User.Util).strswap(sPomPar,cDelimSpace," ")
    s sPomPP1=$p(sPomPar," ",1),sPomPP2=$p(sPomPar," ",2)
    
    if sPomPP1="ye" 
    { ; zjisteni zadanych roku
      s pP("RC")=$p(sPomPar," ",3) 
      s pP("RCZ")=$p(pP("RC"),"~",1)
      s pP("RCK")=$p(pP("RC"),"~",2)
      s pP("RokZ")=$e(pP("RCZ"),1,4)
      s pP("RokK")=$e(pP("RCK"),1,4)
      s pP("RokP")=pP("RokK")-pP("RokZ")+1
    }    
  }
]]></Implementation>
</Method>

<Method name="ExpPVGetData">
<Description><![CDATA[
<pre> Metoda, ktera rozlozi aktivlist na handly a posila je na zpracovani dal
      na ziskani hodnot
      
Parametry:
 pP     - ulozene parametry
 OFN    - odkaz na soubor 
 pErr   - retezec chyb            

09.12.09 tt; metoda zalozena
</pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pP:%Binary,&OFN:%Binary,&pErr:%String]]></FormalSpec>
<Implementation><![CDATA[
 s idx="",brk=0  ; definice pomocnych promennych
 
 f  
 { ; cyklus pro prochazeni vyselektovanych zaznamu
   if $e(pP("InPar4_4"),1)="%"     ; nacitani savelistu
   { ; cyklus pre ulozeny savelist
     s idx=$o(^$$$ListsG("lists",pP("InPar4_4"),idx)),id=idx
   }
   else
   { ; cyklus pres aktiv select list
     s idx=$o(^$$$ListsG($$$ListsActiveSel,$j,idx)),id=idx
   }
   k pP("REC")                                       ; promazani TMP udaju
   if $f(id,"*") s id=$p(id,"*",2)                   ; odstranit triediaci prefix/sufix
   q:((id="") || brk)                                ; konec pokud mame priznak
   
   ; Zpracovavani jednoho zaznamu
   if '##class(User.MARC).getDATAX(.handle,id) s brk=1 s pErr=pErr_"ERROR: ExpPVGetData - record id:"_id_" not found!" continue
   s pP("REC","T001")=$$$HandleT001(handle)          ; ziskani t001
   s pP("REC","970b")=$$$getTagX(.handle,"970b")     ; zjisteni 970b
   s pP("REC","101a")=$$$getTagX(.handle,"101a")     ; zjisteni 101a
   s pP("REC","C26e")=""      
   
   s idc=##class(MARC).recordIdX(.handle)       ; ziskani id
   s sPomYE1="",sPomYE=""
  
   for  
   { ; nacteni informaci z indexu ye
     set sPomYE1=$o(^$$$MarcIndexG("CavUnEpca",idc,"ye",sPomYE1)) 
     q:sPomYE1=""  
     s sPomYE=sPomYE_" "_sPomYE1
   }
   ; chyba, pokud nema zaznam index ye
   s:(sPomYE="") pErr=pErr_"ERROR: Záznam 001: "_pP("REC","T001")_" nemá vyplněný index ye."_$c(10) 
   
   s sPomPrac=",",sCSekce=0,sPomSekce=""
   s sT7XX=##class(MARC).getTagX(.handle,"7**",-1)
   ; jsou definovany na dvou mistech
   s pP("sSekce1")=",ASU-R,FZU-D,MU-W,UIVT-O,UJF-V,UTIA-B,URE-Y,UFM-A,UFP-V,UH-J,UPT-D,UTAM-F,UT-L,GFU-E,GLU-S,UFA-U,UGN-S,USMH-B,"
   s pP("sSekce2")=",UIACH-O,UACH-T,UCHP-M,UFCH-W,UMCH-V,UOCHB-X,BFU-R,FGU-C,MBU-M,UEB-Q,UEM-P,UMG-J,UZFG-Y,BC-A,BU-J,UBO-W,UEK-B,BTO-N,ENTU-I,HBU-Z,PAU-O,UMBR-M,UPB-H,SLCHPL-S,"
   s pP("sSekce3")=",KNAV-K,NHU-N,PSU-E,SOU-Z,USP-I,ARUB-Q,ARU-G,HIU-Y,MSUA-W,UDU-I,USD-C,UEF-S,FLU-F,OU-W,SLU-S,UCL-M,UJC-A,A-Z,MSU-R,"
   
   
   /* - povodni brani pracoviste ze zanamu, po novu se bere z indexu zaznamu. Je to jistejsi  
   for i=1:1:$l(sT7XX,$c(10))  
   { ; nacteni vsech zucastnenych pracovist na zaznamu
     s sT7XX1=$p(sT7XX,$c(10),i)
     s sT7XX1p=##class(MARC).getSubTagStr(sT7XX1,"p") continue:(sT7XX1p="") 
     s:($f(pP("sSekce1"),$zcvt(sT7XX1p,"U"))) sCSekce=1
     s:($f(pP("sSekce2"),$zcvt(sT7XX1p,"U"))) sCSekce=2
     s:($f(pP("sSekce3"),$zcvt(sT7XX1p,"U"))) sCSekce=3
     
     s:(('$f(sPomPrac,","_sT7XX1p_","))&&('$f(sPomSekce,sCSekce))) sPomPrac=sPomPrac_sT7XX1p_","
     s sPomSekce=sPomSekce_sCSekce   
   }
   */
   s sPomPRA1="",sCSekce="0"
   for 
   { ; nacteni vsech zucastnenych pracovist na zaznamu
     set sPomPRA1=$o(^$$$MarcIndexG("CavUnEpca",idc,"pra",sPomPRA1)) 
     q:sPomPRA1=""                             ; pokud neni hodnota, ukoncime     
     s sT7XX1p=$tr($zcvt(sPomPRA1,"U")," ","")
     s:($f(pP("sSekce1"),sT7XX1p)) sCSekce=1   ; ulozime sekci, pokud je nalezena
     s:($f(pP("sSekce2"),sT7XX1p)) sCSekce=2
     s:($f(pP("sSekce3"),sT7XX1p)) sCSekce=3     
     s:(('$f(sPomPrac,","_sT7XX1p_","))&&('$f(sPomSekce,sCSekce))&&(sCSekce'="")) sPomPrac=sPomPrac_sT7XX1p_","
     s sPomSekce=sPomSekce_sCSekce             ; pridame sekci
     s sCSekce="0"                              ; vynulovani sekce
   }
   ; pokud neneajdu pracoviste v sekcich
   ;s:(sPomPrac=",") sPomPrac=",xxx,"
   
   for k=1:1:$l(sPomPrac,",")
   { ; pro vsechny zucastnene pracoviste
     s pP("REC","C26e")=$p(sPomPrac,",",k)  
     continue:(pP("REC","C26e")="")

     for l=1:1:$l(sPomYE," ")
     { ; mame vybrane vstupni data, muzeme pokracovat
       s pP("REC","Rok")=$p(sPomYE," ",l)
       ; zavolani metody pro ulozeni dat jednoho handlu
       continue:(pP("REC","Rok")="")
       d ..ExpPVHanlde(.pP,.handle,.pErr)      
     }   
     q:(pP("TypV")=1)
   }
 }
]]></Implementation>
</Method>

<Method name="ExpPVHanlde">
<Description><![CDATA[
<pre> Metoda, ktera ulozi data jednoho handlu do struktury pP podle roku
      
Parametry:
 pP     - ulozene parametry
 handle - aktualni zpracovavany handle
 pErr   - retezec chyb            

10.12.09 tt; metoda zalozena
</pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pP:%Binary,&handle:%Binary,&pErr:%String]]></FormalSpec>
<Implementation><![CDATA[
  ; definice sekci a urceni cisla sekce pro vystup publikacnich vysledku ve vednich oborech
  ; zmeneno rozdeleni do sekci
  s sCSekce=0,sCisloBunky="XX"                          ; definice na nulu, pokud nebyla sekce nalezena
  ; jsou definovany na dvou mistech
  s sSekce1=",ASU-R,FZU-D,MU-W,UIVT-O,UJF-V,UTIA-B,URE-Y,UFM-A,UFP-V,UH-J,UPT-D,UTAM-F,UT-L,GFU-E,GLU-S,UFA-U,UGN-S,USMH-B,"
  s sSekce2=",UIACH-O,UACH-T,UCHP-M,UFCH-W,UMCH-V,UOCHB-X,BFU-R,FGU-C,MBU-M,UEB-Q,UEM-P,UMG-J,UZFG-Y,BC-A,BU-J,UBO-W,UEK-B,BTO-N,ENTU-I,HBU-Z,PAU-O,UMBR-M,UPB-H,SLCHPL-S,"
  s sSekce3=",KNAV-K,NHU-N,PSU-E,SOU-Z,USP-I,ARUB-Q,ARU-G,HIU-Y,MSUA-W,UDU-I,USD-C,UEF-S,FLU-F,OU-W,SLU-S,UCL-M,UJC-A,A-Z,MSU-R,"
    
  s:($f(sSekce1,$zcvt(pP("REC","C26e"),"U"))) sCSekce=1
  s:($f(sSekce2,$zcvt(pP("REC","C26e"),"U"))) sCSekce=2
  s:($f(sSekce3,$zcvt(pP("REC","C26e"),"U"))) sCSekce=3
  
  ; sCisloBunky - sklada se z radek_sloupec
  if (pP("REC","970b")="B") 
  { ; kategorie - knihy
    s:(pP("REC","101a")="cze") sCisloBunky="11"
    s:(pP("REC","101a")'="cze") sCisloBunky="12"
    ;s:(sCSekce=2) p
  }
  if (pP("REC","970b")="M")
  { ; kategorie - stati v knihach
    s:(pP("REC","101a")="cze") sCisloBunky="21"
    s:(pP("REC","101a")'="cze") sCisloBunky="22"
  }
  if (pP("REC","970b")="J")
  { ; kategorie - clanky ve vedeckych casopisech
    s:(pP("REC","101a")="cze") sCisloBunky="31"
    s:(pP("REC","101a")'="cze") sCisloBunky="32"
  }
  if ((pP("REC","970b")="G")||(pP("REC","970b")="H"))
  { ; kategorie - sborniky z konferenci
    s:(pP("REC","101a")="cze") sCisloBunky="41"
    s:(pP("REC","101a")'="cze") sCisloBunky="42"
  }
  if ((pP("REC","970b")="C")||(pP("REC","970b")="K"))
  { ; kategorie - prispevky ve sbornicich
    s:(pP("REC","101a")="cze") sCisloBunky="51"
    s:(pP("REC","101a")'="cze") sCisloBunky="52"
  }
  ; kategorie - preklady
  s:(pP("REC","970b")="T") sCisloBunky="61"
  ; kategorie - recenze
  s:(pP("REC","970b")="R") sCisloBunky="71"
  ; kategorie - odborne clanky v dennim tisku
  s:(pP("REC","970b")="N") sCisloBunky="81"
  ; kategorie - vyzkumne zpravy
  s:(pP("REC","970b")="V") sCisloBunky="91"
    
  ; ulozeni dat do struktury
  ; pP("REC","Rok"),sCSekce,sCisloBunky
  if $d(pP(pP("REC","Rok"),sCSekce,sCisloBunky))
  { ; pokud hodnota existuje, prictu 1
    s pP(pP("REC","Rok"),sCSekce,sCisloBunky)=pP(pP("REC","Rok"),sCSekce,sCisloBunky)+1
  }
  else 
  { ; pokud hodnota neexistuje, zalozim ji
    s pP(pP("REC","Rok"),sCSekce,sCisloBunky)=1
  }
]]></Implementation>
</Method>

<Method name="ExpPVWCelkPub">
<Description><![CDATA[
<pre> Metoda pro vypis dat CELKOVÉ PUBLIKAČNÍ VÝSLEDKY V AV ČR
      vypis probiha po jednotlivych radcich
      
Parametry:
 pP     - ulozene parametry
 OFN    - odkaz na soubor 
 pErr   - retezec chyb            

11.12.09 tt; metoda zalozena
</pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pP:%Binary,&OFN:%Binary,&pErr:%String]]></FormalSpec>
<Implementation><![CDATA[
 for line=1:1:21
 { ; vypisujeme radek po radku
   d OFN.WriteLine("<tr>")
   if line=1
   { ; do prvniho radku vypiseme
     d OFN.WriteLine("<td style=""width: 50pt;""></td><td></td>")
     for i=1:1:pP("RokP") d OFN.WriteLine("<td style=""width: 50pt;""></td><td style=""width: 66pt;""></td>")       
   }
   if (line>1) d OFN.WriteLine("<td></td>")  ; prvni bunka prazdna
   ; vypis prazdneho radku
   if ((line=2)||(line=3)||(line=18)||(line=21)) d OFN.WriteLine("<td colspan="""_(1+(2*pP("RokP")))_"""></td>")   
   if (line=4) d OFN.WriteLine("<td colspan="""_(1+(2*pP("RokP")))_""" align=""center""><b>CELKOVÉ PUBLIKAČNÍ VÝSLEDKY V AV ČR</b></td>")  
   if (line=5) d OFN.WriteLine("<td colspan="""_(1+(2*pP("RokP")))_""">(konkrétní údaje včetně jejich členění po sekcích budou rozdávány až na zasedání Akademického sněmu AV ČR)</td>")
   if (line=6) d OFN.WriteLine("<td></td><td colspan="""_(2*pP("RokP"))_""" align=""center""><b>Publikační výsledky</b></td>") 
   if (line=7) 
   { ; vypis sedmeho radku
     d OFN.WriteLine("<td align=""center""><b>Typ publikace</b></td>")
     for i=0:1:(pP("RokP")-1) 
     { ; vypisuji se roky postupne
       s sPomRok=pP("RokZ")+i
       s:(i=(pP("RokP")-1)) sPomRok=sPomRok_"*)"  ; pokud posledni rok, tak na konci *
       d OFN.WriteLine("<td colspan=""2"" align=""center"">rok vydání "_sPomRok_"</td>")  
     }
   }
   if (line=8)
   { ; vypis hlavicky jazyku
     d OFN.WriteLine("<td></td>")
     for i=1:1:pP("RokP") d OFN.WriteLine("<td align=""center"">české</td><td align=""center"">cizojazyčné</td>")       
   }
   if ((line>=9)&&(line<=17))
   { ; 
     d:(line=9) OFN.WriteLine("<td>Knihy</td>")
     d:(line=10) OFN.WriteLine("<td>Stati v knihách</td>")
     d:(line=11) OFN.WriteLine("<td>Články ve vědeckých časopisech</td>")
     d:(line=12) OFN.WriteLine("<td>Sborníky z konferencí</td>")
     d:(line=13) OFN.WriteLine("<td>Příspěvky ve sbornících</td>")
     d:(line=14) OFN.WriteLine("<td>Překlady</td>")
     d:(line=15) OFN.WriteLine("<td>Recenze</td>")
     d:(line=16) OFN.WriteLine("<td>Odborné články v denním tisku</td>")
     d:(line=17) OFN.WriteLine("<td>Výzkumné zprávy </td>")

     for i=0:1:(pP("RokP")-1) 
     { ; vypisuji se roky postupne
       s sPomRok=pP("RokZ")+i
       d:(line<=13) OFN.WriteLine("<td align=""center""><b>"_..ExpPVWGetH(.pP,sPomRok,line-8,1)_"</b></td><td align=""center""><b>"_..ExpPVWGetH(.pP,sPomRok,line-8,2)_"</b></td>")
       d:(line>=14) OFN.WriteLine("<td align=""center"" colspan=""2""><b>"_(..ExpPVWGetH(.pP,sPomRok,line-8,1)+..ExpPVWGetH(.pP,sPomRok,line-8,2))_"</b></td>")
     }    
   }   
   if (line=19) d OFN.WriteLine("<td colspan="""_(1+(2*pP("RokP")))_""">*) údaje za rok "_pP("RokK")_" jsou neúplné, protože publikace s vročením daného roku vycházejí ještě i během roku následujícího</td>")   
   if (line=20) d OFN.WriteLine("<td colspan="""_(1+(2*pP("RokP")))_""">Poznámka: agregované údaje pro AV ČR nejsou součtem údajů po vědních oblastech vzhledem k tomu, že na jedné práci se mohou podílet pracovníci z více ústavů. Taková práce je započítána u každého ústavu a v souhrnu jen jednou.</td>")   
   d OFN.WriteLine("</tr>") ; konec radku        
 }
]]></Implementation>
</Method>

<Method name="ExpPVWPubObl">
<Description><![CDATA[
<pre> Metoda pro vypis dat PUBLIKACNÍ VÝSLEDKY VE VEDNÍCH OBLASTECH
      vypis probiha po jednotlivych radcich.
      
Parametry:
 pP     - ulozene parametry
 OFN    - odkaz na soubor 
 pErr   - retezec chyb            

11.12.09 tt; metoda zalozena
</pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pP:%Binary,&OFN:%Binary,&pErr:%String]]></FormalSpec>
<Implementation><![CDATA[
  for line=1:1:20
  { ; vypisujeme radek po radku
    d OFN.WriteLine("<tr>")
    if line=1
    { ; do prvniho radku vypiseme
      d OFN.WriteLine("<td width=""20""></td><td></td>")
      for i=1:1:pP("RokP") d OFN.WriteLine("<td width=""63""></td><td width=""63""></td><td width=""63""></td><td width=""63""></td><td width=""63""></td><td width=""63""></td>")       
    }
    if (line>1) d OFN.WriteLine("<td></td>")  ; prvni bunka prazdna
    ; vypis prazdneho radku
    if ((line=16)||(line=17)) d OFN.WriteLine("<td colspan="""_(1+(6*pP("RokP")))_"""></td>")   
    if (line=2) d OFN.WriteLine("<td colspan="""_(1+(6*pP("RokP")))_""" align=""center""><b>PUBLIKAČNÍ VÝSLEDKY VE VĚDNÍCH OBLASTECH</b></td>")  
    ; slozeni radku 3
    s sRad3="<td valign=""middle"" rowspan=""3"" align=""center""><b>Typ publikace</b></td>"_
            "<td colspan="""_(2*pP("RokP"))_""" align=""center"">1. - 3. sekce</td>"_
            "<td colspan="""_(2*pP("RokP"))_""" align=""center"">4. - 6. sekce</td>"_
            "<td colspan="""_(2*pP("RokP"))_""" align=""center"">7. - 9. sekce</td>"  
    if (line=3) d OFN.WriteLine(sRad3)         
    if (line=4) 
    { ; vypis sedmeho radku
      for j=1:1:3
      { ; vypisuji po sekcich
        for i=0:1:(pP("RokP")-1) 
        { ; vypisuji se roky postupne
          s sPomRok=pP("RokZ")+i
          s:(i=(pP("RokP")-1)) sPomRok=sPomRok_"*)"  ; pokud posledni rok, tak na konci *
          d OFN.WriteLine("<td colspan=""2"" align=""center"">rok vydání "_sPomRok_"</td>")  
        }
      }
    }
    if (line=5)
    { ; vypis hlavicky jazyku      
      for i=1:1:(pP("RokP")*3) d OFN.WriteLine("<td align=""center"">české</td><td align=""center"">cizojaz.</td>")       
    }
    if ((line>=6)&&(line<=14))
    { ; vypsani hodnot do tabulky
      d:(line=6) OFN.WriteLine("<td>Knihy</td>")
      d:(line=7) OFN.WriteLine("<td>Stati v knihách</td>")
      d:(line=8) OFN.WriteLine("<td>Články ve vědeckých časopisech</td>")
      d:(line=9) OFN.WriteLine("<td>Sborníky z konferencí</td>")
      d:(line=10) OFN.WriteLine("<td>Příspěvky ve sbornících</td>")
      d:(line=11) OFN.WriteLine("<td>Překlady</td>")
      d:(line=12) OFN.WriteLine("<td>Recenze</td>")
      d:(line=13) OFN.WriteLine("<td>Odborné články v denním tisku</td>")
      d:(line=14) OFN.WriteLine("<td>Výzkumné zprávy </td>")
      
      for k=1:1:3
      { ; pres tri sekce
        for i=0:1:(pP("RokP")-1) 
        { ; vypisuji se roky postupne
          s sPomRok=pP("RokZ")+i
          ; vypis hodnoty
          d:(line<=10) OFN.WriteLine("<td align=""center""><b>"_..ExpPVWGetH(.pP,sPomRok,line-5,1,k)_"</b></td><td align=""center""><b>"_..ExpPVWGetH(.pP,sPomRok,line-5,2,k)_"</b></td>")
          ; slouceni bunek
          d:(line>=11) OFN.WriteLine("<td align=""center"" colspan=""2""><b>"_(..ExpPVWGetH(.pP,sPomRok,line-5,1,k)+..ExpPVWGetH(.pP,sPomRok,line-5,2,k))_"</b></td>")
        } 
      } 
    }   
    if (line=15) d OFN.WriteLine("<td colspan="""_(1+(6*pP("RokP")))_""">*) údaje za rok "_pP("RokK")_" jsou neúplné, protože publikace s vročením daného roku vycházejí ještě i během roku následujícího</td>")   
    if (line=18) d OFN.WriteLine("<td>sekce 1-3</td><td colspan="""_(6*pP("RokP"))_""">ASU-R or FZU-D or MU-W or UIVT-O or UJF-V or UTIA-B or URE-Y or UFM-A or UFP-V or UH-J or UPT-D or UTAM-F or UT-L or GFU-E or GLU-S or UFA-U or UGN-S or USMH-B</td>")   
    if (line=19) d OFN.WriteLine("<td>sekce 4-6</td><td colspan="""_(6*pP("RokP"))_""">UIACH-O or UACH-T or UCHP-M or UFCH-W or UMCH-V or UOCHB-X or BFU-R or FGU-C or MBU-M or UEB-Q or UEM-P or UMG-J or UZFG-Y or BC-A or BU-J or UBO-W or UEK-B or BTO-N or ENTU-I or HBU-Z or PAU-O or UMBR-M or UPB-H or SLCHPL-S</td>")   
    if (line=20) d OFN.WriteLine("<td>sekce 7-9</td><td colspan="""_(6*pP("RokP"))_""">KNAV-K or NHU-N or PSU-E or SOU-Z or USP-I or ARUB-Q or ARU-G or HIU-Y or MSUA-W or UDU-I or USD-C or UEF-S or FLU-F or OU-W or SLU-S or UCL-M or UJC-A or A-Z or MSU-R</td>")   
    d OFN.WriteLine("</tr>") ; konec radku        
 }
]]></Implementation>
</Method>

<Method name="ExpPVWGetH">
<Description><![CDATA[
<pre> Pomocna metoda pro ziskani informaci pro urcene policko
      
Parametry:
 pP     - ulozene parametry
 pRok   - rok, ktery vypisujeme
 pLine  - radek, ktery vypisujeme
 pPoz   - pozice na radku, kterou vypisujeme
 pSekce - sekce, kterou vypisujeme, pokud neni zadana, vypisuji se hodnoty
          za vsechny sekce v souctu          

11.12.09 tt; metoda zalozena
</pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pP:%Binary,pRok,pLine,pPoz,pSekce=""]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s nRet=0    ; definice pomocne promenne
   
  if pSekce=""
  { ; pokud je sekce prazdna, musime secist hodnoty
    for i=0:1:4
    { ; cyklus pres vsechny hodnoty a kategorie
      if ($d( pP(pRok,i,pLine_pPoz))#10)   
      { ; pokud je hodnota v uzlu,secteme
        s nRet=nRet+pP(pRok,i,pLine_pPoz)
      }
    }
  }
  else
  { ; mame zadanou urcitou funkcnost
    if ($d( pP(pRok,pSekce,pLine_pPoz))#10)   
    { ; pokud je hodnota v uzlu,secteme
      s nRet=nRet+pP(pRok,pSekce,pLine_pPoz)
    }
  }   
  
  q nRet  ; vratim vyplnenou hodnotu, nebo 0
]]></Implementation>
</Method>

<Method name="ExpSetPracAuth">
<Description><![CDATA[
<pre> Metoda slouzi jako vstupni bod vystupu pro vypocet bodoveho ohodnoceni
jednotlivych epca zaznamu
 
Parametry
   pPar - parametry - oddelene carkou
          1. debag mod - jestli 1, vypisuji se pomocne texty - zatim nepouzity
          2. šablona hlavičky  ; HEAD_SET_PRAC_AUTH

10.05.10 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pEnvironment:%Binary,pPar:%String=""]]></FormalSpec>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
  s pP="",OFN="",pErr=""         ; pomocne promenne
  s pP("SelKr","PRA")="",pP("SelKr",".ZAPIS")=0
  
  ; nacteni parametru, obecna metoda
  d ..repParO(.pP,pPar)                          
  ; otevreni souboru
  s pErr=pErr_##class(util.ie.CheckBase).repSoub(.pP,.OFN,1)    
  ; vypis hlavicky souboru
  d:($d(pP("VPar",2))) ##class(util.ie.CheckBase).repHead(.OFN,.pP,pP("VPar",2)) 
  ; vypisovani do souboru a pocitani ohodnoceni
  d ..ExpSetPracA1(.pP,.OFN,.pErr)                               
  ; vypiseme paticku souboru
  d ##class(util.ie.CheckBase).repEnd(.OFN)              
  ; uzavreni souboru
  d ##class(util.ie.CheckBase).repSoub(.stPref,.OFN,0)     
  q ""                 ; konec
]]></Implementation>
</Method>

<Method name="repParO">
<Description><![CDATA[
<pre> Metoda pro nacteni obecnych parametru do struktury reportu.
Parametry:  pP   - globalni parametry vystupu
            pPar - parametr prijaty pri volani reportu
            
10.05.10 tt; metoda zalozena
</pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pP:%Binary,pPar]]></FormalSpec>
<PublicList>sOFileWithPath,sExportOpt,sRetMsg,sSelectCrit,sSelectCrit2,sSortFld,cDelimCrit,cDelimSpace,cDelimVals,nRecCount,sClass,sClassList,sSelectCrit2,bCaseSensitive,pnVerboseMode,sSymbExp1,sOFileBase</PublicList>
<Implementation><![CDATA[
  ; nastaveni selekcnich kritirii
  s pP("Cesta")=sOFileWithPath
  s pP("InPar1")="params: "_pPar                     ; ukladaji se parametry pro vypis 
  s pP("InPar2")="sOFileWithPath: "_sOFileWithPath   ; poznamky do vysledneho souboru 
  s pP("InPar3")="sExportOpt: "_sExportOpt
  s pP("InPar4")="sSelectCrit: "_sSelectCrit
  s pP("InPar4_4")=sSelectCrit
  s pP("InPar5")="sSelectCrit2: "_sSelectCrit2
  s pP("InPar6")="sSortFld: "_sSortFld
  s pP("InPar7")="cDelimCrit: "_cDelimCrit
  s pP("InPar8")="cDelimSpace: "_cDelimSpace
  s pP("InPar9")="cDelimVals: "_cDelimVals
  s pP("Prefix")=##class(User.Util).getClassPrefixParam(sClass)
  
  for j=1:1:$l(pPar,",")
  { ; postupne nacitani parametru
    s pP("VPar",j)=$p(pPar,",",j)
  }
  
  for i=1:1  
  { ; toto je cyklus pro cteni selekcnich parametru 
    s sPomPar=$p(sSelectCrit,cDelimCrit,i) q:sPomPar=""
    s sPomPar=##class(User.Util).strswap(sPomPar,"!","")
    s sPomPar=##class(User.Util).strswap(sPomPar,cDelimVals,"~")
    s sPomPar=##class(User.Util).strswap(sPomPar,cDelimSpace," ")
    s sPomPP1=$p(sPomPar," ",1),sPomPP2=$p(sPomPar," ",2)
    
    ; ulozim si vsechny selekcni kriteria        
    s pP("SelKr",sPomPP1)=$p(sPomPar," ",3)  
  }
]]></Implementation>
</Method>

<Method name="ExpSetPracA1">
<Description><![CDATA[
<pre> Metoda, provede operaci a ulozi vypis do vystupu
      
Parametry:
 pP     - ulozene parametry
 OFN    - odkaz na soubor 
 pErr   - retezec chyb            

17.12.19 tt; provedena zmena doplneni oddeleni a vyhodnoceni podminky
24.09.19 tt; provedena uprava, aby se oddeleni upravovalo na i,j,k,l - nova funkcnost oddeleni
16.05.16 tt; uprava vypisu informaci u vystupu uprava pracovist
17.05.10 tt; pridana varianta pro odstraneni oddeleni, prepracovani vkladani 
             oddeleni, aby se vkladaly vsechny opakovani C06 podpole $$h
10.05.10 tt; metoda zalozena
</pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pP:%Binary,&OFN:%Binary,&pErr:%String]]></FormalSpec>
<PublicList>pEnvironment</PublicList>
<Implementation><![CDATA[
  s idx="",id="", brk=0, pP("AllT")="", sZmena=0  ; definice pomocne promenne
  
  f  
  { ; cyklus pro prochazeni vyselektovanych zaznamu
    s idx=$o(^$$$ListsG($$$ListsActiveSel,$j,idx)),id=idx
    if $f(id,"*") s id=$p(id,"*",2)   ; odstranit triediaci prefix/sufix
    q:((id="") || brk)                ; ukoncime, jestli narazime na konec nebo chybu

    k pP("Rec") ; vymazeme udaje o jednom zaznam
    ; nedotahuji ze txx tagy
    if '##class(User.MARC).getDATAX(.handle,id) s brk=1 s pErr=pErr_"Err: symSetPracAuth - record id:"_id_" not found!" continue
    ; mame nacteny handle, muzeme zacit zpracovavat zaznam po zaznamu
    s s=##class(User.MARC).getTagX(.handle,"70*",-1),sOLD=s continue:s=""
    s sT001=$$$HandleT001(handle)
    
    f i=1:1:$l(s,$c(10))
    { ;  2. prohledavam kazdy tag 7xx
      s s1=$p(s,$c(10),i)   ; nacteme jedno opakovani 7xx
      
      s sO=##class(User.MARC).getSubTagStr(s1,"o")  ; oddelenie
      s sP=##class(User.MARC).getSubTagStr(s1,"p")  ; pracovisko
      s sI=##class(User.MARC).getSubTagStr(s1,"i")  ; oddelenie
      s sJ=##class(User.MARC).getSubTagStr(s1,"j")  ; oddelenie

      if ((pP("SelKr",".ZAPIS")=0)||(pP("SelKr",".ZAPIS")=1))
      { ; pro doplneni oddeleni
        ; 17.12.19 tt; provedena zmena doplneni oddeleni a vyhodnoceni podminky
        continue:(sI'="")||(sJ'="")     ; 3. pokud ma vyplnene 7**$o koncim
        continue:((sP="") || (sP'=pP("SelKr","pra")))  ; 4. pokud ma 7xx $p = zvoleny ustav, pokracujeme
        s s3=##class(User.MARC).getSubTagStr(s1,"3")    ; odkaz
        if '##class(User.MARC).readLX(.handleA,s3) continue
        ; heslo anglicky je v 960a
        s tC06=##class(User.MARC).getTagX(.handleA,"C06") 
        ;s:(tC06h'="") s1=s1_$c(31)_"o"_tC06h,sZmena=1 ; pridano oddeleni
        ; pole $h
        ; 17.05.10 tt; prepracovani vkladani oddeleni, aby se vkladaly vsechny opakovani C06 podpole $$h
        /*s sAllH=##class(User.MARC).getSubTagStr(tC06, "h",-1)
        f l=1:1:$l(sAllH,$c(10))
        { ; doplnime vsechny opakovani podpole h
          s sH1 = $p(sAllH,$c(10),l)
          if (sH1'="") 
          { ; pokud mame hodnotu, doplnime
            s s1=s1_$c(31)_"o"_sH1
            s sZmena=1
          }
        }*/
        
        s sAllH=##class(User.MARC).getSubTagStr(tC06, "i",-1)
        f l=1:1:$l(sAllH,$c(10))
        { ; doplnime vsechny opakovani podpole i
          s sH1 = $p(sAllH,$c(10),l)
          if (sH1'="") 
          { ; pokud mame hodnotu, doplnime
            s s1=s1_$c(31)_"i"_sH1
            s sZmena=1
          }
        }
        s sAllH=##class(User.MARC).getSubTagStr(tC06, "j",-1)
        f l=1:1:$l(sAllH,$c(10))
        { ; doplnime vsechny opakovani podpole j
          s sH1 = $p(sAllH,$c(10),l)
          if (sH1'="") 
          { ; pokud mame hodnotu, doplnime
            s s1=s1_$c(31)_"j"_sH1
            s sZmena=1
          }
        }
        s sAllH=##class(User.MARC).getSubTagStr(tC06, "k",-1)
        f l=1:1:$l(sAllH,$c(10))
        { ; doplnime vsechny opakovani podpole k
          s sH1 = $p(sAllH,$c(10),l)
          if (sH1'="") 
          { ; pokud mame hodnotu, doplnime
            s s1=s1_$c(31)_"k"_sH1
            s sZmena=1
          }
        }
        s sAllH=##class(User.MARC).getSubTagStr(tC06, "l",-1)
        f l=1:1:$l(sAllH,$c(10))
        { ; doplnime vsechny opakovani podpole l
          s sH1 = $p(sAllH,$c(10),l)
          if (sH1'="") 
          { ; pokud mame hodnotu, doplnime
            s s1=s1_$c(31)_"l"_sH1
            s sZmena=1
          }
        }
        
      }
      ; 17.05.10 tt; pridana varianta pro odstraneni oddeleni
      if ((pP("SelKr",".ZAPIS")=2)||(pP("SelKr",".ZAPIS")=3))
      { ; pro smazani oddeleni
        continue:((sP="") || (sP'=pP("SelKr","pra")))  ; 4. pokud ma 7xx $p = zvoleny ustav, pokracujeme
        ; odstranime oddeleni pracoviste
        //s s1 = ##class(User.MARC).setSubTagStr(s1,$c(31)_"o"),sZmena=1     
  
        s s1 = ##class(User.MARC).setSubTagStr(s1,$c(31)_"i"),sZmena=1          
        s s1 = ##class(User.MARC).setSubTagStr(s1,$c(31)_"j"),sZmena=1          
        s s1 = ##class(User.MARC).setSubTagStr(s1,$c(31)_"k"),sZmena=1          
        s s1 = ##class(User.MARC).setSubTagStr(s1,$c(31)_"l"),sZmena=1    
      }
      s $p(s,$c(10),i)=s1   ; ulozime do retezce jedno opakovani 7xx
    }
    
    ; kontroly jestli probehla zmena
    continue:(s=sOLD)
    d OFN.WriteLine("<div class=""UR1""><div class=""Nadpis1"">")
    d OFN.WriteLine("<div class=""col1"">Záznam: "_sT001_"</div>") 
    d OFN.WriteLine("<div class=""col2"">&nbsp;&nbsp;&nbsp;&nbsp;Původní:</div></div>") 
    for j=1:1:$l(sOLD,$c(10)) {
         continue:($f(($c(10)_s_$c(10)),($c(10)_$p(sOLD,$c(10),j)_$c(10))))
         d OFN.WriteLine("<div class=""Nadpis2"">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_$$$strswap($p(sOLD,$c(10),j),$c(31),"<strong>  $$</strong>")_"</div>")
    }
    d OFN.WriteLine("<div class=""Nadpis1""><div class=""col2"">&nbsp;&nbsp;&nbsp;&nbsp;Nový:</div></div>") 
    for l=1:1:$l(s,$c(10)) { 
        continue:($f(($c(10)_sOLD_$c(10)),($c(10)_$p(s,$c(10),l)_$c(10))))
       d OFN.WriteLine("<div class=""Nadpis2"">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_$$$strswap($p(s,$c(10),l),$c(31),"<strong>  $$</strong>")_"</div>")
     }
    d OFN.WriteLine("<div class=""Cara""></div>")   
    continue:($l(s)<8)  ; ochrana proto nespravym datum
    if ((pP("SelKr",".ZAPIS")=1)||(pP("SelKr",".ZAPIS")=3))
    { ; pokud mam zapisovat
      d ##class(User.MARC).setTagX(.handle,s)   ; ulozim tag
      s st=##class(User.MARC).writeX(.handle,1,,,3_$c(10)_$g(pEnvironment("user_name"))_$c(10)_$g(pEnvironment("ip")))   ; ulozeni handlu
      if '$$$ISOK(st) d OFN.WriteLine("Error: record written to database.")     
    } 
    d OFN.WriteLine("</div>")      
  }
  if (sZmena=0)
  { ; pokud nebyla zadna zmena, vypiseme hlasku
    d OFN.WriteLine("<div class=""UR1""><div class=""Nadpis1"">")
    d OFN.WriteLine("<div class=""col1"">Nebyla nalezena žádná změna v záznamech.</div></div></div>") 
  }
]]></Implementation>
</Method>

<Method name="test">
<Description>
d ##class(User.CavS).test()</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  s gnDEBUG=1
  ;s ret=##class(Util).DBCommand("report SPCommon exporta CavUnEpca,0 «¤»!ye¤bt¤2007»2009 .  . 0 . ##class(User.CavS).ExpPublVysl(.pEnvironment,""rep_CelkPublVysledky.csv¤1"") 1 0 . . . ."_$c(10)_"arl"_$c(10)_"127.0.0.1 ## i2ws 1acMohtp00 aRL ## F-CAV_36CFC76EE897B80F ## standalone v.2.0.156f (19.03.2009)"_$c(10)_"CMD_CAV_UN_EPCA")
  ;s ret=##class(Util).DBCommand("report SPCommon exporta CavUnEpca,0 «¤»!ye¤bt¤2007»2008«!exp¤=¤a .  . 0 . ##class(User.CavS).ExpPublVysl(.pEnvironment,""rep_PublVyslVedObl.xls¤2"") 1 1 . . . ."_$c(10)_"arl"_$c(10)_"90.176.241.209 ## i2ws 3bz8dRw100 aRL ## F-CAV_36CFC76EE897B80F ## standalone v.2.0.156e (26.09.2008)"_$c(10)_"CMD_CAV_UN_EPCA")

  ;s ret=##class(Util).DBCommand("report SPCommon exporta CavUnEpca,0 «¤»!ye¤bt¤2007»2007«!exp¤=¤a«!dk¤=¤V .  . 0 . ##class(User.CavS).ExpPublVysl(.pEnvironment,""rep_PublVyslVedObl.xls¤2"") 1 1 . . . ."_$c(10)_"arl"_$c(10)_"62.240.178.252 ## i2ws 3utbbR7x00 aRL ## F-CAV_36CFC76EE897B80F ## standalone v.2.0.156e (26.09.2008)"_$c(10)_"CMD_CAV_UN_EPCA")

  ;s ret=##class(Util).DBCommand("report SPCommon exporta CavUnEpca,0 «¤»!ye¤bt¤2007»2007«!exp¤=¤a .  . 0 . ##class(User.CavS).ExpPublVysl(.pEnvironment,""rep_PublVyslVedObl.xls¤2"") 1 1 . . . ."_$c(10)_"arl"_$c(10)_"62.240.178.252 ## i2ws 3u45acPn00 aRL ## F-CAV_36CFC76EE897B80F ## standalone v.2.0.156e (26.09.2008)"_$c(10)_"CMD_CAV_UN_EPCA")
  
 ; s ret=##class(User.Util).DBCommand("report ReportCommon exporta cav_is_user,cav_un_tablesd CavUnEpca,0 «¤»!yev¤=¤2017«.PAR1¤=¤V«!tag¤=¤C83 . . . . . ##class(User.CavS).repPrehledZaz(.pEnvironment,""C83"","""") 1 1 . . . . REPORTS_EPCA,RIVZMEN"_$c(10)_"arl"_$c(10)_"31.192.66.98 ## i2ws 9zdIHIrQZ1 aRL ## ## standalone v.3.4.214a  (18.01.2017)"_$c(10)_"CMD_CAV_UN_EPCA")
  s ret=##class(User.Util).DBCommand("report ReportCommon exporta cav_is_user,cav_un_tablesd CavUnEpca,0 «¤»!yev¤=¤2017«.PAR1¤=¤W«!T001¤=¤0473519«!tag¤=¤969«!ds¤=¤RIV . . . . . ##class(User.CavS).repPrehledZaz(.pEnvironment,""969"","""") 1 1 . . . . REPORTS_EPCA,RIVZMEN9"_$c(10)_"arl"_$c(10)_"31.192.66.98 ## i2ws KmIwLnanOo aRL ## ## standalone v.3.4.214a  (18.01.2017)"_$c(10)_"CMD_CAV_UN_EPCA")
 

  b ;konec 
  ;s ret=##class(Util).DBCommand("report SPCommon exporta CavUnEpca,0 «¤»!ye¤bt¤2008»2008 .  . 0 . ##class(User.CavS).ExpPublVysl(.pEnvironment,""rep_CelkPublVysledky.csv¤1"") 1 0 . . . ."_$c(10)_"arl"_$c(10)_"127.0.0.1 ## i2ws 1acMohtp00 aRL ## F-CAV_36CFC76EE897B80F ## standalone v.2.0.156f (19.03.2009)"_$c(10)_"CMD_CAV_UN_EPCA")
]]></Implementation>
</Method>

<Method name="RecNeodIpac">
<Description><![CDATA[
<pre>
Metoda pro zobrazení linku na záznamy, které nebyly odeslané do ipacu.
Volani 200     $a@##class(User.CavS).RecNeodIpac(.result,.handle,"")

 result     - hodnota pro vysledek
 handle     - aktualni zpracovavany handle 
 param      - parametry
              1 - prefix
              2 - index
              3 - text 
              4 - zobrazit link   
              5 - nezobrazovat ulove zaznamy (hodnota 1)
              6 - zobrazit lupu pro specialni druhy dokumentu 
              7 - zobrazit zpracovatelum a superuzivateli (hodnota 1- v podstate jakakoli krome prazdne) 

10.01.24 tt; pridan parametr na zobrazeni pro superuzivatele a zpracovatele (bez rozliseni prava)
11.01.19 tt; upravy kvuli zobrazeni lup a dalsi funkcnosti
12.01.17 tt; prepsana metoda pro zobrazeni neodeslanych zaznamu podle nove logiky indexu
22.07.10 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&result,&handle:%Binary,param:%String]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
  s sT001=$$$HandleT001(handle)         ; ziskani t001
  s sClass=$$$HandleClass(handle)       ; ziskani tridy
  s sLClass=##class(User.Util).objectName2lname(sClass)
  s sCilDat="cav_un_epca"
  s term=" "_sLClass_"*"_sT001
  s id="", sPocet=0,link=""
  for  
  {
    s id=$o(^$$$MarcIndexG("CavUnEpca","znnz",term,id))
    q:id=""
    s sPocet=sPocet+1    
  }
  
  ; pokud je 5 - parametr 1 a nebyly nalezene neodeslane zaznamy, nic nezobrazuj
  q:((sPocet=0)&&($p(param,"-",5)="1"))          
  s pPar1=$p(param,"-",1)                             ; prefix
  s sPref=##class(rep.zf.tf).prefix(.handle,pPar1)    ; ziskame prefix     
  
  s pPar2=$p(param,"-",2)                             ; index
  s:(pPar2="") pPar2="ZNNZ"
  s pPar3=##class(User.Util).strswap($p(param,"-",3),"\s"," ")  ; text - odescapovani textu
  s pPar4=$p(param,"-",4)                             ; zobrazit link 1 default - 0 jen text
  s:(pPar4="") pPar4=1  
  s pPar6=$p(param,"-",6) 
  s:($f(pPar6,$$$getTagX(.handle,"970b"))) pPar4=1
  
  if ($p(param,"-",7)'="") 
  {  ; 10.01.24 tt; pridan parametr na zobrazeni pro superuzivatele a zpracovatele (bez rozliseni prava)
     if ($$$WeAreInCSPContext)
     {
        s user=##class(i2.access).getLoginId()       ; ziskame id uzivatele
        q:(user="")    ; pokud nemame login kontext - ukoncime  
        s sUserR=##class(User.CavS).FTgetIsUser(user,sT001,"USER") ; metoda pro vygenerovani role uzivatele
        q:('($f(sUserR,"6")||$f(sUserR,"2")))
        s sCilDat="cav_un_epca-4"
     }    
  }     
  s:(pPar4=1) link="\q"_pPar2_"*"_sCilDat_"*1 "_sLClass_sT001_"\q"         
  s text=" ("_sPocet_") -"_pPar3
  s nLBlock=$o(result(""),-1)+1 
  s result(nLBlock)=sPref_" :"_link_text
  q
]]></Implementation>
</Method>

<Method name="FilterSymbI">
<Description><![CDATA[
<pre>
Ukazkova metoda - kostra uzivatelskeho filtrovaciho symboliku, zapojuje se
v CmConfig MARC_WBLISTS v tagu 220

Metoda se pouziva pro odfiltrovani tagu 856, ktere maji vyplnene 856x. To znamena ze byly vlozeny na 
uloziste cav starym zpusobem nahravani fulltextu a nejsou verejne viditelne
0347790 53621163 CavUnEpca
856    $n0347790.pdf$uhttps://arl-repository.lib.cas.cz/uloziste_av/UZFG-Y/cav_un_epca-0347790_01.pdf$s366$xA$e201012151008

dokumentace ve wiki
https://cosmo2/wiki/index.php/ARL_security#Definice_WB_list.C5.AF_a_symbolik.C5.AF_.28MARC_WBLISTS.29
Parametr:
 handle       zaznam
 sUser        uzivatel, CmSecurity SECURITY_USERS 200$$a
 symbChanges  zmeny, ktere symbolik provedl
              -  pokud se vrati parametr change prazdny
              --  symbolik nic neodfiltroval
              --  nebo odfiltroval ale o vlozeni zpet se postara nejaky kontrolni symbolik
              format:
               symbChanges(1)="HID"_$c(10)_zbytek_$c(10)_odfiltrovano
               symbChanges(2)="LINE"_$c(10,10)_odfiltrovano
               HID - odfiltrovana cast pole (subtagy, indikatory)
               LINE - odfiltrovano cele pole
               HID5 - odfiltrovano jedno konkretni opakovani pole
               Pr.
                symbChanges(1)="HID"_$c(10)_"022 89 "_$c(31)_"5CS"_$c(10)_"022 "_$c(31)_"a1211-4294"
                symbChanges(2)="LINE"_$c(10,10)_"773 89 "_$c(31)_"wcbvk_us_cat*s0000729"_$c(31)_"7 as"_$c(31)_"5CS,L"
                symbChanges(3)="HID5"_$c(10,10)_"022 89 "_$c(31)_"a9876"_$c(31)_"ldfgfd"_$c(31)_"5CS1,L"
Navrat:
 0/1    nebylo/bylo neco odfiltrovano
 text   chyba ve formatu "|ERRxxx#", "|INFxxx#"

14.10.10 tt; zalozeno na zaklade usel.sec.mfilter.testSplitSymb
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,sUser:%String,&symbChanges]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s ret=0,nCh=1
  //w !," sUser="_sUser
  ; chyby se vraci ve formatu error code "|ERRxxx#", informace "|INFxxx#"
  //s symbChanges(1)="HID"_$c(10)_"rest"_$c(10)_"finds"
  //s symbChanges(2)="HID5"_$c(10,10)_"finds"
  //s symbChanges(3)="LINE"_$c(10,10)_"finds"
  
  s c=##class(User.MARC).recordLineCountX(.handle) ; ziskani poctu radku v zaznamu 
  f i=1:1:c 
  { ; pres vsechny radky zaznamu pujdeme po jednom radku a budeme nahrazovat
   s lsLine=##class(User.MARC).getLineX(.handle,i) continue:lsLine="" 
   if ($e(lsLine,1,3)="856")
   { ; pokud mame filtrovany zaznam, zpracujeme
     s sT856x=##class(User.MARC).getSubTagStr(lsLine,"x")
     if (sT856x'="")
     { ; pokud mame vyplnene x, 
       s symbChanges(nCh)="LINE"_$c(10,10)_lsLine
       s lsLine=""
       d ##class(User.MARC).setLineX(.handle,i,lsLine) ; zapsani to radku
       s nCh=nCh+1 ; inkrementujeme pocitadlo
       s ret=1
     }         
   }
  }
  
  ; odmazani prazdnych tagu a subtagu
  d ##class(User.MARC).recordDelEmptyST(.handle)    
  q ret
]]></Implementation>
</Method>

<Method name="Filt856x">
<Description>
Zalozena metoda na litrovani zaznamu podle 856x c ipacu2.
Parametry : handle - aktualni zpracovavany handle
obdobne jako ##class(User.SpuS).Filt856i(.handle)

Dokumentace: https://cosmo2/wiki/index.php/Cust:SPU_Filtrovaci_symbolik_856#Zad.C3.A1n.C3.AD

25.08.10 tt; zalozena metoda na filtrovani 856 podle $x</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Binary]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 ; zjisteni, jestli je prihlaseny uzivatel (0 - ne, 1 - ano)
 s IsLog=##class(i2.access).isLoggedIn()
 ; zjisteni login kategorie definovane v I2_LOGINCHECKS_ICTX
 s sLoginC=##class(i2.access).getLoginCateg()
 ; zjisteni, jestli je dana kategorie ve mych kategoriich, je mozne pouzit * INTRANET_* 
 ; (1 - ano, 0 - ne) 
 ;s IsLogCat=##class(i2.access).isLoginOptionP("INTRANET_URL",sLoginC)
 ; zjisteni aktualni ip adresy
 ;s Ip=##class(i2.common).getIP()
 
 s s856=$$$getTagXC(.handle,"856",-1) q:s856=""  ; ziskani tagu
 
 s sVVYST=""                             ; nastavime pomocne promenne
 s sAktDat=##class(User.Util).date()     ; ziskame aktualni datum
 
 f i=1:1:$l(s856,$c(10)) 
 { ; cyklime pres vsechny opakovani 856
   s s8561=$p(s856,$c(10),i)
   s s8561x=##class(User.MARC).getSubTagStr(s8561,"x")       ; ziskame podpole i
     
   ; definice podminek, kdy se ma 856 odmazavat
   if (s8561x'="")
   { ; pokud je x vyplnene, odmazeme
     s s8561=""
   }
      
   ; ukladame pro vyseledek
   s:((sVVYST'="")&&(s8561'="")) sVVYST=sVVYST_$c(10)_s8561  ; skladame vysledek do sebe
   s:((sVVYST="")&&(s8561'="")) sVVYST=s8561             
 }
 if ($l(sVVYST)>8) { d ##class(User.MARC).setTagX(.handle,sVVYST)} ; ulozeni vysledku
 else { d ##class(User.MARC).delTagX(.handle,"856") }              ; nebo odmazani tagu
]]></Implementation>
</Method>

<Method name="symExportOAI2NUSL">
<Description><![CDATA[
<pre> Metoda, ktera filtruje zaznamy posilane pres OAI do NUSL

30.11.14 tt; pridana uprava,a by se do NUSL odesilali zaznamy, ktere maji 856 bez x nebo s x=N
27.03.11 tt; nahrazeni hodnoty v C34v
25.10.10 tt; upraven filtracni symbolik pro OAI o filtraci 856
19.10.10 lp; filtracni symbolik - pri exportu pres OAI-PMH do NUSL je potreba
             odfiltrovat interni pole, ale ponechat Cxx a 970
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Library.Binary]]></FormalSpec>
<Implementation><![CDATA[
 s T970 = $$$getTagX(.handle,"970")
 ; vymazy tagu
 ; vsechny TXX tagy
 d $$$delTagX(.handle,"T**")  
 ; vsechny 9XX tagy
 d $$$delTagX(.handle,"9**")  
 ; CXX tagy nechame

 ;22.10.10 tt; do NUSL se odesilaji jen tagy 856 s $xN
 s s856=$$$getTagXC(.handle,"856",-1)   ; ziskani tagu
 if (s856'="")
 { ; pokud mame co zpracovavat, pokracujeme
   s sVVYST=""                                                 ; nastavime pomocne promenne
   f i=1:1:$l(s856,$c(10)) 
   { ; cyklime pres vsechny opakovani 856
     s s8561=$p(s856,$c(10),i)
     s s8561x=$$$getSubTagStr(s8561,"x")       ; ziskame podpole x
     
     ; definice podminek, kdy se ma 856 odmazavat
     ; 30.11.14 tt; pridana uprava,a by se do NUSL odesilali zaznamy, ktere maji 856 bez x nebo s x=N
     if (s8561x'="")
     {
       s:(s8561x'="N") s8561=""  ; pokud pokud v x neni N, odmazeme
     }
     ; ukladame pro vyseledek
     s:((sVVYST'="")&&(s8561'="")) sVVYST=sVVYST_$c(10)_s8561  ; skladame vysledek do sebe
     s:((sVVYST="")&&(s8561'="")) sVVYST=s8561 
   }
   if (sVVYST'="") { d $$$setTagX(.handle,sVVYST)} ; ulozeni vysledku
   else { d $$$delTagX(.handle,"856") }              ; nebo odmazani tagu
 }
 ; 01.07.12 tt; zapojen symbolik pro generovani 856 na zaklade content serveru 
 d ..Add856NUSLforOAI(.handle)
 
 ; 27.03.11 tt; nahrazeni hodnoty v C34v
 s sC34=$$$getTagXC(.handle,"C34",-1)   ; ziskani tagu
 if (sC34'="")
 { ; pokud mame co zpracovavat, pokracujeme
   s sVVYST=""
   f i=1:1:$l(sC34,$c(10)) 
   { ; cyklime pres vsechny opakovani C34
     s sC341=$p(sC34,$c(10),i)
     s sC341v=$$$getSubTagStr(sC341,"v")       ; ziskame podpole v
     if sC341v'=""
     {
       s sC341vN=##class(User.Util).sXlate("UN_TC34V",sC341v,,"Cav","d")
       s sC341=$$$setSubTagStr(sC341,$c(31)_"v"_sC341vN)     
     }
           
     ; ukladame pro vyseledek
     s:(sVVYST'="") sVVYST=sVVYST_$c(10)_sC341  ; skladame vysledek do sebe
     s:(sVVYST="") sVVYST=sC341             
   }
   if ($l(sVVYST)>8) { d $$$setTagX(.handle,sVVYST)} ; ulozeni vysledku
 }
  
 if T970'="" d ##class(MARC).setTagX(.handle,T970)
 q
]]></Implementation>
</Method>

<Method name="testCheck856x">
<Description><![CDATA[
<pre> Metoda pro kontrolu modifikace tagu 856
Parametr:
 handle       zaznam
 sUser        uzivatel, CmSecurity SECURITY_USERS 200$$a
 changes      nalezene zmeny v handle
              format: ("tag, opakovani tagu, subtag, opakovani subtagu") - vse v jednom uzlu !
               changes("002,1")=""
               changes("100,1,.,1")=""       zmena prvniho indikatoru
               changes("100,1,:,1")=""       zmena druheho indikatoru
               changes("100,1,a,1")=""
               changes("200,8,g,1")=""
               changes("200,12,g,1")=""
Navrat:
 ""     kontrola prosla
 text   nalezene nepovolene zmeny v handle, chyby

08.11.10 tt; pridana varianta pro novy zaznam
03.11.10 tt; formalni oprava chyby, aby se nenacitalo s prazdneho handlu
25.10.10 tt; dalsi upravy symboliku
22.10.10 tt; zalozena metoda na kontrolu
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,sUser:%String,&changes]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s c=0,i=1,sRet=""
  s sT001=$$$HandleT001(handle)       ; ziskani t001
  s sClass=$$$HandleClass(handle)    ; ziskani tridy
  ; 03.11.10 tt; formalni oprava chyby, aby se nenacitalo s prazdneho handlu
  if ##class(User.MARC).readX(.handleOld,sClass,sT001)
  {
    d {
      s sT856=##class(User.MARC).getTagX(.handleOld,"856",.c) ; vsetky citacie
      continue:(sT856="")
      s sT856x=##class(User.MARC).getSubTagStr(sT856,"x")
      if (sT856x'="")
      { ; pokud mame vyplnene x, zkontrolujeme, jestli je zmena
        s sCh=$g(changes("856,"_i_",u,1"),"xxx")
        s:(sCh="xxx") sCh=$g(changes("856,"_i_",q,1"),"xxx")
        s:(sCh="xxx") sCh=$g(changes("856,"_i_",s,1"),"xxx")
        s:(sCh="xxx") sCh=$g(changes("856,"_i_",y,1"),"xxx")
        s:(sCh="xxx") sCh=$g(changes("856,"_i_",i,1"),"xxx")
        s:(sCh="xxx") sCh=$g(changes("856,"_i_",n,1"),"xxx")
        s:(sCh="xxx") sCh=$g(changes("856,"_i_",x,1"),"xxx")
        s:(sCh="xxx") sCh=$g(changes("856,"_i_",e,1"),"xxx")
        s:(sCh'="xxx") sRet ="ERRUSR_CAV05#856#"_i_"#nepovolená modifikace pole"
      }
      s i=i+1
    } while (c'=0) 
    
    for j=1:1:i+20
    { ; dalsi cyklus pro mozne zmeny
      s sCh=$g(changes("856,"_j_",x,1"),"xxx")
      s:(sCh'="xxx") sRet ="ERRUSR_CAV05#856#"_j_"#nepovolená modifikace pole"
    }
  }
  else
  { ; 08.11.10 tt; varianta pro novy zaznam
    d {
       s sT856=##class(User.MARC).getTagX(.handle,"856",.c) ; vsetky citacie
       continue:(sT856="")
       s sT856x=##class(User.MARC).getSubTagStr(sT856,"x")
       if (sT856x'="")
       { ; pokud mame vyplnene x, zkontrolujeme, jestli je zmena
         s sRet ="ERRUSR_CAV05#856#"_i_"#nepovolená modifikace pole"
       }
       s i=i+1
    } while (c'=0)        
  }    
  q sRet
]]></Implementation>
</Method>

<Method name="RecFullText">
<Description><![CDATA[
<pre>
Metoda pro zobrazení linku pro vlozeni fulltextu.
Volani 200     $a@##class(User.CavS).RecNeodIpac(.result,.handle,"")

 result     - hodnota pro vysledek
 handle     - aktualni zpracovavany handle 
 param      - parametry
              1 - prefix
              2 - text (z prefixu)
30.11.16 tt; zmena adresy
23.05.13 tt; uprava linku na prikladani souboru z klienta 
21.03.11 tt; zmena logiky, pridavat souboru se nemaji k BCA a BXXS
09.03.11 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&result,&handle:%Binary,param:%String]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
  ; nacteme parametry
  s pPar1=$p(param,"-",1)               ; prefix
  s pPar2=$p(param,"-",2)               ; text
  
  ; ziskame nazvove udaje
  s s200a=$$$getTagX(.handle,"200a") 
  s s970b=$zcvt($$$getTagX(.handle,"970b"),"L")
  ; 21.03.11 tt; zmena logiky, pridavat souboru se nemaji k BCA a BXXS
  q:((s970b="bca")||(s970b="bxxs"))
  
  s sPref=##class(rep.zf.tf).prefix(.handle,pPar1) ; ziskame prefix     
  s sText=##class(rep.zf.tf).prefix(.handle,pPar2) ; ziskame text     
  s sT001=$$$HandleT001(handle)                    ; ziskani t001
  s sClass=$$$HandleClass(handle)                  ; ziskani tridy
  s sLClass=##class(User.Util).objectName2lname(sClass)
  
  s:(s200a="") s200a=sClass_" - "_sT001            ; vlozime hodnotu
  
  s s200a=##class(i2.html.base).encode(s200a)
  ; https://arl-repository.lib.cas.cz/application/?idx=cav_un_epca*0329386&name=test
  ; 23.05.13 tt; uprava linku na prikladani souboru z klienta 
  s sUrl="https:/asep.lib.cas.cz/i2/i2.entry.cls?ictx=cav&language="_$$$GETLANGUAGE_"&op=uploader&idx=cav_un_epca-1*"_sT001
  ;s sUrl="https://arl-repository.lib.cas.cz/application/?idx="_sLClass_"*"_sT001_"&name="_s200a_"&client=1"
  s sUrl="<a href="""_sUrl_""" target=""_blank"">"_sText_"</a>"
  
  s nLBlock=$o(result(""),-1)+1 
  s result(nLBlock)=sPref_" :"_sUrl
  q
]]></Implementation>
</Method>

<Method name="FTgetIsAutor">
<Description><![CDATA[
<pre> Metoda ziskani informaci, jestli je dany uzivatel autor. Autor v tom smyslu, ze je to
      bud autor zaznamu, nebo je jednim ze spoluautoru uvedenych v zaznamu
 Parametry: pIdUser   - Id uzivatele
            pIdRecord - Id zaznamu
            pPar      - oddelene -
                        1. hodnota 1 - vratit 1, jen pokud je to autor zaznamu (zalozil zaznam)  
                               jinak - funkuje defaultne

 Navratova hodnota: 0 - neni autor zaznamu
                    1 - je autor zaznamu

29.09.11 tt; uprava proti spatnym vstupum
21.09.11 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIdUser="",pIdRecord="",pPar=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  s bRet=0,sErr="",sPomAuth="",sState=0
  
  ; nacteme parametry
  s pPar1=$p(pPar,"-",1)          ; jestli je to hlavni autor (tvurce zaznamu)
  s sErr=..FTgetData(.handleU, pIdUser,.handleR,pIdRecord,.sState)  ; nacteme zaznamy
  if ((sErr'="")||(sState'=3)) { q "0" }
  s sUT100k=$$$getTagX(.handleU,"100k")                     ; kategorie uzivatele
  if ((sUT100k=0)||(sErr'="")) { q "0" }                                  ; ukoncime, pokud neni uzivatel registrovany

  ; nacteme data z uzivatele
  s sUT620=$$$getTagXC(.handleU,"620",-1)
  if (sUT620'="")
  { ; pokud mame co zpracovavat, pokracujeme    
    f i=1:1:$l(sUT620,$c(10)) 
    { ; cyklime pres vsechny opakovani 620
      s sUT6201=$p(sUT620,$c(10),i)
      s sPomAuth=sPomAuth_$c(10)_$$$getSubTagStrC(sUT6201,"a",-1)  ; ziskame vsechna podpole a      
    }   
  }
  
  s c=0
  d {
    s sT7XX=$$$getTagXC(.handleR,"7**",.c) ; vsetky citacie
    continue:((sT7XX="")&&(c'=0))
    if (sT7XX'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      s sT7XX3=$$$getSubTagStr(sT7XX,"3")
      s:($f($c(10)_sPomAuth_$c(10),$c(10)_sT7XX3_$c(10))) bRet=1
    }
  } while (c'=0)
  
  
  ; autor zaznamu - zjisteni tvurce zazanmu
  s sRT999e=$$$getTagX(.handleR,"999e")             ; ziskam si autora zaznamu
  s:($p(sRT999e,"*",2)=pIdUser) bRet=1              ; pridame priznak i kdyz je vlastnik zaznamu
  if (pPar1=1)                                      ; osetreni parametru
  { ; pokud mame urcit autora (toho kdo vytvoril zaznam) zaznamu
    s:($p(sRT999e,"*",2)'=pIdUser) bRet=0    
  }
  q bRet                                  ; vratime vyslednou navratovou hodnotu
]]></Implementation>
</Method>

<Method name="FTgetIsUser">
<Description><![CDATA[
<pre> Metoda ziskani informaci o typu uzivatele vuci zaznamu
 !!! pouzivat GetRoleUser !!!
 Parametry: pIdUser   - Id uzivatele
            pIdRecord - Id zaznamu
            pPar      - oddelene "-" 
                      - "USER" - pokud hodnota user, vyhodnocuje se jen role uzivatele - ne vuci zaznamu

 Navratova hodnota: 0 - nema zadny vztah
                    1 - jeden z autoru zaznamu, nebo clovek, ktery zaznam vytvoril
                    2 - zpracovatel k zaznamu
                    3 - clovek z ustavu zaznamu (ma stejny ustav)
                    4 - clovek ze spolupracujiciho ustavu
                    5 - zpracovatel ze spolupracujiciho zaznamu
                    6 - superuzivatel
                    7 - anonymni uzivatel - pro parametr "USER"
                    8 - uzivatel kontrola

01.02.19 tt; pridan uzivatel kontrola
01.10.12 tt; pridana funkcnost na zjisteni ustavu podle IP adres
             i neprihlaseny uzivatel ziska prava prihlaseneho v ramci ustavu
18.05.12 tt; uprav logiky pro anonymni uzivatele - chova se vzdy jako navratova hodnota 3
14.10.11 tt; zmena logiky superuzivatele
29.09.11 tt; uprava proti spatnym vstupum
21.09.11 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIdUser="",pIdRecord="",pPar=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  s bRet=0,sErr="",sPomAuth="",sPomUstavR="",sState=0,sUstavyIP="",sUT600i=""
  
  ; nacteme parametry
  s sErr=..FTgetData(.handleU, pIdUser,.handleR,pIdRecord,.sState)  ; nacteme zaznamy
  
  ; 01.10.12 tt; pridana funkcnost na zjisteni ustavu podle IP adres
  ; metoda, ktera vrati na zaklade IP adresy seznam ustavu, do ktereho clovek nalezi
  s sUstavyIP=..FTgetIntranetUstav()
  if (($g(handleR("Rec",1),"")'="")&&((sState=2))&&(sUstavyIP'=""))
  { ; pokud existuje zaznam, pokusime se nacist
     
    s sRTC26e=$$$getTagX(.handleR,"C26e")                ; ziskam pracoviste, ktere zaznam vykazuje
    // informace o autorovi /////////////////////////////////////////////////////////////////////
    ; 1 - jeden z autoru zaznamu, nebo clovek, ktery zaznam vytvoril
    s c=0
    d {
      s sT7XX=$$$getTagXC(.handleR,"7**",.c) ; vsetky citacie
      continue:((sT7XX="")&&(c'=0))
      if (sT7XX'="")
      { ; pokud mame vyplnene data, muzeme provadet akce 
        s sT7XXp=$$$getSubTagStr(sT7XX,"p")  ; nacteme si ustav
        s:(sT7XXp'="") sPomUstavR=sPomUstavR_","_sT7XXp
      }
    } while (c'=0)
    for k=1:1:$l(sUstavyIP,",")
    {
      s sUstavyIP1=$p(sUstavyIP,",",k)
      continue:(sUstavyIP1="")               ; pokud nemame hodnotu, nemame co srovnavat 
      ; nastavime uzivatele na autora daneho ustavu
      s:($f(","_sPomUstavR_",",","_sUstavyIP1_",")) bRet=3 
    }
    s:($f(","_sUstavyIP_",",","_sRTC26e_",")) bRet=3 
    q bRet ; ukoncime s prislusnou hodnotou pro cloveka z ustavu, pokud se naleza na
           ; ip adrese daneho ustavu. Kontrolovano podle I2_LOGINCHECKS_CAV
  }
  
  
  if ((sState=3)||(sState=1))
  { 
    /// 01.03.19 tt; provedena uprava vyhodnoceni uzivatele kontrola
    s sUT100k=$$$getTagX(.handleU,"100k")             ; anonymni uzivatel
    s sUT100b=$$$getTagX(.handleU,"100b")             ; anonymni uzivatel
    s sUT600a=$$$getTagX(.handleU,"600a")             ; link na nadrizenou jednotku
    s sUT600b=$$$getTagX(.handleU,"600b")             ; ustav uzivatele 
    s sUT600i=$$$getTagX(.handleU,"600i")             ; login kontext uzivatele
    s sUT620a=$$$getTagX(.handleU,"620a")             ; link na autoritu
    s sUT610b=$$$getTagX(.handleU,"610b")             ; priznak, ze se muze uzivatel hlasit pres ipac do formularu
  
    if ($f("-"_pPar_"-","-USER-"))
    { ; pokud mame vyhodnocovat jen roli uzivatele 
      /////////////////////////////////////////////////////////
      s bRet=0
      /// 01.03.19 tt; provedena uprava vyhodnoceni uzivatele kontrola   
      ; je zpracovatel
      if ((sUT600b'="") && (sUT600a="")) { s bRet=2 } 
      ; se superuzivatel
      if (sUT100k="2") { s bRet=6 } 
      ; osetreni pro anonymni uzivatele
      ; 08.12.16 tt; upraveno porovnani anonymniho uzivatele - jsou vovoleny cisla, ktere se pri porovnani odfiltruji
      s sUT100btest=$tr(sUT100b,"0123456789","")
      if (($e(sUT100btest,($l(sUT100btest)-1),$l(sUT100btest))="-A") && (sUT600a'="")) { s bRet=7 }     
      s:((sUT600b="KONTROLA")||($f(sUT600i,"KONTROLA"))) bRet=8    ; ziskam uzivatele ne kontrolu  
      ; vratime navratovou hodnotu
      q bRet  
    }
  }
  
  if ((sErr'="")||(sState'=3)) { q "0" }
  s sUT100k=$$$getTagX(.handleU,"100k")                     ; kategorie uzivatele
  if ((sUT100k=0)||(sErr'="")) { q "0" }                    ; ukoncime, pokud neni uzivatel registrovany
  
   // informace o uzivateli ///////////////////////////////////////////////////  ; zjistime, jestli
  ; nacteme data z uzivatele
  s sUT620=$$$getTagXC(.handleU,"620",-1)
  if (sUT620'="")
  { ; pokud mame co zpracovavat, pokracujeme    
    f i=1:1:$l(sUT620,$c(10)) 
    { ; cyklime pres vsechny opakovani 620
      s sUT6201=$p(sUT620,$c(10),i)
      s sPomAuth=sPomAuth_$c(10)_$$$getSubTagStrC(sUT6201,"a",-1)  ; ziskame vsechna podpole a      
    }   
  }
  ; nacteme si ustav
  s sUT600a=$$$getTagX(.handleU,"600a")                ; link na nadrizenou jednotku
  s sUT600b=$$$getTagX(.handleU,"600b")                ; ustav uzivatele 
  s sUT100k=$$$getTagX(.handleU,"100k")                ; ustav uzivatele 
  ; 18.05.12 tt; uprav logiky pro anonymni uzivatele
  s sUT100b=$$$getTagX(.handleU,"100b")                ; prihlasovaci jmeno


  // informace o epca zaznamu ///////////////////////////////////////////////////
  s sRT999e=$$$getTagX(.handleR,"999e")                ; ziskam si autora zaznamu
  s sRTC26e=$$$getTagX(.handleR,"C26e")                ; ziskam pracoviste, ktere zaznam vykazuje
  ;s sRT999b=$$$getTagX(.handleR,"999b")               ; ziskam pracoviste vlastnika zaznamu

  // informace o autorovi /////////////////////////////////////////////////////////////////////
  ; 1 - jeden z autoru zaznamu, nebo clovek, ktery zaznam vytvoril
  s c=0
  d {
    s sT7XX=$$$getTagXC(.handleR,"7**",.c) ; vsetky citacie
    continue:((sT7XX="")&&(c'=0))
    if (sT7XX'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      s sT7XX3=$$$getSubTagStr(sT7XX,"3")              ; nacteme link na autoritu
      s sT7XXp=$$$getSubTagStr(sT7XX,"p")              ; nacteme si ustav
      ; 02.04.21 tt; provedena uprava logiky pridelovani roli
      s:($f($c(10)_sPomAuth_$c(10),$c(10)_sT7XX3_$c(10))&&(sT7XX3'="")) bRet=1
      s:(sT7XXp'="") sPomUstavR=sPomUstavR_","_sT7XXp
    }
  } while (c'=0)
  ; autor zaznamu - zjisteni tvurce zazanmu
  s:(($p(sRT999e,"*",2)=pIdUser)&&(sRT999e'="")) bRet=1         ; pridame priznak i kdyz je vlastnik zaznamu
  ; 18.05.12 tt; uprav logiky pro anonymni uzivatele
  ; 08.12.16 tt; upraveno porovnani anonymniho uzivatele - jsou vovoleny cisla, ktere se pri porovnani odfiltruji
  s sUT100btest=$tr(sUT100b,"0123456789","")
  s:(($e(sUT100btest,($l(sUT100btest)-1),$l(sUT100btest))="-A") && (sUT600a'="")) bRet=0 ; osetreni pro anonymni uzivatele

  if (bRet=0)
  { ; vyhodnocuji, jen pokud neni autor
    // informace o cloveku ze spolupracujiciho ustavu /////////////////////////////
    ; 4 - clovek ze spolupracujiciho zaznamu
    s:($f(sPomUstavR,sUT600b)) bRet=4          ; pokud mam zpracovatele, pridam priznak
    ; 01.10.12 tt; pridana funkcnost na zjisteni ustavu podle IP adres
    s:($f(sUstavyIP,sUT600b)) bRet=4 

    // informace o zpracovateli ze spolupracujiciho ustavu ////////////////////////
    ; 5 - zpracovatel ze spolupracujiciho zaznamu
    s:(($f(sPomUstavR,sUT600b))&&(sUT600a="")) bRet=5          ; pokud mam zpracovatele, pridam priznak

    // informace o cloveku z ustavu ///////////////////////////////////////////////
    ; 3 - clovek z ustavu zaznamu (ma stejny ustav)
    s:(sUT600b=sRTC26e) bRet=3          ; mam cloveka z ustavu
    ; 01.10.12 tt; pridana funkcnost na zjisteni ustavu podle IP adres
    s:($f(sUstavyIP,sRTC26e)) bRet=3 
  }
    
  // vyhodnotceni zpracovatele ///////////////////////////////////////////
  ; 2 - zpracovatel k zaznamu
  s:((sUT600b=sRTC26e)&&(sUT600a="")) bRet=2          ; pokud mam zpracovatele, pridam priznak
   
  
  // vyhodnotceni superuzivatele ///////////////////////////////////////////
  ; 6 - superuzivatel
  ; je to uživatel v CavIsUser, který má v 600 $$acav_is_user*0000016. To je zkratka knihovny AV ČR,
  ; a subtag b je prázdný. Nebo 600b="KNAV-K"
  
  ; 14.10.11 tt; zmena logiky superuzivatele
  ;s:(((sUT600b="")&&(sUT600a="cav_is_user*0000016"))||
  ;  ((sUT600b="KNAV-K")&&(sUT600a="cav_is_user*0000016"))) bRet=6    ; ziskam superuzivatele
  s:(sUT100k="2") bRet=6    ; ziskam superuzivatele  
  ; 17.10.19 tt; uzivatel kontrola muze videt smlouvy i spolupracujicich ustavu- zmenena tato podminka
  //s:((sUT600b="KONTROLA")||((sUT600b=sRTC26e)&&($f(sUT600i,"KONTROLA")))) bRet=8    ; ziskam uzivatele ne kontrolu  
  s:((sUT600b="KONTROLA")||(($f(sPomUstavR,sUT600b))&&($f(sUT600i,"KONTROLA")))) bRet=8    ; ziskam uzivatele ne kontrolu  

  q bRet                                  ; vratime vyslednou navratovou hodnotu
]]></Implementation>
</Method>

<Method name="FTgetDataStav">
<Description><![CDATA[
<pre> Metoda ziskani informaci o datovem zaznamu vuci uzivateli (inspirovane FTgetIsUser)
 Parametry: pIdUser   - Id uzivatele
            pIdRecord - Id zaznamu
            pPar      - parametry oddelene "-"

 Navratova hodnota: 0 - nema zadny vztah
                    1 - je mozne mazat prilohy uzivatelem

1.  Autor by měl mít možnost mazat neodeslaný dataset
2.  Zpracovatele, by měli mít možnost mazat neodeslany dataset

10.05.17 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIdUser="",pIdRecord="",pPar=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  s bRet=0,sErr="",sPomAuth="",sPomUstavR="",sState=0,sUstavyIP=""

  ; nacteme parametry
  s sErr=..FTgetData(.handleU, pIdUser,.handleR,pIdRecord,.sState)  ; nacteme zaznamy
      
  if ((sErr'="")||(sState'=3)) { q "0" }
  s sR970b=$$$getTagX(.handleR,"970b")  
  q:(sR970b'="DATA") "0"
  s sUT100k=$$$getTagX(.handleU,"100k")                     ; kategorie uzivatele
  if ((sUT100k=0)||(sErr'="")) { q "0" }                    ; ukoncime, pokud neni uzivatel registrovany

  // informace o uzivateli ///////////////////////////////////////////////////  ; zjistime, jestli
  s sUT100k=$$$getTagX(.handleU,"100k")             ; anonymni uzivatel
  s sUT100b=$$$getTagX(.handleU,"100b")             ; anonymni uzivatel
  s sUT600a=$$$getTagX(.handleU,"600a")             ; link na nadrizenou jednotku
  s sUT600b=$$$getTagX(.handleU,"600b")             ; ustav uzivatele 
  s sUT620a=$$$getTagX(.handleU,"620a")             ; link na autoritu
  s sUT610b=$$$getTagX(.handleU,"610b")             ; priznak, ze se muze uzivatel hlasit pres ipac do formularu
  

  ; nacteme data z uzivatele
  s sUT620=$$$getTagXC(.handleU,"620",-1)
  if (sUT620'="")
  { ; pokud mame co zpracovavat, pokracujeme    
    f i=1:1:$l(sUT620,$c(10)) 
    { ; cyklime pres vsechny opakovani 620
      s sUT6201=$p(sUT620,$c(10),i)
      s sPomAuth=sPomAuth_$c(10)_$$$getSubTagStrC(sUT6201,"a",-1)  ; ziskame vsechna podpole a      
    }   
  }

  // informace o epca zaznamu ///////////////////////////////////////////////////
  s sRT999e=$$$getTagX(.handleR,"999e")                ; ziskam si autora zaznamu
  s sRTC26e=$$$getTagX(.handleR,"C26e")                ; ziskam pracoviste, ktere zaznam vykazuje
  s sRT969f=$$$getTagX(.handleR,"969f")
  s sRTU95a=$$$getTagX(.handleR,"U95a")

  s sUT100btest=$tr(sUT100b,"0123456789","")
  if (($e(sUT100btest,($l(sUT100btest)-1),$l(sUT100btest))="-A") && (sUT600a'="")) { q "0" }     
 
  // vyhodnotceni zpracovatele ///////////////////////////////////////////
  ; 2 - zpracovatel k zaznamu
  if (sRT969f="N")
  {
    q:((sUT600b=sRTC26e)&&(sUT600a="")) "1"          ; pokud mam zpracovatele, pridam priznak
    if (sRTU95a'=1)
    {
      q:($p(sRT999e,"*",2)=pIdUser) "1"        ; pridame priznak i kdyz je vlastnik zaznamu
    }
  }
 
  q bRet                                  ; vratime vyslednou navratovou hodnotu
]]></Implementation>
</Method>

<Method name="FTgetIntranetUstav">
<Description><![CDATA[
<pre> Metoda ziskani seznamu ustavu podle ip a podle I2_LOGINCHECKS_CAV. 
Zalozena z duvodu, aby se i neprihlaseny uzivatel dostal k fulltextum sveho
nebo spolupracujiciho ustavu

25.09.12 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 ; zjisteni login kategorie definovane v I2_LOGINCHECKS_ICTX
 s sLoginC=##class(i2.access).getLoginCateg()
 s sUstavy=""
 
 for i=1:1:$l(sLoginC,",")
 {
   s sLoginC1=$p(sLoginC,",",i)
   s sUstav1=$p(sLoginC1,"_",2)
   ; mimo celou cav a mozna cosmo
   if ($f(sUstav1,"-")&&(sUstav1'="CAV")&&(sUstav1'="COSMO")&&(sUstav1'=""))
   {
     s:(sUstavy'="") sUstavy=sUstavy_","_sUstav1
     s:(sUstavy="") sUstavy=sUstav1
   }
 }
 q sUstavy
]]></Implementation>
</Method>

<Method name="FTgetUstavU">
<Description><![CDATA[
<pre> Metoda ziskani informaci ustavu uzivatele
 Parametry: pIdUser   - Id uzivatele
            pPar      - 1 - vratit ustav jen pokud je uzivatel zpracovatel
                        jinak - nic
 Navratova hodnota: string ustavu

29.09.11 tt; uprava proti spatnym vstupum
22.09.11 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIdUser="",pPar=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s sRet="",sErr="",sState=0
  
  s sErr=..FTgetData(.handleU, pIdUser,.handleR,"",.sState)         ; nacteme zaznamy
  if ((sErr'="")||(sState'=1)) { q "" }
  s sUT100k=$$$getTagX(.handleU,"100k")                     ; kategorie uzivatele
  if ((sUT100k=0)||(sErr'="")) { q "" }                     ; ukoncime, pokud neni uzivatel registrovany
  
  ; nacteme si ustav
  s sUT600a=$$$getTagX(.handleU,"600a")                     ; link na nadrizenou jednotku
  s sRet=$$$getTagX(.handleU,"600b")                        ; ustav uzivatele 
  if (pPar="1")
  { ; 2 - zpracovatel k zaznamu
    s:('((sRet'="")&&(sUT600a=""))) sRet=""                 ; pokud mam zpracovatele, pridam priznak
  }
      
  q sRet                                  ; vratime vyslednou navratovou hodnotu
]]></Implementation>
</Method>

<Method name="FTgetUstavR">
<Description><![CDATA[
<pre> Metoda ziskani informaci o typu uzivatele vuci zaznamu
 Parametry: pIdRecord - Id zaznamu

 Navratova hodnota: string ustavu
                    pokud se nenajde, prazdna hodnota  

29.09.11 tt; uprava proti spatnym vstupum
22.09.11 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIdRecord=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s sRet="",sErr="",sState=0
  
  s sErr=..FTgetData(.handleU, "",.handleR,pIdRecord,.sState)  ; nacteme zaznamy
  if ((sErr'="")||(sState'=2)) { q "" }                ; ukoncime, pokud neni uzivatel registrovany
  s sRet=$$$getTagX(.handleR,"C26e")                   ; ziskam pracoviste, ktere zaznam vykazuje
  
  q sRet                                               ; vratime vyslednou navratovou hodnotu
]]></Implementation>
</Method>

<Method name="FTgetData">
<Description><![CDATA[
<pre> Metoda pro nacteni dat do handlu
 Parametry: pIdUser   - Id uzivatele
            pIdRecord - Id zaznamu
            pState    - stav otevirani zaznamu
                        0 - defaultni hodnota
                        1 - otevren uzivatel
                        2 - otevren zaznam
                        3 - otevreny oba

29.09.11 tt; uprava proti spatnym vstupum
21.09.11 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handleU,pIdUser="",&handleR,pIdRecord="",&pState]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s pState=0                ; nastavim defaultne na 0
  s sRet=""                 ; navratova hodnota
  s handleR="", handleU=""  ; inicializace promenych
  if (pIdUser'="")
  { ; pokud mame id usera, nacteme informace
    if ('##class(MARC).readX(.handleU,"CavIsUser",pIdUser)) 
    { 
      s sRet=sRet_"Error reading Isu record for t001="_pIdUser
    }
    else
    { ; nastavime si priznak otevreni
      s pState=1             
    }
  }
  if (pIdRecord'="")
  { ; pokud mame id usera, nacteme informace
    if ('##class(MARC).readX(.handleR,"CavUnEpca",pIdRecord)) 
    {
      s sRet=sRet_"Error reading Epca record for t001="_pIdRecord
    }
    else
    { ; nastavime si priznak otevreni
      if (pState=1) { s pState=3 }    ; mame otevrene oba zaznamy
      else { s pState=2 }             
    }
  }
  q sRet
]]></Implementation>
</Method>

<Method name="FTgetZpracZaUstav">
<Description><![CDATA[
<pre> Metoda pro nacteni dat do handlu
 Parametry: pUstav    - ustav, ktery se zpracovava
            pPar      - parametry oddelene -
                        1 - vrati id zaznamu oddelene ,
                        2 - vrati emaily uzivatelu oddelene ,
ARUB-Q
04.11.11 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pUstav="",pPar="2"</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s sRet=""                 ; navratova hodnota
  ; vyber zaznamu pro vypocet vycerpane castky: obednavky spadajici do daneho obdobi
  q:(pUstav = "") ""        ; osetreni proti zadnym datum
  s kod="",brk=0
  f    
  {
    s kod=$o(^$$$MarcIndexG("CavIsUser","stu"," zp",kod),-1) 
    q:((kod="")||(brk=1))              ; podminka pro konec
    
    if '##class(User.MARC).getDATAX(.handle,kod,"T") 
    { ; pokud se nepodari nacist, pokracujeme
      s brk=1 
      w !,"err: FTgetZpracZaUstav - record id:"_kod_" not found!" 
      continue
    }
    s sT600b=$$$getTagX(.handle,"600b")
    s sT600a=$$$getTagX(.handle,"600a")
    continue:(sT600a'="")
    continue:(sT600b'=pUstav)
  
    ;Zpracovavani jednoho zaznamu
    s sT001="",sEmail=""
    s sT001=$$$HandleT001(handle)                           ; ziskani t001
    if ($p(pPar,"-",1)=1)
    { ; vracime id zaznamu
      s:((sT001'="")&&(sRet'="")) sRet=sRet_","_sT001
      s:((sT001'="")&&(sRet="")) sRet=sT001                 ; prvni vlozeni id
    }
    if ($p(pPar,"-",1)=2)
    { ; vracime id zaznamu
      s sEmail=..FTgetEmailHandle(.handle)
      s:((sEmail'="")&&(sRet'="")) sRet=sRet_","_sEmail
      s:((sEmail'="")&&(sRet="")) sRet=sEmail                 ; prvni vlozeni id
    }
  }
  q sRet
]]></Implementation>
</Method>

<Method name="FTgetEmailHandle">
<Description><![CDATA[
<pre> Metoda pro ziskani emailu z autority, nebo uzivatele
 Parametry: handle    - zpracovavany handle, bud uzivatel, nebo autorita

04.11.11 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s sRet=""                 ; navratova hodnota
  s sT001=$$$HandleT001(handle)       ; ziskani t001
  s sClass=$$$HandleClass(handle)    ; ziskani tridy
  
  if (sClass="CavIsUser")
  { ; pokud mame uzivatele, zkusime nacist informace z nej
    s sT100e=$$$getTagX(.handle,"100e")             ; email uzivatele
    if (sT100e'="")
    { ; pokud jiz mame email, ukoncime
      s sRet = sT100e                               ; ulozime 
      q sRet                                        ; ukoncime
    }
    else
    { ; pokusime se email dostat z autority
      s sUT620=$$$getTagXC(.handle,"620",-1)
      if (sUT620'="")
      { ; pokud mame co zpracovavat, pokracujeme    
        f i=1:1:$l(sUT620,$c(10)) 
        { ; cyklime pres vsechny opakovani 620
          s sUT6201=$p(sUT620,$c(10),i)
          s sPomAuth=$$$getSubTagStrC(sUT6201,"a",-1)  ; ziskame vsechna podpole a      
          f j=1:1:$l(sPomAuth,$c(10)) 
          { ; pres vsechny linky na autoritu
            s sPomAuth1=$p(sPomAuth,$c(10),j)          ; ziskame si jeden link
            if ##class(User.MARC).readLX(.handleA,sPomAuth1) 
            { ; otevreme si autoritu a ziskame email
              s sTC01f=$$$getTagX(.handleA,"C01f")     ; email uzivatele
              s:(sTC01f'="") sRet=sTC01f               ; ulozime si email
            }
            q:(sRet'="")                               ; ukoncime, pokud mame data
          }
          q:(sRet'="")                                 ; ukoncime, pokud mame data
        }   
      }
    }
  }
  if (sClass="CavUnAuth")
  { ; pokud mame uzivatele, zkusime nacist informace z nej
    s sTC01f=$$$getTagX(.handle,"C01f")  ; email autority
    s:(sTC01f'="") sRet=sTC01f           ; ulozime si email
  }

  q sRet
]]></Implementation>
</Method>

<Method name="Add856NUSLforOAI">
<Description>
Metoda pro dogenerovani linku 856 z content serveru pro NUSL
linky museji byt zaescapovane.
symExportOAI2NUSL

14.10.20 oi; doplneno podpole $f do pole 856 s hodnotou "origname" nahraneho souboru
06.02.14 jk; zruseny globalni promenne ictx a lang
09.10.13 tt; upraveny podminky pro poslani linku na zaznam 
03.10.13 tt; uprava linku pro NUSL - pridan parametr ictx
01.07.12 tt; zalozen symbolik pro dogenerovani fulltextu pro ucely OAI</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle]]></FormalSpec>
<Implementation><![CDATA[
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  s sIdx=##class(i2.dblink).recordIdX(.handle) ; ziskame id zaznamu 
  ;s baseUrl=##class(i2.html.tpl).getBaseURL() ; mam base url pro sekladani linku do 856
  s baseUrl="https://asepactivenode.lib.cas.cz/i2/"            ; nesla me nacist baseurl, natvrdo
   
  ; ziskame vsechny data k zaznamu v output
  d ##class(content.api).selectRecAll(.output,sClass,sT001)
    
  ; prochazime postupne cyklem vsech polozek k zaznamu
  s item=""      ; jedna polozka k zaznamu
  f { s item=$o(output(item)) q:item=""
    s repo=output(item,"repository")   ; ziskame repository
    s key=output(item,"key")           ; klice    
    
    ; nacteme delsi pomocna data k jednomu zaznamu
    
    d ##class(content.api).getBatch(.array,repo,key)         ; ziskame informace z array    
    ; 03.10.13 tt; uprava linku pro NUSL - pridan parametr ictx
    s sLink=baseUrl_"content.csg.cls?ictx=cav&repo="_repo_"&key="_key ; seskladame si link
    
    ; 09.10.13 tt; upraveny podminky pro poslani linku na zaznam   
    if (($g(array("nusl"),"")="true")&&($g(array("accession"))="O")&&($g(array("status"))=4))
    { ; pokud mame priznak, ze mame link pro nusl, pridame 856
      ; pridame pole 856 s priznakem, ze ma jit pro Nusl
      ;s sLink1=##class(User.Util).XMLfixup(sLink)        ; zaescapovani url
      ;14.10.20 oi; pridano podpole $$f o hodnote "origname" souboru v content serveru (cs116135)      
      s origname="", origname=$g(array("origname"))      
      if (origname'="") { d ##class(User.MARC).appendLineX(.handle,"856    "_$c(31)_"f"_origname_$c(31)_"u"_sLink_$c(31)_"xN") }
      else { d ##class(User.MARC).appendLineX(.handle,"856    "_$c(31)_"u"_sLink_$c(31)_"xN") }
    }   
  } ; konec cyklu prochazeni souboru k zaznamu
]]></Implementation>
</Method>

<Method name="tt">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  w !,..FTgetIsAutor(,"0000738", "0")
  
  ;w !,..FTgetIsAutor("0000677","0367202", "0")
  ;w !,..FTgetIsUser("0000677","0367202")
  /*
  w !,..FTgetUstavU("0000001",1)
  w !,..FTgetUstavR("0103816")
  
   w !,..FTgetIsAutor(,"0103816", "0")
  w !,..FTgetIsUser(,)
  w !,..FTgetUstavU(,1)
  w !,..FTgetUstavU()
  w !,..FTgetUstavR()*/
  
  ;d ##class(User.MARC).readLX(.handle,"cav_is_user*0000618")
  ;w !,..FTgetEmailHandle(.handle)
  ;d ##class(User.MARC).readLX(.handle,"cav_un_auth*0108433")
  ;w !,..FTgetEmailHandle(.handle)

  ;w !,!,"!!!!"_..FTgetZpracZaUstav("ARUB-Q","2")
  ;w !,!,"!!!!"_..FTgetZpracZaUstav("KNAV-K","2")
  
  /*d ##class(User.MARC).readLX(.handle,"cav_un_epca*0385043")
  d ..Add856NUSLforOAI(.handle)*/
  b ;ttt
]]></Implementation>
</Method>

<Method name="getNuslRec">
<Description><![CDATA[
<pre> Založena metoda pro vyexportovani NUSL dat

09.08.12 tt; zalozena metoda
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Library.Binary]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 s sRet=0  ; pokud neni 856, vrati 0 - logika prevzata z exportu do NUSLu 
 
 s s856=$$$getTagXC(.handle,"856",-1)   ; ziskani tagu
 if (s856'="")
 { ; pokud mame co zpracovavat, pokracujeme
   s sVVYST=""                                                 ; nastavime pomocne promenne
   f i=1:1:$l(s856,$c(10)) 
   { ; cyklime pres vsechny opakovani 856
     s s8561=$p(s856,$c(10),i)
     s s8561x=$$$getSubTagStr(s8561,"x")       ; ziskame podpole x
     
     ; definice podminek, kdy se ma 856 odmazavat
     s:(s8561x'="N") s8561=""  ; pokud pokud v x neni N, odmazeme
      
     ; ukladame pro vyseledek
     s:((sVVYST'="")&&(s8561'="")) sVVYST=sVVYST_$c(10)_s8561  ; skladame vysledek do sebe
     s:((sVVYST="")&&(s8561'="")) sVVYST=s8561             
   }
   if ($l(sVVYST)>8) { d $$$setTagX(.handle,sVVYST)} ; ulozeni vysledku
   else { d $$$delTagX(.handle,"856") }              ; nebo odmazani tagu
 }
 
 ; 01.07.12 tt; zapojen symbolik pro generovani 856 na zaklade content serveru 
 d ..Add856NUSLforOAI(.handle)
  
 s s856=$$$getTagXC(.handle,"856",-1)   ; ziskani tagu
 s:(s856'="") sRet=1
  
 q sRet   ; vratime hodnotu
]]></Implementation>
</Method>

<Method name="SelSymbCont">
<Description><![CDATA[
Metoda pro vyber zaznamu z content serveru

d ^X("s CavUnEpca")
s sy="ret1=(##class(User.CavS).SelSymbCont(.handle)=""1"")"
d ^X("s &&CavUnEpca @"_sy)
07.10.12 tt; zalozen symbolik pro vyber zaznamu z content serveru]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s sRet=0
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  s sIdx=##class(i2.dblink).recordIdX(.handle) ; ziskame id zaznamu 
   
  ; ziskame vsechny data k zaznamu v output
  d ##class(content.api).selectRecAll(.output,sClass,sT001)
    
  ; prochazime postupne cyklem vsech polozek k zaznamu
  s item=""      ; jedna polozka k zaznamu
  f { s item=$o(output(item)) q:item=""
    s repo=output(item,"repository")   ; ziskame repository
    s key=output(item,"key")           ; klice
    ; nacteme delsi pomocna data k jednomu zaznamu
    
    d ##class(content.api).getBatch(.array,repo,key)         ; ziskame informace z array    
        
    if ($g(array("nusl"),"")="true")
    { ; pokud mame priznak, ze mame link pro nusl, pridame 856
      s sRet=1
    }   
  } ; konec cyklu prochazeni souboru k zaznamu
  q sRet
]]></Implementation>
</Method>

<Method name="FindRecBezC52">
<Description><![CDATA[
<pre> Metoda pro nalezeni zaznamu, ktere namaji C52 a meli by mit
s sy="ret1=(##class(User.CavS).FindRecBezC52(.handle)>0)"
d ^X("s CavUnEpca @"_sy)
17.12.14 tt; zalozena metoda
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Binary]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s ret=0
  s sTC52Puv=$$$getTagX(.handle,"C52")
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  if (sTC52Puv="")
  {
    ; ziskame vsechny data k zaznamu v output
    d ##class(content.api).selectRecAll(.output,sClass,sT001)
    
    ; prochazime postupne cyklem vsech polozek k zaznamu
    s item=""      ; jedna polozka k zaznamu
    f { 
      s item=$o(output(item)) q:item=""
      s repo=output(item,"repository")   ; ziskame repository
      s key=output(item,"key")           ; klice
      ; nacteme delsi pomocna data k jednomu zaznamu
      s:((repo'="")||(key'="")) ret=1
    } ; konec cyklu prochazeni souboru k zaznamu
    
  }
 q ret
]]></Implementation>
</Method>

<Method name="generateC52">
<Description>
Metoda pro pregenerovani tagu C52
!!! zmeny i do d ##class(i2.cust.cav.approvalAuthor).genC52

 s sy="##class(User.CavS).generateC52(.handle)"
 d ^X("l @"_sy)

22.11.23 tt; doplnena smlouva
28.01.20 tt; provedena uprava, aby se do C52 vzdy pri zmene generovalo podpole n
13.03.15 tt; pridano $n s datem aktualizace C52
03.11.14 tt; pridano vytvoreni recenzi a hodnoceni
20.01.13 tt; osetren vypis kvuli zobrazovani v IPACu3
10.01.13 tt; pridano odmazani C52, pokud se nevytvorila jina/nove
07.10.12 tt; zalozen symbolik pro pregenerovani C52</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,pV=0]]></FormalSpec>
<Implementation><![CDATA[
  s sTC52Puv=$$$getTagX(.handle,"C52")
  w:(pV=1) !,"Puvodni C52: "_sTC52Puv
  s sTC52="C52    " ; inicializujeme C52
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu

  ; ziskame vsechny data k zaznamu v output
  d ##class(content.api).selectRecAll(.output,sClass,sT001)
    
  ; prochazime postupne cyklem vsech polozek k zaznamu
  s item="",sSTm=""     ; jedna polozka k zaznamu
  f { 
    s item=$o(output(item)) q:item=""
    s repo=output(item,"repository")   ; ziskame repository
    s key=output(item,"key")           ; klice
    ; nacteme delsi pomocna data k jednomu zaznamu
    
    d ##class(content.api).getBatch(.array,repo,key)         ; ziskame informace z array    
    s sSTa="", sSTb="", sSTc=""
    s sSTb=$c(31)_"b"_array("accession")                     ; nacteme si postupne data
    s sSTa=$c(31)_"a"_array("status")
    
    continue:(sSTa'=($c(31)_"a4"))
    s:($g(array("nusl"),"")="true") sSTc=$c(31)_"c"_"nusl"
    ; 03.11.14 tt; pridano vytvoreni recenzi a hodnoceni
    s:($g(array("recenze"),"")="true") sSTc=$g(sSTc,"")_$c(31)_"c"_"rec"
    s:($g(array("hodnoceni"),"")="true") sSTc=$g(sSTc,"")_$c(31)_"c"_"hod"
    s:($g(array("version"),"")="SML") sSTc=$g(sSTc,"")_$c(31)_"c"_"sml"
     
    ; seskladame si vyslednou C52
    s:('$f(sTC52,sSTa)) sTC52=sTC52_sSTa
    s:('$f(sTC52,sSTb)) sTC52=sTC52_sSTb
    s:('$f(sTC52,sSTc)) sTC52=sTC52_sSTc    
  } ; konec cyklu prochazeni souboru k zaznamu
  ; 13.03.15 tt; zapojeno generovani C52m
  s sTC52=##class(User.MARC).setSubTagStr(sTC52,$c(31)_"m"_..generateC52m(sT001,sClass))
  
  ; 28.01.20 tt; provedena uprava, aby se do C52 vzdy pri zmene generovalo podpole n
  s:($l(sTC52)>9) sTC52=sTC52_$c(31)_"n"_##class(User.MARC).genT005(0)    
  
  ; mame vyskladanou aktualni C52 a muzeme ji ulozit
  if (($l(sTC52)>9)&&(sTC52Puv'=sTC52))
  { ; pokud mame nejakou hodnotu v C52 a neni stejna jako ta co uz v zaznamu byla, ulozime
    d $$$setTagX(.handle,sTC52)                 ; ulozime si zmenene tag C52
    w:(pV=1) !,"Nova   C52: "_sTC52
  }
  elseif ((sTC52Puv'="")&&(sTC52Puv'=sTC52))
  { ; 10.01.13 tt; pridano odmazani C52, pokud se nevytvorila jina/nove
    d ##class(MARC).delTagX(.handle,"C52")
    w:(pV=1) !,"Smazana C52: "_sTC52Puv
  }
]]></Implementation>
</Method>

<Method name="generateC52m">
<Description>
Metoda pro pregenerovani tagu C52m. Navrat je tag.


01.03.19 tt; pridan priznak pro smlouvu - specialni typ
24.03.15 tt; uprava logiky
13.03.15 tt; zalozena metoda pro pregenerovani C52m </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pT001="",pClass="",pkey="",pC52mAkt=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  ; ziskame vsechny data k zaznamu v output
  d ##class(content.api).selectRecAll(.output,pClass,pT001)
    
  ; prochazime postupne cyklem vsech polozek k zaznamu
  s item="",sSTm=""     ; jedna polozka k zaznamu
  f { 
    s item=$o(output(item)) 
    if (item="")
    {
      s sSTm=sSTm_" "_pC52mAkt
      q
    }
    s repo=output(item,"repository")   ; ziskame repository
    s key=output(item,"key")           ; klice
    
    if (key=pkey)
    {
      s sSTm=sSTm_" "_pC52mAkt
    } 
    ; nacteme delsi pomocna data k jednomu zaznamu
    d ##class(content.api).getBatch(.array,repo,key)         ; ziskame informace z array    
    
    s sSTm=sSTm_" "_array("status")_array("accession")
    s:($g(array("nusl"),"")="true") sSTm=sSTm_"n"
    s:($g(array("recenze"),"")="true") sSTm=sSTm_"r"
    s:($g(array("hodnoceni"),"")="true") sSTm=sSTm_"h"   
    s:($g(array("version"),"")="SML") sSTm=sSTm_"s" 
   
  } ; konec cyklu prochazeni souboru k zaznamu
  
  ; vratime seskladany retezec vsech dulezitych informaci  
  q $zcvt($e(sSTm,2,9999),"L")
]]></Implementation>
</Method>

<Method name="zfContent">
<Description><![CDATA[
<pre> Metoda pro zobrazeni tabulky souboru content serveru podle kontextu uzivatele.
Pokud je uzivatel zpracovatel nebo superuzivatel, vidi pristup vyplneneny v kontextu 
content serveru a taky informaci, jestli je fulltext Nusl.
Parametry:
         params - 1. parametr nic
                     "DATA" - zobrazeni jen u datovych souboru
                     "EPCA" - zobrazeni u jinych, nez datovych souboru    

Dokumentace: https://cosmo2/wiki/index.php/Cav-full_text_upload_25#Zobrazov.C3.A1n.C3.AD_soubor.C5.AF_v_zobrazovac.C3.ADch_form.C3.A1tech

20.09.23 tt; pridan 1. parametr v parametrech - pro zobrazovani souboru v ruznych kontextech
11.11.16 tt; pridana volba u zobrazeni velkych dat
30.11.14 tt; pridan spolupracujici zpracovatel do rozsireneho zobrazeni udaju content serveru
22.11.14 tt; dopracovana podpora zobrazovani recenzi
17.08.14 tt; pridan preklad textu u tabulky content serveru
16.10.12 tt; zalozena metoda
<\pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&result,&handle:%Binary,params:%String=""]]></FormalSpec>
<Implementation><![CDATA[
  s user=##class(i2.access).getLoginId()       ; ziskame id uzivatele
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  s nLStart=$o(result(""),-1)+1
  s sT970b=$$$getTagX(.handle,"970b")
  s sPar1=$p(params,"-",1)
  ; 2 - zpracovatel k zaznamu
  ; 6 - superuzivatel
  
  ; 22.11.14 tt; dopracovana podpora zobrazovani recenzi
  s sUserR=##class(User.CavS).FTgetIsUser(user,sT001) ; metoda pro vygenerovani role uzivatele
  ; 30.11.14 tt; pridan spolupracujici zpracovatel do rozsireneho zobrazeni udaju content serveru
  
  ; 11.01.18 tt; upraven zobrazovaci format pro DATA content server
  ; 01.11.17 tt; pridan u dat sloupec pristup
  if ((sT970b="DATA")&&((sPar1="DATA")||(sPar1="")))  
  { ; 11.11.16 tt; pridana volba u zobrazeni velkych dat
    d ##class(content.zf).fmtContent(.result, .handle,"T=CONi TP=\s CL=-5 T=CONn TP=0991 T=CON1 TP=\s M=key-extension M=symb-##class(i2.cust.cav.archivelist).zfTabSymb T=CONb TP=0992 CL=-7 T=CONs TP=0993 CL=-7 T=CONc TP=0994 CL=-30 T=CONa TP=0995 CL=-20")
  }
  elseif (((sUserR=2)||(sUserR=6)||(sUserR=5))&&((sPar1="EPCA")||(sPar1=""))&&(sT970b'="DATA"))  
  { ; zpracovatelum ukazeme jinou tabulku
    ; 27.02.19 tt; upraveno zobrazeni sloupce hodnoceni
    ; T=CON9 TP=U200 M=key-user - zobrazeni uzivatelu - 001 
    d ##class(content.zf).fmtContent(.result, .handle,"M=filter-recenze-true-not T=CONi TP=\s CL=-5 T=CONn TP=0991 T=CONb TP=0992 CL=-7 T=CONs TP=0993 CL=-7 T=CONc TP=0994 T=CONv TP=0057 M=cis-UT_ASEP_VERSION-1 T=CONt TP=0995 M=cis-UT_ASEP_ACCESS-1 T=CONl M=cis-UT_ASEP_NUSL-1 TP=U123 T=CONu TP=U200 T=CON1 M=key-hodnoceni M=cis-UT_ASEP_NUSL-1 TP=U127 CL=-2")
    d ##class(rep.zf.ub).fmtUb(.handle,"T=005 M=text-&nbsp; PR=",.result)
    d ##class(content.zf).fmtContent(.result, .handle,"M=filter-recenze-true T=CONi TP=\s CL=-5 T=CONn TP=U128 T=CONb TP=0992 CL=-7 T=CONs TP=0993 CL=-7 T=CONc TP=0994 T=CONv TP=0057 M=cis-UT_ASEP_VERSION-1 T=CONt TP=0995 M=cis-UT_ASEP_ACCESS-1 T=CONl M=cis-UT_ASEP_NUSL-1 TP=U123 T=CONu TP=U200 T=CON1 M=key-hodnoceni M=cis-UT_ASEP_NUSL-1 TP=U127 CL=-2")
  }
  elseif (((sPar1="EPCA")||(sPar1=""))&&(sT970b'="DATA"))
  { ; ostatnim uzivatelum standardni
    d ##class(content.zf).fmtContent(.result, .handle,"M=filter-recenze-true-not T=CONi TP=\s CL=-5 T=CONn TP=0991 T=CONb TP=0992 CL=-7 T=CONs TP=0993 CL=-9 T=CONc TP=0994 T=CONv TP=0057 M=cis-UT_ASEP_VERSION-1 T=CONa TP=0995 CL=-10")
    d ##class(rep.zf.ub).fmtUb(.handle,"T=005 M=text-&nbsp; PR=",.result)
    d ##class(content.zf).fmtContent(.result, .handle,"M=filter-recenze-true T=CONi TP=\s CL=-5 T=CONn TP=U128 T=CONb TP=0992 CL=-7 T=CONs TP=0993 CL=-9 T=CONc TP=0994 T=CONv TP=0057 M=cis-UT_ASEP_VERSION-1 T=CONa TP=0995 CL=-10")
  }
  s nLStop=$o(result(""),-1)+1
  
  f i=nLStart:1:nLStop     
  { ; smycka pro upravu odkazu
    s sR1=$g(result(i))    ; ziskame prislusny radek resultu
    continue:(sR1="")      ; pokud by byl prazdny, nebudem nic nahrazovat
    ; upravime odkaz na externi
    ; 20.02.13 tt; uprava kvuli validnosti - kp
    s sR1=$$$strswap(sR1,"<a rel=""nofollow"" href=","<a target=""_blank"" href=")
    ;s sR1=$$$strswap(sR1,"<a rel=""nofollow"" href=","<a class=""external"" target=""_blank"" href=")
    s href=$p($p(sR1,"href=",2,9999),">",1)
    s result(i)=sR1        ; vratime upraveny vysledek
  }
]]></Implementation>
</Method>

<Method name="zfContentHlaska">
<Description><![CDATA[
<pre> Zalozena metoda pro vypsani hlasky pro CAV - kdy neschvaleny zaznam je zobrazen pro hodnoceni

16.10.12 tt; zalozena metoda
<\pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&result,&handle:%Binary,params:%String=""]]></FormalSpec>
<Implementation><![CDATA[
  s user=##class(i2.access).getLoginId()       ; ziskame id uzivatele
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  s sIdx=##class(i2.dblink).recordIdX(.handle) ; ziskame id zaznamu 
  s nLStart=$o(result(""),-1)+1
  s sT970b=$$$getTagX(.handle,"970b")
  ; 2 - zpracovatel k zaznamu
  ; 6 - superuzivatel
  
  s sUserR=##class(User.CavS).FTgetIsUser(user,sT001) ; metoda pro vygenerovani role uzivatele
  
  if ((sUserR=2)||(sUserR=6)||(sUserR=5))
  { ; zpracovatelum zobrazime hlasku
    ; ziskame vsechny data k zaznamu v output
    d ##class(content.api).selectRecAll(.output,sClass,sT001)
  
    ; prochazime postupne cyklem vsech polozek k zaznamu
    s item="",bRec=0,bSoub=0      ; jedna polozka k zaznamu  
    f { 
      s item=$o(output(item)) q:item=""
      s repo=output(item,"repository")   ; ziskame repository
      s key=output(item,"key")           ; klice
      ; nacteme delsi pomocna data k jednomu zaznamu
    
      d ##class(content.api).getBatch(.array,repo,key)         ; ziskame informace z array    
      ; 03.10.13 tt; uprava linku pro NUSL - pridan parametr ictx
    
      if (($g(array("hodnoceni"),"")="true")&&($g(array("status"))'=4)) 
      { ; pokud mame vybrane zaznamy pro hodnoceni, budeme exportovat fulltexty
        d ##class(rep.zf.ub).fmtUb(.handle,"T=005 M=text-<font\scolor=""red""><strong>!!!!!Dokument&nbsp;označený&nbsp;k&nbsp;hodnocení&nbsp;není&nbsp;schválen!!!!!</strong></font> PR=",.result)
      }     
    } ; konec cyklu prochazeni souboru k zaznamu   
  }
]]></Implementation>
</Method>

<Method name="zfContentMainMez">
<Description><![CDATA[
<pre> Metoda, ktera vrati mezeru, pokud se vraci link

16.10.12 tt; zalozena metoda
<\pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Binary]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s ret=""
  s ret=##class(content.zf).fmtMaintain(.handle,"-\n")
  s:(ret'="") ret=" : &nbsp;"  
  q ret
]]></Implementation>
</Method>

<Method name="CreateHandleNet">
<Description><![CDATA[
<pre>  
Generovani handle.net. Volano z planovanych uloh RTM. 
Priklad provolani Cav.
Dokumentace: https://cosmo2/wiki/index.php/Cust:CAV/handle_net

16.12.14 tt; upraven link pro smazane zaznamy
12.12.12 tt; zalozena planovana metoda na zapis do handle net serveru      
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  s ipref="Cav"
  s hprefix="11104"
  s path=##class(util.common).getArlDir("HANDLENET",ipref)
  s auth="AUTHENTICATE PUBKEY:300:0.NA/11104"_$c(10)_path_$$$PathSepp_"admpriv.bin|111.knav.04"
  s hadm="100 HS_ADMIN 86400 1110 ADMIN 200:110011111111:0.NA/11104"
  s hurl="1 URL 86400 1110 UTF8"
  ; 16.12.14 tt; upraven link pro smazane zaznamy
  //s urldel="i2.entry.cls?ictx=cav&language=2&op=cavdeletedrecord"
  s urldel="smazane-zaznamy/"
  d ##class(util.handleNet).createHandleNet(ipref,hprefix,auth,hadm,hurl,urldel)
]]></Implementation>
</Method>

<Method name="GenC60Handle">
<Description><![CDATA[
<pre>
Zalozena metoda pro vygenerovani nove C60 u zkopirovanych zaznamu pro zpracovani Handle.net, ci predanych do systemu jinym zpusobem.
Berou se zaznamy zalozene zpetne za 15 dnu a kontroluje se, jestli se u nich daji zalozit tagy C60.
pokud ano, zalozi se.
Volano z planovanych uloh RTM.

Navrat:
"1" ok, "0" chyba

02.01.14 tt; upravena navratova hodnota
06.02.13 tt; zalozena metoda
<pre>]]></Description>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 s sDtZac=$zd($h-15,8)  ; aktualni datum - 15 dnu
 s sDtKon=$zd($h+1,8)   ; aktualni datum + jeden den
 s ret=1
 
 ; udelame selekt podle dt1
 d ##class(User.Util).XselIndex("CavUnEpca dt1 bt "_sDtZac_"~"_sDtKon)  ; vyselektujeme zaznamy vytvorene do 15 dnu
 d ##class(User.Util).Xselect("&&CavUnEpca 'C60")                       ; ty nesmi mit C60 
 s idx="",id="" 
 f  
 { ; cyklus pro prochazeni vyselektovanych zaznamu
   s idx=$o(^$$$ListsG($$$ListsActiveSel,$j,idx)),id=idx 
   q:(id="")  
     
   ;Zpracovavani jednoho zaznamu
   if '##class(User.MARC).getDATAX(.handle,id,"T") s err="error: planGenC60 - record id:"_id_" not found!" w !,err continue   
   s sT001=$$$HandleT001(handle)                           ; ziskani t001
   ; metoda pro automaticke provazani se serverem handle.net (User.CavS)CreateHandleNet
   s sDruhDok=$zcvt($$$getTagX(.handle,"970b"),"U")
   s s969f=$$$getTagX(.handle,"969f")
   
   if ((sDruhDok'="BXX") && (sDruhDok'="BXXS") && (sDruhDok'="BCA") && (sT001'="new"))
   { ; nebudeme kontrolovat u novych zaznamu a u soubornych zaznamu periodik
     s sC60=$$$getTagX(.handle,"C60")
     ; 29.06.16 tt; upraveny podminky pro vytvareni handle.net
     if (($zcvt(s969f,"U")'="D")&& ($zcvt(s969f,"U")'="N") && (sC60="")) {
       w !,"Zpracovavan zaznam: CavUnEpca*"_sT001_"."
       d ##class(util.handleNet).addHandleNet(.handle,"11104",7,"create")
       s st=##class(User.MARC).writeX(.handle)  ; zapiseme zmeneny zaznam
       if $$$ISERR(st) 
       { 
         s err="error: planGenC60 - write record T001:"_sT001_"!" 
         s ret=0
         w !,err,!
         continue 
       }
       else { w !,"Uspesne zapsan zaznam CavUnEpca*"_sT001_"."}
     }
   }
 }
 
 ; 02.01.14 tt; upravena navratova hodnota
 q ret
]]></Implementation>
</Method>

<Method name="ModifyCavhandle">
<Description><![CDATA[
Metoda pro rucni aktulaizaci handlenet serveru.
Metoda vygeneruje textoveho souboru na zaklade selkcnich podminek pro handle davku 
Nasledne se rucne spusti prikaz:
 windows: ...\aRL\handlenet\bin>hdl-genericbatch.bat pFile log.txt
 linux:   home/cosmo/aRL/handlenet/bin>hdl-genericbatch pFile log.txt
A zkontroluje se vysledek v log.txt

Priklad:
 cterm:
  d ^X("s CavUnEpca dt1 bt 20130101~20130530")
  d ^X("s && C60")
  s nPoc=1
  s sy="ret1=(##class(User.CavS).ModifyCavhandle(.handle,.nPoc,""/home/cosmo/_tmp/jk/cavhandle.txt"")>0)"
  d ^X("s && @"_sy)
 shell, staci pod uctem cosmo:
  /home/cosmo/handlenet/bin/hdl-genericbatch /home/cosmo/_tmp/jk/cavhandle.txt /home/cosmo/_tmp/jk/cavhandlelog.txt
 zkontrolovat /home/cosmo/_tmp/jk/cavhandlelog.txt 

27.11.17 jk; zruseno makro GetParDefaultLang
13.12.16 jk; predelana tvorba linku na detail zaznamu v ipacu
30.11.16 jk; cesta na handlenet se cte z konfigurace
30.11.16 tt; zmena adresy pro handle net
06.02.13 tt; zalozena metoda ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Binary,&nPoc,pFile="/home/cosmo/_tmp/cavhandle.txt"]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
  s ret=1  ; muze se dodelat funkcnost pro pripadne selektovaci potreby
  s ipref=##class(User.Util).getClassPrefixParam($$$HandleClass(handle))
  ; 30.11.16 jk; cesta na handlenet se cte z konfigurace
  s path=##class(util.common).getArlDir("HANDLENET",ipref)
  
  ; simulace prostredi IPACu
  s ictx=$zcvt(ipref,"l")
  ; 27.11.17 jk; zruseno makro GetParDefaultLang
  s language=##class(User.Util).getServerLanguage(ipref)
  d ##class(i2.init).batchinit(ictx,language)
  s sBaseURL=##class(i2.html.tpl).getBaseURL()   
  
  if (nPoc=1)
  {  ; vypis hlavicky - jen jednou
     d ##class(User.Util).xlogf(pFile,"AUTHENTICATE PUBKEY:300:0.NA/11104")
     d ##class(User.Util).xlogf(pFile,path_$$$PathSepp_"admpriv.bin|111.knav.04")
     d ##class(User.Util).xlogf(pFile,"")
  }
  s sT001=$$$HandleT001(handle)                     ; ziskani t001
  s sClass=$$$HandleClass(handle)                   ; ziskani tridy
  s idx="cav_un_epca*"_sT001
  s sC60=##class(User.MARC).getTagX(.handle,"C60a") 
  if (sC60'="")
  {   
      ; 13.12.16 jk; predelana tvorba linku na detail zaznamu v ipacu 
      s hlink=sBaseURL_##class(i2.html.tpl).getRecordURL(idx)
      s hlink=##class(User.Util).strswap(hlink,"&amp;","&")
      s hlink=$$$strswap(hlink,"/sk/","/cs/")          
      
      ; pokud ma handle jiz C60, budeme modifikovat
      s sIDH=$p(sC60,"/",$l(sC60,"/"))                        ; ziskame id handlu
      d ##class(User.Util).xlogf(pFile,"MODIFY 11104/"_sIDH)  ; id zapiseme do souboru spolu se spravnym linkem 
      d ##class(User.Util).xlogf(pFile,"1 URL 86400 1110 UTF8 "_hlink)

      d ##class(User.Util).xlogf(pFile,"")                    ; mezi zaznamy musi byt mezera      
  }
  s nPoc=nPoc+1                                    ; zvysime pocitadlo
  q ret
]]></Implementation>
</Method>

<Method name="CreateCavhandle">
<Description><![CDATA[
<pre>
Jako ModifyCavhandle() ale vytvari nove handlenet.

Priklad:
 cterm:
  d ^X("s CavUnEpca dt1 bt 20130101~20130530")
  d ^X("s && C60")
  s nPoc=1
  s sy="ret1=(##class(User.CavS).CreateCavhandle(.handle,.nPoc,""/home/cosmo/_tmp/jk/cavhandle.txt"")>0)"
  d ^X("s && @"_sy)
 shell, staci pod uctem cosmo:
  /home/cosmo/handlenet/bin/hdl-genericbatch /home/cosmo/_tmp/jk/cavhandle.txt /home/cosmo/_tmp/jk/cavhandlelog.txt
 zkontrolovat /home/cosmo/_tmp/jk/cavhandlelog.txt 

26.01.22 jk; zalozeno
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Binary,&nPoc,pFile="/home/cosmo/_tmp/cavhandle.txt"]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
  s ret=1  ; muze se dodelat funkcnost pro pripadne selektovaci potreby
  s ipref=##class(User.Util).getClassPrefixParam($$$HandleClass(handle))
  s path=##class(util.common).getArlDir("HANDLENET",ipref)
  
  ; simulace prostredi IPACu
  s ictx=$zcvt(ipref,"l")
  s language=##class(User.Util).getServerLanguage(ipref)
  d ##class(i2.init).batchinit(ictx,language)
  s sBaseURL=##class(i2.html.tpl).getBaseURL()   
  
  if (nPoc=1)
  {  ; vypis hlavicky - jen jednou
     d ##class(User.Util).xlogf(pFile,"AUTHENTICATE PUBKEY:300:0.NA/11104")
     d ##class(User.Util).xlogf(pFile,path_$$$PathSepp_"admpriv.bin|111.knav.04")
     d ##class(User.Util).xlogf(pFile,"")
  }
  s sT001=$$$HandleT001(handle)                     ; ziskani t001
  s sClass=$$$HandleClass(handle)                   ; ziskani tridy
  s idx="cav_un_epca*"_sT001
  s sC60=##class(User.MARC).getTagX(.handle,"C60a") 
  if (sC60'="")
  {   
      s hlink=sBaseURL_##class(i2.html.tpl).getRecordURL(idx)
      s hlink=##class(User.Util).strswap(hlink,"&amp;","&")
      s hlink=$$$strswap(hlink,"/sk/","/cs/")          
      
      ; pokud ma handle jiz C60, budeme vytvaret novy
      s sIDH=$p(sC60,"/",$l(sC60,"/"))                        ; ziskame id handlu
      d ##class(User.Util).xlogf(pFile,"CREATE 11104/"_sIDH)  ; id zapiseme do souboru spolu se spravnym linkem 
      d ##class(User.Util).xlogf(pFile,"100 HS_ADMIN 86400 1110 ADMIN 200:110011111111:0.NA/11104")
      d ##class(User.Util).xlogf(pFile,"1 URL 86400 1110 UTF8 "_hlink)
      d ##class(User.Util).xlogf(pFile,"")                    ; mezi zaznamy musi byt mezera      
  }
  s nPoc=nPoc+1                                    ; zvysime pocitadlo
  q ret
]]></Implementation>
</Method>

<Method name="exportXMLKAV">
<Description><![CDATA[
<pre> Metoda zajistujici export do formatu UNIMARCXML 
     (/www.bncf.firenze.sbn.it/unimarc/slim)

18.04.11 tt; zalozena metoda
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,pnWhat,pnOutFmt]]></FormalSpec>
<Implementation><![CDATA[
  s xmlchs=$$$GETSESSVAR("xmlchs")
  if (xmlchs="")
  {
    d ##class(i2.export).outputAdd("internal error - missing variable '_xmlchs'",pnOutFmt)
    q  
  }
  
  if (pnWhat=$$$I2ExportHdr)
  {
      d ##class(i2.export).outputAdd("<?xml version=""1.0"" encoding="""_xmlchs_"""?>"
                     _"<collection>",pnOutFmt)
      q
  }
  
  if (pnWhat=$$$I2ExportFooter)
  {
      d ##class(i2.export).outputAdd("</collection>",pnOutFmt)
      q
  }

  if pnWhat'=$$$I2ExportBody zt "ER1" ; poistka chybne volanie

  ; zjisteni parametru z konfigurace volaneho exportu
  s sExpInfo=##class(i2.export).getExportInfo()
  ; v $e jsou doplnkove options
  s sFmtParams=$p(sExpInfo,$c(10),$$$I2cfgrowE)
    
  d ..showRecordXMLKAV(.handle,pnOutFmt,sFmtParams)
]]></Implementation>
</Method>

<Method name="showRecordXMLKAV">
<Description><![CDATA[
<pre> Output jedneho zaznamu do XML ve firnatu pro KAV
Dokumentace: https://cosmo2/wiki/index.php/Cust:CAV_v%C3%BDstupy/Pravideln%C3%BD_a_ad-hoc_export_z%C3%A1znam%C5%AF_z_ASEP#Dokumentace

05.02.19 tt; pridana informace o vyuzivani patentu do exportu pro hodnoceni
15.03.15 tt; pridany anglicky link - link_eng
13.12.14 tt; pridano odstraneni zpecialnich znaku
06.11.14 tt; pridany prvek s nazevm eng
10.06.14 tt; drobne upravy ve scheme na pripominky pana Galika
20.01.13 tt; uprava, aby se plnilo pracoviste u autoru
13.08.13 tt; zalozena metoda
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,pnOutFmt,sFmtParams=""]]></FormalSpec>
<Implementation><![CDATA[
 s bEndOfRec=0,brk=0
 
 ; 19.06.09 lp; pridana moznost vlozeni xmlns prefixu pres options (I2_EXPORT/200$e)
 s sPrefix=sFmtParams
 s:((sPrefix'="")&&('$f(sPrefix,":"))) sPrefix=sPrefix_":"
 s sPrefix=""
 ; specifikace jmenneho prostoru ma byt spravne i v bezprefixove variante
 if sPrefix'=""
 {   d ##class(i2.export).outputAdd("<"_sPrefix_"record>"_$c(10),pnOutFmt) }
 else
 {   d ##class(i2.export).outputAdd("<record>"_$c(10),pnOutFmt)            }
 
 ; predsunute pred cyklus
 ; 19.06.09 lp; navesti 000 musi byt jeste pred 001-kou uplne na zacatku
 s lsLine=##class(User.Util).XMLfixup($$$getTagX(.handle,"000"))
 s lsVal=$e(lsLine,8,99999)
 ;d ##class(i2.export).outputAdd("  <"_sPrefix_"lab>"_lsVal_"</"_sPrefix_"lab>"_$c(10),pnOutFmt)
 
 ; 001
 s sSysno=##class(MARC).recordT001X(.handle)
 d ##class(i2.export).outputAdd("  <"_sPrefix_"sysno>"_sSysno_"</"_sPrefix_"sysno>"_$c(10),pnOutFmt)
 
 s sZpZverejneni=$$$getTagX(.handle,"970b") 
 d ##class(i2.export).outputAdd("  <"_sPrefix_"zp_zverejneni>"_sZpZverejneni_"</"_sPrefix_"zp_zverejneni>"_$c(10),pnOutFmt)
  /*
 ; nepouzijeme 70* kvoli tomu, ze poradie tagov moze byt zmenene
 s nAutoriAVPocet=0,nAutoriVsichniPocet=0
 s sAutoriVsichniBase=$$$getTagXC(.handle,"700",-1)_$c(10)
                     _$$$getTagXC(.handle,"701",-1)_$c(10)
                     _$$$getTagXC(.handle,"702",-1)
 s c=$l(sAutoriVsichniBase,$c(10))
 s sAutoriVsichni="",sAutoriAV="",nAutoriVsichniPocet=0
 f i=1:1:c
 {
      s sAutPart=$p(sAutoriVsichniBase,$c(10),i)
      continue:(sAutPart="")
      s nAutoriVsichniPocet=nAutoriVsichniPocet+1
      
      s sPrislusnost=""
      s sPrislusnost=$$$getSubTagStr(.sAutPart,"p")

      s:(sPrislusnost'="") nAutoriAVPocet=nAutoriAVPocet+1
      s sOdd=" - "
      s sPom=$$$getSubTagStr(.sAutPart,"a")
      if (sPom'="")
      {
        s:(sAutoriVsichni'="") sAutoriVsichni=sAutoriVsichni_sOdd
        s sAutoriVsichni=sAutoriVsichni_sPom
        if (sPrislusnost'="") 
        {
          s:(sAutoriAV'="") sAutoriAV=sAutoriAV_sOdd
          s sAutoriAV=sAutoriAV_sPom
        }  
        s sOdd=", "
      }
      s sPom=$$$getSubTagStr(.sAutPart,"b")
      if (sPom'="")
      {
        s:(sAutoriVsichni'="") sAutoriVsichni=sAutoriVsichni_sOdd
        s sAutoriVsichni=sAutoriVsichni_sPom
        if (sPrislusnost'="") 
        {
          s:(sAutoriAV'="") sAutoriAV=sAutoriAV_sOdd
          s sAutoriAV=sAutoriAV_sPom
        }  
      }    
  }
  s:(sAutoriAV'="") sAutoriAV=$$$strswap(sAutoriAV,"..",".")
  s:(sAutoriVsichni'="") sAutoriVsichni=$$$strswap(sAutoriVsichni,"..",".")
  d ##class(i2.export).outputAdd("  <"_sPrefix_"autori_av>"_sAutoriAV_"</"_sPrefix_"autori_av>"_$c(10),pnOutFmt)
  */
  
  d ..showRecordXMLKAVAutori(.handle, pnOutFmt, sFmtParams,sPrefix)
  d ..showRecordXMLKAVHodKr(.handle, pnOutFmt, sFmtParams,sPrefix)
  d ..showRecordXMLKAVCitRec(.handle, pnOutFmt, sFmtParams,sPrefix)
  d ..showRecordXMLKAVContent(.handle, pnOutFmt, sFmtParams,sPrefix)
  ; 20.03.20 tt; provedeno upraveni bibliografickych citaci pro oai kav
  ; bibliograficka citace
  s sBiblCit=""
  ; 17.03.20 tt; osetreni citace od html znaku
  s sBiblCit=##class(User.CavUnEpca).getBibcitCAV(.handle,,,"DelHtml")
  s:(sBiblCit'="") sBiblCit=$$$strswap(sBiblCit,"..",".")
  s:(sBiblCit'="") sBiblCit=$$$strswap(sBiblCit,"..",".")
  s:(sBiblCit'="") sBiblCit=$$$strswap(sBiblCit,"..",".")
  s:(sBiblCit'="") sBiblCit=$$$strswap(sBiblCit,".  ",". ")
  ; 13.12.14 tt; pridano odstraneni zpecialnich znaku
  s:(sBiblCit'="") sBiblCit=..showRecordXMLBibCit(sBiblCit)
  s:(sBiblCit'="") sBiblCit=##class(User.Util).XMLfixup(sBiblCit)
  d ##class(i2.export).outputAdd("  <"_sPrefix_"bibl_cit>"_sBiblCit_"</"_sPrefix_"bibl_cit>"_$c(10),pnOutFmt)

  ; bibliograficka citace zdroje
  s nLast=1,sBiblCit463=$$$trim(##class(User.CavUnEpca).getBibcitCAV463(.handle,.nLast))
  ; 13.12.14 tt; pridano odstraneni zpecialnich znaku
  s:(sBiblCit463'="") sBiblCit463=..showRecordXMLBibCit(sBiblCit463)
  s:(sBiblCit463'="") sBiblCit463=$$$strswap(sBiblCit463,"..",".")
  s:(sBiblCit463'="") sBiblCit463=$$$strswap(sBiblCit463,"..",".")
  s:(sBiblCit463'="") sBiblCit463=$$$strswap(sBiblCit463,"..",".")
  s:(sBiblCit463'="") sBiblCit463=$$$strswap(sBiblCit463,".  ",". ")
  s:(sBiblCit463'="") sBiblCit463=##class(User.Util).XMLfixup(sBiblCit463)
  d ##class(i2.export).outputAdd("  <"_sPrefix_"bibl_cit_zdr>"_sBiblCit463_"</"_sPrefix_"bibl_cit_zdr>"_$c(10),pnOutFmt)
  
  ; zeme zverejneni
  s sZemeZverejneni=$$$getTagX(.handle,"102a")
  d ##class(i2.export).outputAdd("  <"_sPrefix_"zeme_zverejneni>"_sZemeZverejneni_"</"_sPrefix_"zeme_zverejneni>"_$c(10),pnOutFmt)
  
  ; jazyk
  s sJazyk=$$$getTagX(.handle,"101a")
  d ##class(i2.export).outputAdd("  <"_sPrefix_"jazyk>"_sJazyk_"</"_sPrefix_"jazyk>"_$c(10),pnOutFmt)

  s sImpFaktor=$$$getTagX(.handle,"T16c")
  ; 30.01.24 tt; provedeno zaescapovani impact factoru znaku < do exportu xml
  s sImpFaktor=$$$strswap(sImpFaktor,"<","&lt;")
  d ##class(i2.export).outputAdd("  <"_sPrefix_"impact_faktor>"_sImpFaktor_"</"_sPrefix_"impact_faktor>"_$c(10),pnOutFmt)
  
  s sOrigNazev=$$$getTagX(.handle,"200a")
  s:(sOrigNazev'="") sOrigNazev=##class(User.Util).XMLfixup(sOrigNazev)
  d ##class(i2.export).outputAdd("  <"_sPrefix_"orig_nazev>"_sOrigNazev_"</"_sPrefix_"orig_nazev>"_$c(10),pnOutFmt)

  ; 29.08.07 jj; rozdelit anotaci do trech sloupcu (v jazyce orig, preklad do eng, preklad do cz)
  s sAnotaceBase=$$$getTagX(.handle,"C15")
  s sAnotaceOrig="",sAnotaceEng="",sAnotaceCz=""
  if (sAnotaceBase'="")
  {
    s sAnotaceOrig=$$$getSubTagStr(sAnotaceBase,"a")
    s:(sAnotaceOrig'="") sAnotaceOrig=$$$strswap(sAnotaceOrig,"\\","\")
    s:(sAnotaceOrig'="") sAnotaceOrig=##class(User.Util).XMLfixup(sAnotaceOrig)
    d ##class(i2.export).outputAdd("  <"_sPrefix_"anotace_orig>"_sAnotaceOrig_"</"_sPrefix_"anotace_orig>"_$c(10),pnOutFmt)
    
    s sAnotaceEng=$$$getSubTagStr(sAnotaceBase,"b")
    s:(sAnotaceEng'="") sAnotaceEng=$$$strswap(sAnotaceEng,"\\","\")
    
    s sAnotaceCz=$$$getSubTagStr(sAnotaceBase,"c")
    s:(sAnotaceCz'="") sAnotaceCz=$$$strswap(sAnotaceCz,"\\","\")  
  }  

  //s sPrekladNazvu=$$$getTagX(.handle,"541a")
  if (sJazyk'="eng")
  { ; 06.11.14 tt; pridany prvek s nazevm eng
    s bEngAnot=0,sNazevEng=""
    s sT541=##class(User.MARC).getTagX(.handle,"541",-1)
    f i=1:1:$l(sT541,$c(10))
    {
      s sT5411=$p(sT541,$c(10),i)
      s sT5411a=##class(User.Util).XMLfixup($$$getSubTagStr(sT5411,"a"))
      s sT5411z=$$$getSubTagStr(sT5411,"z")
      s:(sT5411z="eng") sNazevEng=sT5411a
    }
    s sAnotaceEng=##class(User.Util).XMLfixup($$$getSubTagStr(sAnotaceBase,"b"))
    s:(sAnotaceEng'="") sAnotaceEng=$$$strswap(sAnotaceEng,"\\","\")
    d ##class(i2.export).outputAdd("  <"_sPrefix_"eng_nazev>"_sNazevEng_"</"_sPrefix_"eng_nazev>"_$c(10),pnOutFmt)
    d ##class(i2.export).outputAdd("  <"_sPrefix_"anotace_eng>"_sAnotaceEng_"</"_sPrefix_"anotace_eng>"_$c(10),pnOutFmt)
  }
  else
  {
    d ##class(i2.export).outputAdd("  <"_sPrefix_"eng_nazev>"_sOrigNazev_"</"_sPrefix_"eng_nazev>"_$c(10),pnOutFmt)
    s sAnotaceEng=$$$getSubTagStr(sAnotaceBase,"a")
    s:(sAnotaceEng'="") sAnotaceEng=$$$strswap(sAnotaceEng,"\\","\")
    s:(sAnotaceEng'="") sAnotaceEng=##class(User.Util).XMLfixup(sAnotaceEng)
    d ##class(i2.export).outputAdd("  <"_sPrefix_"anotace_eng>"_sAnotaceEng_"</"_sPrefix_"anotace_eng>"_$c(10),pnOutFmt)
  }

  ; vlastnik zaznamu 
  s sVlastnikZaznamu=$$$getTagX(.handle,"C26e")
  d ##class(i2.export).outputAdd("  <"_sPrefix_"vlastnik_zaznamu>"_sVlastnikZaznamu_"</"_sPrefix_"vlastnik_zaznamu>"_$c(10),pnOutFmt)

  ; ziskame vsechny ustavy ve spolupraci
  s sUstAll=##class(User.CavUnEpca).getSpolByHandle(.handle)  
  d ##class(i2.export).outputAdd("  <"_sPrefix_"ustav_spoluprace>"_sUstAll_"</"_sPrefix_"ustav_spoluprace>"_$c(10),pnOutFmt)
  
  ; rok vydani 
  s sRokVydani=$$$getTagX(.handle,"T16r")
  d ##class(i2.export).outputAdd("  <"_sPrefix_"rok_vydani>"_sRokVydani_"</"_sPrefix_"rok_vydani>"_$c(10),pnOutFmt)

  ; HANDLE - C60$a link
  s sHANDLE=$$$getTagX(.handle,"C60a")
  d ##class(i2.export).outputAdd("  <"_sPrefix_"handle>"_sHANDLE_"</"_sPrefix_"handle>"_$c(10),pnOutFmt)
  
  ; 15.03.15 tt; pridany anglicky link - link_eng
  s sLink=$p($p(##class(i2.html.tpl).getPermalink2("cav_un_epca*"_sSysno,sSysno),"a href=""",2),"""",1)_"&amp;zf=TF_UN_ENG"
  s:('$f(sLink,"language=3")) sLink=sLink_"&amp;language=3"
   //s sLink=##class(User.Util).XMLfixup(sLink)
  d ##class(i2.export).outputAdd("  <"_sPrefix_"link_eng>"_sLink_"</"_sPrefix_"link_eng>"_$c(10),pnOutFmt)


  ; CisloPatentovehoSpisu - C11$a
  s sCisloPatentovehoSpisu=$$$getTagX(.handle,"C11a")
  d ##class(i2.export).outputAdd("  <"_sPrefix_"cislo_patentu>"_sCisloPatentovehoSpisu_"</"_sPrefix_"cislo_patentu>"_$c(10),pnOutFmt)
  
  ; 05.02.19 tt; pridana informace o vyuzivani patentu do exportu pro hodnoceni
  ; vyuziti - C11$p
  s sVyuzitiPatentu=$$$getTagX(.handle,"C11p")
  if (sVyuzitiPatentu="A") { d ##class(i2.export).outputAdd("  <"_sPrefix_"vyuziti>nevyuzivany</"_sPrefix_"vyuziti>"_$c(10),pnOutFmt) }
  elseif (sVyuzitiPatentu="B") { d ##class(i2.export).outputAdd("  <"_sPrefix_"vyuziti>vyuzivany</"_sPrefix_"vyuziti>"_$c(10),pnOutFmt) }
  else { d ##class(i2.export).outputAdd("  <"_sPrefix_"vyuziti>nevyplněno</"_sPrefix_"vyuziti>"_$c(10),pnOutFmt) }
  
  ; VlastnikPatentu - C11$e
  s sVlastnikPatentu=$$$getTagX(.handle,"C11e")
  d ##class(i2.export).outputAdd("  <"_sPrefix_"vlastnik_patentu>"_##class(User.Util).XMLfixup(sVlastnikPatentu)_"</"_sPrefix_"vlastnik_patentu>"_$c(10),pnOutFmt)

  ; DatumUdeleniPatentu - C11$c
  s sDatumUdeleniPatentu=$$$getTagX(.handle,"C11c")
  d ##class(i2.export).outputAdd("  <"_sPrefix_"datum_patentu>"_sDatumUdeleniPatentu_"</"_sPrefix_"datum_patentu>"_$c(10),pnOutFmt)

  ; KodVydavatelePatentu -C11$q
  s sKodVydavatelePatentu=$$$getTagX(.handle,"C11q")
  d ##class(i2.export).outputAdd("  <"_sPrefix_"kod_vyd_patentu>"_sKodVydavatelePatentu_"</"_sPrefix_"kod_vyd_patentu>"_$c(10),pnOutFmt)
      
  s sC64a=$$$getTagX(.handle,"C64a")
  s:(sC64a="") sC64a=0
  d ##class(i2.export).outputAdd("  <"_sPrefix_"vyrocni_zprava>"_sKodVydavatelePatentu_"</"_sPrefix_"vyrocni_zprava>"_$c(10),pnOutFmt)
   
 d ##class(i2.export).outputAdd("</"_sPrefix_"record>"_$c(10),pnOutFmt)
]]></Implementation>
</Method>

<Method name="showRecordXMLBibCit">
<Description><![CDATA[
<pre>Osetri specialnich znaku pro citace

17.03.20 tt; doplneny dalsi znacky pro swap
13.12.14 tt; zalozeno
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>s:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[

 if $f(s,".")
 {
     if $f(s,"./b.")
     {
       s s=$$$strswap(s,".b.","")
       s s=$$$strswap(s,"./b.","")
     }
     if $f(s,"./br.")
     {
      s s=$$$strswap(s,"./br."," ")
     }
     if $f(s,"./i.")
     {
       s s=$$$strswap(s,".i.","")
       s s=$$$strswap(s,"./i.","")
     }
     ;
     if $f(s,"./u.")
     {
       s s=$$$strswap(s,".u.","")
       s s=$$$strswap(s,"./u.","")
     }
     if $f(s,"./emphasis.")
     { 
       s s=$$$strswap(s,".emphasis.","")
       s s=$$$strswap(s,"./emphasis.","")
     }
     if $f(s,"./sub.")
     {
       s s=$$$strswap(s,".sub.","")
       s s=$$$strswap(s,"./sub.","")
     }
     if $f(s,"./sup.")
     {
       s s=$$$strswap(s,".sup.","")
       s s=$$$strswap(s,"./sup.","") 
     }
 }
 if $f(s,"\")
 {
     s s=$$$strswap(s,"\bs ","")
     s s=$$$strswap(s,"\be ","")
     s s=$$$strswap(s,"\be","")
     s s=$$$strswap(s,"\is ","")
     s s=$$$strswap(s,"\ie ","")
     s s=$$$strswap(s,"\ie","")
     s s=$$$strswap(s,"\us ","")
     s s=$$$strswap(s,"\ue ","")
     s s=$$$strswap(s,"\ue","")
     s s=$$$strswap(s,"\n"," ")
 }
 if $f(s,"<")
 {
     s s=$$$strswap(s,"<b>","")
     s s=$$$strswap(s,"</b>","")
     s s=$$$strswap(s,"<i>","")
     s s=$$$strswap(s,"</i>","")
     s s=$$$strswap(s,"<br/>"," ")
     s s=$$$strswap(s,"<br>"," ")
     s s=$$$strswap(s,"<em>","")   
     s s=$$$strswap(s,"</em>","")     
     s s=$$$strswap(s,"<strong>","")     
     s s=$$$strswap(s,"</strong>","") 
     s s=$$$strswap(s,"<u>","")      
     s s=$$$strswap(s,"</u>","") 

 }
 
 q s
]]></Implementation>
</Method>

<Method name="showRecordXMLKAVAutori">
<Description><![CDATA[
<pre> Output jedneho zaznamu do XML ve firnatu pro KAV - podmetoda pro autory

28.06.14 tt; pridan element researcher_id -  zaznam autority 035$$a, kde $$2WOS + pridan priznak z 70*u=1 - zaznam k hodnoceni
03.06.14 tt; zalozena metoda
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,pnOutFmt,sFmtParams="",sPrefix=""]]></FormalSpec>
<Implementation><![CDATA[

 ; nepouzijeme 70* kvoli tomu, ze poradie tagov moze byt zmenene
 s nAutoriAV=0,nAutoriVsichni=0,nAutoriZah=0
 s sAutoriVsichniBase=$$$getTagXC(.handle,"700",-1)_$c(10)
                     _$$$getTagXC(.handle,"701",-1)_$c(10)
                     _$$$getTagXC(.handle,"702",-1)
 s c=$l(sAutoriVsichniBase,$c(10))

 d:(sAutoriVsichniBase'="") ##class(i2.export).outputAdd("  <"_sPrefix_"autori>"_$c(10),pnOutFmt)

 f i=1:1:c
 {
    s sAutPart=$p(sAutoriVsichniBase,$c(10),i)
    continue:(sAutPart="")
    s nAutoriVsichni=nAutoriVsichni+1
    d ##class(i2.export).outputAdd("    <"_sPrefix_"autor>"_$c(10),pnOutFmt)
     
    s sPrislusnost=""
    s sPrislusnost=$$$getSubTagStr(.sAutPart,"p")
    s sZeme=$$$getSubTagStr(.sAutPart,"y")
      
    if (sPrislusnost'="") 
    { ; pokud je z avcr, predpokladam ze neni zahranicni
      s nAutoriAV=nAutoriAV+1 
    }
    elseif (($zcvt(sZeme,"L")'="cz")&&(sZeme'=""))
    { ; je zahranicni - nema zemi cz
      s nAutoriZah=nAutoriZah+1
    }
      
    ; 701  1    $3 cav_un_auth*0100444 $a Pelant $b Ivan $p FZU-D $4 070 $o Tenké vrstvy a nanostruktury $T Fyzikální ústav AV ČR, v. v. i. 
    ; vlozime kod autority
    s sKod=$$$getSubTagStr(.sAutPart,"3")   ; kod na utoritu
    d:(sKod'="") ##class(i2.export).outputAdd("      <"_sPrefix_"autor_id>"_$p(sKod,"*",2)_"</"_sPrefix_"autor_id>"_$c(10),pnOutFmt)      
    if (sKod'="")
    { ; pokud mame link do autorit, pokusime se otevrit
      if '##class(User.MARC).readLX(.handleA,sKod)
      {
        s sKod=""   
      }
    }  
    
    if (sKod'="")
    { ; 28.06.14 tt; pridan element researcher_id -  zaznam autority 035$$a, kde $$2WOS
      ; <researcher_id> tam, kde je v záznamu autority 035$$a, kde $$2WOS.
      s c=0,bResearcher=0 ; pomocne promenne
      d { ; cyklus pres vsechny 035 autority
        s sT035=$$$getTagXC(.handleA,"035",.c) ; vsetky 035 
        continue:((sT035="")&&(c'=0))
        if (sT035'="")
        { ; pokud mame vyplnene data, muzeme provadet akce 
          if ($zcvt($$$getSubTagStr(sT035,"2"),"l")="wos")     
          { ; najdeme jen ty, co jsou WOS
            s sT035a=$$$getSubTagStr(sT035,"a")
            continue:(sT035a="") ; pokud nemame data, zkoncime 
            s:(sT035a'="") sT035a=##class(User.Util).XMLfixup(sT035a)    
            d ##class(i2.export).outputAdd("      <"_sPrefix_"researcher_id>"_sT035a_"</"_sPrefix_"researcher_id>"_$c(10),pnOutFmt) 
            s bResearcher=1
          }
        }
      } while (c'=0)       
      if (bResearcher=0)
      { ; vypiseme prazdny element, pokud nemame data
        d ##class(i2.export).outputAdd("      <"_sPrefix_"researcher_id></"_sPrefix_"researcher_id>"_$c(10),pnOutFmt)
      } 
    }
    
    ; pridame jmeno
    s sJmeno=$$$getSubTagStr(.sAutPart,"b")
    s:(sJmeno'="") sJmeno=##class(User.Util).XMLfixup(sJmeno)
    d ##class(i2.export).outputAdd("      <"_sPrefix_"jmeno>"_sJmeno_"</"_sPrefix_"jmeno>"_$c(10),pnOutFmt)   
     
    ; prijmeni
    s sPrijmeni=$$$getSubTagStr(.sAutPart,"a")
    s:(sPrijmeni'="") sPrijmeni=##class(User.Util).XMLfixup(sPrijmeni)
    d ##class(i2.export).outputAdd("      <"_sPrefix_"prijmeni>"_sPrijmeni_"</"_sPrefix_"prijmeni>"_$c(10),pnOutFmt)      
      
    ; ustav
    d ##class(i2.export).outputAdd("      <"_sPrefix_"ustav>"_sPrislusnost_"</"_sPrefix_"ustav>"_$c(10),pnOutFmt)     
    
    ; vystup do hodnotceni
    s sHodnoceni=$$$getSubTagStr(.sAutPart,"u")
    if (sHodnoceni=1) { d ##class(i2.export).outputAdd("      <"_sPrefix_"vystup_do_hodnoceni>true</"_sPrefix_"vystup_do_hodnoceni>"_$c(10),pnOutFmt)     }
    else { d ##class(i2.export).outputAdd("      <"_sPrefix_"vystup_do_hodnoceni>false</"_sPrefix_"vystup_do_hodnoceni>"_$c(10),pnOutFmt)     }
    
    s bWriteAutority=0 
    d ##class(i2.export).outputAdd("      <"_sPrefix_"autority>"_$c(10),pnOutFmt)      
    if (sKod'="")
    { ; pokud mame link do autorit, pokusime se otevrit
      s s400 = $$$getTagXC(.handleA,"400",-1)
      s sPom4003=$$$getTagX(.handleA,"4003")
      ;d:((s400'="")&&(sPom4003'="")) ##class(i2.export).outputAdd("      <"_sPrefix_"autority>"_$c(10),pnOutFmt)     

      for kk=1:1:$l(s400,$c(10))
      { ; zaindexujeme vsechny isbn
        s s4001=$p(s400,$c(10),kk)
        continue:(s4001="")
        s s40013=$$$getSubTagStr(s4001,"3") ; prijmeni
        d:(s40013'="") ##class(i2.export).outputAdd("      <"_sPrefix_"id>"_$p(s40013,"*",2)_"</"_sPrefix_"id>"_$c(10),pnOutFmt)    
        s:(s40013'="") bWriteAutority=1       
      }     
      ;d:((s400'="")&&(sPom4003'="")) ##class(i2.export).outputAdd("      </"_sPrefix_"autority>"_$c(10),pnOutFmt)
      if (bWriteAutority=0)
      { ; vypiseme prazdne tagy
        d ##class(i2.export).outputAdd("       <"_sPrefix_"id></"_sPrefix_"id>"_$c(10),pnOutFmt)
      }        
    }
    
    d ##class(i2.export).outputAdd("      </"_sPrefix_"autority>"_$c(10),pnOutFmt)   
     
    
    d ##class(i2.export).outputAdd("    </"_sPrefix_"autor>"_$c(10),pnOutFmt)
  }
  ; ukoncovaci prvek vsech autoru
  d:(sAutoriVsichniBase'="") ##class(i2.export).outputAdd("  </"_sPrefix_"autori>"_$c(10),pnOutFmt) 
  
  ; vypis prvku s poctem autoru
  d ##class(i2.export).outputAdd("  <"_sPrefix_"pocty_autoru>"_$c(10),pnOutFmt) 
  d ##class(i2.export).outputAdd("      <"_sPrefix_"celkem>"_nAutoriVsichni_"</"_sPrefix_"celkem>"_$c(10),pnOutFmt)
  d ##class(i2.export).outputAdd("      <"_sPrefix_"avcr>"_nAutoriAV_"</"_sPrefix_"avcr>"_$c(10),pnOutFmt)
  d ##class(i2.export).outputAdd("      <"_sPrefix_"zahranici>"_nAutoriZah_"</"_sPrefix_"zahranici>"_$c(10),pnOutFmt)     
  d ##class(i2.export).outputAdd("  </"_sPrefix_"pocty_autoru>"_$c(10),pnOutFmt)
]]></Implementation>
</Method>

<Method name="showRecordXMLKAVCitRec">
<Description><![CDATA[
<pre> Output jedneho zaznamu do XML ve firnatu pro KAV - citace/recenze

04.06.14 tt; zalozena metoda
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,pnOutFmt,sFmtParams="",sPrefix=""]]></FormalSpec>
<Implementation><![CDATA[
  ; . prochazeni zaznamu podle .c   
  s c=0,sData="",nPoc971=0,nPocC71=0
  d {
    s sT971=$$$getTagXC(.handle,"971",.c) ; vsetky citacie
    continue:((sT971="")&&(c'=0))
    if (sT971'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      s sT971i=$$$getSubTagStr(sT971,"i")
      s sT9719=$$$getSubTagStr(sT971,"9")
      if (sT9719=1)
      { ; pokud mam byt citace vystaveni, ulozim si ji
        s nPoc971=nPoc971+1
        s sData("971",nPoc971)=sT971i
      }
    }
  } while (c'=0)
  
  d {
    s sTC71=$$$getTagXC(.handle,"C71",.c) ; vsetky citacie
    continue:((sTC71="")&&(c'=0))
    if (sTC71'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      s sTC71i=$$$getSubTagStr(sTC71,"i")
      s sTC719=$$$getSubTagStr(sTC71,"9")
      if (sTC719=1)
      { ; pokud mam byt citace vystaveni, ulozim si ji
        s nPocC71=nPocC71+1
        s sData("C71",nPocC71)=sTC71i
      }
    }
  } while (c'=0)

  if (nPoc971>0)
  { ; vime ze mame nejake citace, budeme zpracovavat
    d ##class(i2.export).outputAdd("  <"_sPrefix_"citace>"_$c(10),pnOutFmt) 
    f x=1:1:nPoc971
    { ; pred vsechny citace
      s s971=$g(sData("971",x)) 
      continue:(s971="")
      d ##class(i2.export).outputAdd("      <"_sPrefix_"citace>"_##class(User.Util).XMLfixup(s971)_"</"_sPrefix_"citace>"_$c(10),pnOutFmt)
    }
    d ##class(i2.export).outputAdd("  </"_sPrefix_"citace>"_$c(10),pnOutFmt) 
  }
  else 
  { ;nemame data - dame prazdny pravek
    d ##class(i2.export).outputAdd("  <"_sPrefix_"citace></"_sPrefix_"citace>"_$c(10),pnOutFmt) 
  }
  
  if (nPocC71>0)
  { ; pokud vim, ze mam recenze, pokracujeme
    d ##class(i2.export).outputAdd("  <"_sPrefix_"recenze>"_$c(10),pnOutFmt) 
    f x=1:1:nPocC71
    { ; pres vsechny recenze
      s sC71=$g(sData("C71",x)) 
      continue:(sC71="")
      d ##class(i2.export).outputAdd("      <"_sPrefix_"recenze>"_##class(User.Util).XMLfixup(sC71)_"</"_sPrefix_"recenze>"_$c(10),pnOutFmt)
    }
    d ##class(i2.export).outputAdd("  </"_sPrefix_"recenze>"_$c(10),pnOutFmt) 
  }
  else 
  { ;nemame data - dame prazdny pravek
    d ##class(i2.export).outputAdd("  <"_sPrefix_"recenze></"_sPrefix_"recenze>"_$c(10),pnOutFmt) 
  }
]]></Implementation>
</Method>

<Method name="showRecordXMLKAVContent">
<Description><![CDATA[
<pre> Output jedneho zaznamu do XML ve firnatu pro KAV - pridana data content serveru
podle showRecordXMLKAVCitRec
https://cosmo2/wiki/index.php/Cust:CAV/KAV_%C3%BAprava_syst%C3%A9mu_ASEP_k_hodnocen%C3%AD_AV_2015#.C3.9Apravy_OAI_setu_pro_KAV

13.12.14 tt; pridan export 856 
04.11.14 tt; zalozena metoda
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,pnOutFmt,sFmtParams="",sPrefix=""]]></FormalSpec>
<Implementation><![CDATA[
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  s sIdx=##class(i2.dblink).recordIdX(.handle) ; ziskame id zaznamu 
  s baseUrl="https://asepactivenode.lib.cas.cz/i2/"            ; nesla me nacist baseurl, natvrdo
  s sFullText="ne" 
  ; ziskame vsechny data k zaznamu v output
  d ##class(content.api).selectRecAll(.output,sClass,sT001)
  
  ; oteviraci prvek zaznamu
  d ##class(i2.export).outputAdd("  <"_sPrefix_"soubory>"_$c(10),pnOutFmt) 
  
  ; prochazime postupne cyklem vsech polozek k zaznamu
  s item="",bRec=0,bSoub=0      ; jedna polozka k zaznamu  
  f { s item=$o(output(item)) q:item=""
    s repo=output(item,"repository")   ; ziskame repository
    s key=output(item,"key")           ; klice
    ; nacteme delsi pomocna data k jednomu zaznamu
    
    d ##class(content.api).getBatch(.array,repo,key)         ; ziskame informace z array    
    ; 03.10.13 tt; uprava linku pro NUSL - pridan parametr ictx
    s sLink=baseUrl_"content.csg.cls?ictx=cav&repo="_repo_"&key="_key ; seskladame si link
    s sLink=##class(User.Util).XMLfixup(sLink)               ; zaescapujeme link  
    
    ;if (($g(array("nusl"),"")="true")&&($g(array("accession"))="O")&&($g(array("status"))=4))
   
    s sVerze=$zcvt($g(array("version"),""),"U") 
    if ((sVerze'="")&&(sVerze'="SML")&&(sVerze'="ANOTHER"))
    { ; 21.01.20 tt; pridano generovani do xml pro KNAV prvku plny_text 
      s sFullText="ano" 
    }
    if ((sVerze'="")&&(sVerze="ANOTHER")&&($f("E,L,P,Z",$e($$$getTagX(.handle,"980b"),1))))
    { ; 24.01.20 tt; pridana podminka pro fultext, i pokud je verze jina ale druhy dokumentu jsou E,L*,P*,Z
      s sFullText="ano"     
    }
    
    if (($g(array("hodnoceni"),"")="true")&&($g(array("status"))=4)) 
    { ; pokud mame vybrane zaznamy pro hodnoceni, budeme exportovat fulltexty
     if ($g(array("recenze"),"")="true")
     { ; pro recenze
       s bRec=1   ; nastaveni priznaku exportu recenzi
       s sRecenze(key)=sLink
     }
     else
     { ; pro soubory
       s bSoub=1  ; nastaveni priznaku exportu souboru
       s sSoubory(key)=sLink
     }
    }      
  } ; konec cyklu prochazeni souboru k zaznamu
  
 if (bSoub=1)
 { ; pokud mame vyplnene soubory, zobrazime
   s sRet=""
   for
   {
     s sRet=$o(sSoubory(sRet)) q:(sRet="")  ; posledni cast tagove mapy       
     s sHod=sSoubory(sRet)
     d ##class(i2.export).outputAdd("      <"_sPrefix_"soubor>"_sHod_"</"_sPrefix_"soubor>"_$c(10),pnOutFmt)
   }
 }
 else
 { 
   d ##class(i2.export).outputAdd("  <"_sPrefix_"soubor></"_sPrefix_"soubor>"_$c(10),pnOutFmt)
 }
 
 if (bRec=1)
 { ; pokud mame vyplnene soubory, zobrazime
   s sRet=""
   for
   {
     s sRet=$o(sRecenze(sRet)) q:(sRet="")  ; posledni cast tagove mapy       
     s sHod=sRecenze(sRet)
     d ##class(i2.export).outputAdd("      <"_sPrefix_"recenze>"_sHod_"</"_sPrefix_"recenze>"_$c(10),pnOutFmt)
   }
 }
 else
 { 
   d ##class(i2.export).outputAdd("  <"_sPrefix_"recenze></"_sPrefix_"recenze>"_$c(10),pnOutFmt)
 }
 
 //// export 856
 ; . prochazeni zaznamu podle .c    
 s c=0, sExp856=0
 d {
   s sT856=$$$getTagXC(.handle,"856",.c) ; pres vsechny linky
   continue:((sT856="")&&(c'=0))
   if (sT856'="")
   { ; pokud mame vyplnene data, muzeme provadet akce 
     s sT856u=$$$getSubTagStr(sT856,"u")
     if (sT856u'="") 
     {
       d ##class(i2.export).outputAdd("      <"_sPrefix_"link>"_##class(User.Util).XMLfixup(sT856u)_"</"_sPrefix_"link>"_$c(10),pnOutFmt)
       s sExp856=1
     }
   }
 } while (c'=0)
 if (sExp856=0)
 { 
   d ##class(i2.export).outputAdd("      <"_sPrefix_"link></"_sPrefix_"link>"_$c(10),pnOutFmt)
 } 
  
 ; 21.01.20 tt; pridano generovani do xml pro KNAV prvku plny_text 
 d ##class(i2.export).outputAdd("  <"_sPrefix_"plny_text>"_sFullText_"</"_sPrefix_"plny_text>"_$c(10),pnOutFmt)
  
 ; uzaviraci prvek
 d ##class(i2.export).outputAdd("  </"_sPrefix_"soubory>"_$c(10),pnOutFmt)
]]></Implementation>
</Method>

<Method name="showRecordXMLKAVHodKr">
<Description><![CDATA[
<pre> Output jedneho zaznamu do XML ve firnatu pro KAV - pro hodnotici kriteria - zdroj, srj ...

05.06.14 tt; zalozena metoda
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,pnOutFmt,sFmtParams="",sPrefix=""]]></FormalSpec>
<Implementation><![CDATA[
  ; sjr 
  s sSJR=##class(User.Util).XMLfixup($$$getTagX(.handle,"T16s"))
  d ##class(i2.export).outputAdd("  <"_sPrefix_"sjr>"_sSJR_"</"_sPrefix_"sjr>"_$c(10),pnOutFmt)
  
  ; ais 
  s sAIS=##class(User.Util).XMLfixup($$$getTagX(.handle,"T16j"))
  d ##class(i2.export).outputAdd("  <"_sPrefix_"ais>"_sAIS_"</"_sPrefix_"ais>"_$c(10),pnOutFmt)
  
  s c=0,bUTISI=0
  d { 
    s sT014=$$$getTagXC(.handle,"014",.c) ; vsetky kody
    continue:((sT014="")&&(c'=0))
    if (sT014'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      if ($zcvt($$$getSubTagStr(sT014,"2"),"l")="wos")     
      { ; najdeme jen ty, co jsou WOS
        s sUTISI=$$$getSubTagStr(sT014,"a")
        continue:(sUTISI="") ; pokud nemame data, zkoncime 
        s:(sUTISI'="") sUTISI=##class(User.Util).XMLfixup(sUTISI)    
        d ##class(i2.export).outputAdd("  <"_sPrefix_"accession_number>"_sUTISI_"</"_sPrefix_"accession_number>"_$c(10),pnOutFmt) 
        s bUTISI=1
      }
    }
  } while (c'=0)    
  d:(bUTISI=0) ##class(i2.export).outputAdd("  <"_sPrefix_"accession_number></"_sPrefix_"accession_number>"_$c(10),pnOutFmt) 

  
  ; zkusime nacist zdroj
  s sLX=$$$getTagX(.handle,"463/001")
  d ##class(i2.export).outputAdd("  <"_sPrefix_"zdroj>"_$c(10),pnOutFmt) 
  if (sLX'="")
  { ; mame nejake data, pokracujeme dal
    if ##class(MARC).readLX(.handle4,sLX)
    {      
      s s200a = $$$getTagX(.handle4,"200a")
      s:(s200a'="") s200a=##class(User.Util).XMLfixup(s200a)
      d ##class(i2.export).outputAdd("    <"_sPrefix_"nazev>"_s200a_"</"_sPrefix_"nazev>"_$c(10),pnOutFmt) 
      s s011aA = $$$getTagXC(.handle4,"011a",-1)
      if (s011aA'="")
      { ; 25.03.11 tt; zmena indexovani issbn
        for l=1:1:$l(s011aA,$c(10))
        { ; zaindexujeme vsechny isbn
          s s011a=$p(s011aA,$c(10),l)  
          d ##class(i2.export).outputAdd("    <"_sPrefix_"issn>"_s011a_"</"_sPrefix_"issn>"_$c(10),pnOutFmt) 
        }
      }   
      else { d ##class(i2.export).outputAdd("    <"_sPrefix_"issn></"_sPrefix_"issn>"_$c(10),pnOutFmt)  }  
    }
  }
  else
  { ; pokud nemame zaznam - dame prazdne data
    d ##class(i2.export).outputAdd("    <"_sPrefix_"nazev></"_sPrefix_"nazev>"_$c(10),pnOutFmt) 
    d ##class(i2.export).outputAdd("    <"_sPrefix_"issn></"_sPrefix_"issn>"_$c(10),pnOutFmt)
  } 
  d ##class(i2.export).outputAdd("  </"_sPrefix_"zdroj>"_$c(10),pnOutFmt)
]]></Implementation>
</Method>

<Method name="ImpHod2015">
<Description>
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

Postup importu:
1. Smazat vsechno co je nastavene v autoritach (C48) a v zaznamech (700w,C64)
2. Import udaju do autorit (C48)
3. Dotazeni do pole 700w udaje o tymu (do zaznamu s vrocenim 2010-2014)
4. Import udaju z CSV do zaznamu (C64), C64a nastavit na "k hodnoceni!).

Import by mohl probihat v nejakych pravidelnych intervalech, aby byl v
ASEP aktualni stav.
28.01.15 tt; vytvoreno

Importni metoda pro import dat z csv k hodnoceni.


d ##class(User.CavS).ImpHod2015("Tymy_zaznamy.csv","K","Tymy_zaznamy.log")
d ##class(User.CavS).ImpHod2015("Tymy_autori.csv","A","Tymy_autori.log")
pFile   - nazev souboru
pTyp    - A - autority - K - katalog
pLog    - log soubor</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFile:%String,pTyp:%Integer,pLog=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 s file=##class(%FileCharacterStream).%New() ; otevreni vstupniho souboru
 s file.Filename=pFile
 d file.TranslateTableSet("UTF8")  ; otevreni v UTF8
 ;d file.TranslateTableSet("CP1250")
 s sLine=file.ReadLine()           ; nacten prvni radek
 
 f
 { ; cyklus pres cely soubor
   s sLine=file.ReadLine()         ; cten 1 radek
   
   if (sLine'="")
   { ; pokud mame vyplneny radek, zpracovavame
     s sL1=$p(sLine,";",1),sL2=$p(sLine,";",2),sL3=$p(sLine,";",3),sL4=$p(sLine,";",4)
     s sL5=$p(sLine,";",5),sL6=$p(sLine,";",6),sL7=$p(sLine,";",7),sL8=$p(sLine,";",8)
     if (pTyp="K")
     {
       ; Tymy_zaznamy.csv
       ; sysno;tým;ústav;obor;podobor
       d ..ImpHod2015Kat(sL1,sL2,sL3,sL4,sL5,pLog)
     }
     if (pTyp="A")
     {
       ; Tymy_autori.csv
       ; Autor;Sysno autority;Tým;Tým eng;Oborová skupina;Zařazení (vědecký, další pracovník)
       d ..ImpHod2015Auth(sL2,sL3,sL4,sL5,sL6,pLog)
     }
   }   
   q:(file.AtEnd) ; pokud je konec souboru, ukoncime zpracovani
 }
 d file.%Close()                   ; zavreni souboru
]]></Implementation>
</Method>

<Method name="ImpHod2015Kat">
<Description>
Import udaju do katalogu - C64
C64a =1
sysno;tým C64b;ústav C64c;obor C64d;podobor C64e
28.01.15 tt; doplnena importni metoda C64</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pT001="",pTym="",pUstav="",pObor="",pPodobor="",pLog=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 
 s err=""
 if ##class(User.MARC).readX(.handle,"CavUnEpca",pT001) 
 { ; pokusime se otevrit handle
   w !,"------------------------------------------------------------------------------"
   w !,"CavUnEpca*"_pT001

   s sCatT=""
   s sCatT=##class(User.MARC).setSubTagStr(sCatT,$c(31)_"a1","C64   ")
   s:(pTym'="") sCatT=##class(User.MARC).setSubTagStr(sCatT,$c(31)_"b"_pTym,"C64   ") 
   s:(pUstav'="") sCatT=##class(User.MARC).setSubTagStr(sCatT,$c(31)_"c"_pUstav,"C64    ") 
   s:(pObor'="") sCatT=##class(User.MARC).setSubTagStr(sCatT,$c(31)_"d"_pObor,"C64    ") 
   s:(pPodobor'="") sCatT=##class(User.MARC).setSubTagStr(sCatT,$c(31)_"e"_pPodobor,"C64    ") 
   ; radky pouze pridavame (nemazeme puvodni). Provedeme jen kontrolu, jestli nahodou jiz neexistuji
   s sTagC64=$$$getTagXC(.handle,"C64",-1)
   ; vlozime radek a ulozime zaznam
   d:((sCatT'="")&&('$f($c(10)_sTagC64_$c(10),$c(10)_sCatT_$c(10)))) ##class(User.MARC).appendLineX(.handle,sCatT)
   w:(sTagC64'="") !,"Do exostujici:"_$$$strswap(sTagC64,$c(31),"$$")
   w !,"Pridano:"_$$$strswap(sCatT,$c(31),"$$")
   
   s st=##class(User.MARC).writeX(.handle,0,0)
   if '$$$ISOK(st) 
   { ; ulozime si chybu pro pozdejsi zpracovani
     s err="Error - write: (CavUnEpca/"_pT001_") - "_##class(User.Util).status2str(st)
   }
 }
 else
 { ; vypis, ze nam chybi autorita
   s err="Error - (CavUnEpca/"_pT001_") - nepodarilo se otevrit zaznam pro doplneni dat"
 }
 
 if (pLog'="")
 { ; pokud mame log, piseme informace o improtu do logu
   d:(err'="") ##class(User.Util).xlogf(pLog,pT001_"#####"_err)
 }
 else 
 { ; pokud nemame log, vypisou se informace na standardni vystup
   w:(err'="") !,err       ; proveden vypis
 }
]]></Implementation>
</Method>

<Method name="ImpHod2015Auth">
<Description><![CDATA[
<pre> Import udaju do autority - C48 pro ucely hodnoceni
Parametry: pT001      - ID autority
           pTym       - nazev ci zkratky tymu
           pTymEng    - anglicky nazev ci zkratka tymu
           pOborSk    - oborova skupina
           pZarazeni  - zarazeni
           pLog       - log soubor. Pokud neni zadan, vypisuji se chyby na standardni vystup

Autor;Sysno autority;Tým C48x;Tým eng C48y;Oborová skupina C48z;Zařazení C48k
28.01.15 tt; doplnena importni metoda C48
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pT001="",pTym="",pTymEng="",pOborSk="",pZarazeni="",pLog=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 
 s err=""
 if ##class(User.MARC).readX(.handle,"CavUnAuth",pT001) 
 { ; pokusime se otevrit handle
   w !,"------------------------------------------------------------------------------"
   w !,"CavUnAuth*"_pT001
   s sAutT=""
   s:(pTym'="") sAutT=##class(User.MARC).setSubTagStr(sAutT,$c(31)_"x"_pTym,"C48   ") 
   s:(pTymEng'="") sAutT=##class(User.MARC).setSubTagStr(sAutT,$c(31)_"y"_pTymEng,"C48    ") 
   s:(pOborSk'="") sAutT=##class(User.MARC).setSubTagStr(sAutT,$c(31)_"z"_pOborSk,"C48    ") 
   s:(pZarazeni'="") sAutT=##class(User.MARC).setSubTagStr(sAutT,$c(31)_"k"_pZarazeni,"C48    ") 
   ; radky pouze pridavame (nemazeme puvodni). Provedeme jen kontrolu, jestli nahodou jiz neexistuji
   s sTagC48=$$$getTagXC(.handle,"C48",-1)
   ; vlozime radek a ulozime zaznam
   d:((sAutT'="")&&('$f($c(10)_sTagC48_$c(10),$c(10)_sAutT_$c(10)))) ##class(User.MARC).appendLineX(.handle,sAutT)
   w:(sTagC48'="") !,"Do exostujici:"_$$$strswap(sTagC48,$c(31),"$$")
   w !,"Pridano:"_$$$strswap(sAutT,$c(31),"$$")
  
   s st=##class(User.MARC).writeX(.handle)
   if '$$$ISOK(st) 
   { ; ulozime si chybu pro pozdejsi zpracovani
     s err="Error - write: (CavUnAuth/"_pT001_") - "_##class(User.Util).status2str(st)
   }
 }
 else
 { ; vypis, ze nam chybi autorita
   s err="Error - (CavUnAuth/"_pT001_") - nepodarilo se otevrit zaznam pro doplneni dat"
 }
 
 if (pLog'="")
 { ; pokud mame log, piseme informace o improtu do logu
   d:(err'="") ##class(User.Util).xlogf(pLog,pT001_"#####"_err)
 }
 else 
 { ; pokud nemame log, vypisou se informace na standardni vystup
   w:(err'="") !,err       ; proveden vypis
 }
]]></Implementation>
</Method>

<Method name="FindgwCountStazeno">
<Description><![CDATA[
<pre> Metoda pro nalezeni zaznamu, ktere maji jine cislo stazeni ze statitik a array
s sy="ret1=(##class(User.CavS).FindgwCountStazeno(.handle)>0)"
d ^X("s CavUnEpca @"_sy)
03.01.15 tt; zalozena metoda
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Binary]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s ret=0
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  s sIdx=##class(i2.dblink).recordIdX(.handle) ; ziskame id zaznamu 
   
  ; ziskame vsechny data k zaznamu v output
  d ##class(content.api).selectRecAll(.output,sClass,sT001)
    
  ; prochazime postupne cyklem vsech polozek k zaznamu
  s item=""      ; jedna polozka k zaznamu
  f { s item=$o(output(item)) q:item=""
    s repo=output(item,"repository")   ; ziskame repository
    s key=output(item,"key")           ; klice
    ; nacteme delsi pomocna data k jednomu zaznamu
    
    d ##class(content.api).getBatch(.array,repo,key)         ; ziskame informace z array    
    //////////////////////////////////////////////////////////////////////////////
    s myquery = "SELECT count(*) as Pocet FROM content.stat WHERE Repo = '"_repo_"' AND Ckey = '"_key_"' AND Operation = 'read' AND Result = '1'"
  
    s nPocet=0  ; nastavime si pocet
    s rset=##class(%ResultSet.SQL).%Prepare(myquery,.err,"")
    s nArrayPoc=array("count")
    while rset.%Next() 
    { ; prochazime jednotlivymi vyselektovanymi udaji
      d rset.%Print(",")
      s nPocet=rset.%GetData(1)
      q  ; staci nam jen jeden pruchod - jistota
    }
    s:(nArrayPoc'=nPocet) ret=1
    ;b ; moje
  } ; konec cyklu prochazeni souboru k zaznamu
 q ret
]]></Implementation>
</Method>

<Method name="gwCountStazeno">
<Description>

 d ^X("s CavUnEpca")
 s sy="##class(User.CavS).gwCountStazeno(.handle)"
 d ^X("l @"_sy)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle]]></FormalSpec>
<Implementation><![CDATA[
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  s sIdx=##class(i2.dblink).recordIdX(.handle) ; ziskame id zaznamu 
  s %ipac2("ictx")="cav" 
  ; ziskame vsechny data k zaznamu v output
  d ##class(content.api).selectRecAll(.output,sClass,sT001)
    
  ; prochazime postupne cyklem vsech polozek k zaznamu
  s item=""      ; jedna polozka k zaznamu
  f { s item=$o(output(item)) q:item=""
    s repo=output(item,"repository")   ; ziskame repository
    s key=output(item,"key")           ; klice
    ; nacteme delsi pomocna data k jednomu zaznamu
    
    d ##class(content.api).getBatch(.array,repo,key)         ; ziskame informace z array    
    //////////////////////////////////////////////////////////////////////////////
    s myquery = "SELECT count(*) as Pocet FROM content.stat WHERE Repo = '"_repo_"' AND Ckey = '"_key_"' AND Operation = 'read' AND Result = '1'"
  
    s nPocet=0  ; nastavime si pocet
    s rset=##class(%ResultSet.SQL).%Prepare(myquery,.err,"")
    s nArrayPoc=array("count")    ; pocet z array

    while rset.%Next() 
    { ; prochazime jednotlivymi vyselektovanymi udaji
      d rset.%Print(",")
      s nPocet=rset.%GetData(1)
      q  ; staci nam jen jeden pruchod - jistota
    }
    ; tady mame dobre ziskany pocet podle statistk
    if (nArrayPoc'=nPocet)
    {
      ////////////////////////////////////////////////////////////////////////
      // SELECT count(*) FROM content.stat WHERE Repo = 'crepo1' AND Ckey = '31344487815' AND Operation = 'read'
      s array("count")=nPocet
      ///d ##class(content.api).update(.array)
    }
  } ; konec cyklu prochazeni souboru k zaznamu
]]></Implementation>
</Method>

<Method name="exDataSCOPUS">
<Description><![CDATA[
<pre>
cav - vystupy periodik SCOPUS - cs29332 - high
Dobry den, potrebovaly bychom v systemu rozlisit zaznamy SCOPUS. Nevim presne jak to je, predpokladam, ze  tyto zaznamy maji SJR.
Potrebovaly bychom ted co nejdriv dva vystupy:
 1. zaznamu rok 2010-2014 navazanych na autority, kde je SJR.
 2. zaznamy navazane na autority, kde je SRJ a neni IF
sysno;ustav;UTSCOPUS;rok;nazev periodika;ISSN

s poradi=0
s sy="ret1=(##class(User.CavS).exDataSCOPUS(.handle,.poradi)>0)"
d ^X("s CavUnEpca tag = 463")
d ^X("s &&CavUnEpca @"_sy)

</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,&poradi]]></FormalSpec>
<Implementation><![CDATA[
  s cesta="d:\RecScopus"
  ; sysno;ustav;UTSCOPUS;rok;NazevPeriodika;ISSN;DruhDokumentu
  ; sT001,sUSTAV;sSCOPUSID;sRocnik; t200a; sISSN; sDRUHDOKUMENTU
  d:(poradi=0) ##class(User.Util).xlogf(cesta_".csv","sysno;ustav;UTSCOPUS;rok;NazevPeriodika;ISSN;DruhDokumentu")
  d:(poradi=0) ##class(User.Util).xlogf(cesta_"bezIF"_".csv","sysno;ustav;UTSCOPUS;rok;NazevPeriodika;ISSN;DruhDokumentu")

  s poradi=1
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  s t463=$$$getTagX(.handle,"463") 
  
  s sUSTAV=$$$getTagX(.handle,"C26e")
  s sDRUHDOKUMENTU=$$$getTagX(.handle,"970b")

  s sRocnik="",sISSN="", sJESRJ=0,sJEIF=0
  
  ; nazev 
  s t200a=##class(rep.epca.exportBase).exGetT4xx(t463,"200a")
  ; strany od-do
  s t200v=##class(rep.epca.exportBase).exGetT4xx(t463,"200v")
  d ##class(rep.epca.exportBase).exParse463(t200v,1,.sRocnik,.sCislo,.sStrany)

  s rok=$p(t200v,"(",2)
  s rok=$$$trim($p(rok,")",1))
  if ((sRocnik="")||($l(sRocnik)'=4))
  {
    s:(($l(rok)=4)&&(rok?4N)) sRocnik=rok
  }
  q:(sRocnik="") 0
  if ('$f(",2010,2011,2012,2013,2014,",sRocnik))
  { ; pokud nam rocnik nespadl do datumoveho rozsahu, koncime
    q 0
  }
  d ##class(User.MARC).t4xx2handle(.h4xx, t463) 
  s sT001463=$$$HandleT001(h4xx)
  s sClass4463=$$$HandleClass(h4xx)

  if ($g(sT001463,"")'="")
  { ; pokud mame 463
    if ##class(User.MARC).readX(.handleP463,sClass4463,sT001463) 
    { ; nacteme z handlu 978c
      s sISSN=$$$getTagX(.handleP463,"011a")
        
      s c=0
      d {
        s sT978=$$$getTagXC(.handleP463,"978",.c) ; vsetky citacie
        continue:((sT978="")&&(c'=0))
        if (sT978'="")
        { ; pokud mame vyplnene data, muzeme provadet akce 
          s sT978a=$$$getSubTagStr(sT978,"a")
          if ($f(",2010,2011,2012,2013,2014,",sT978a))
          { ; pokud mame 4mistny rok, pouzijeme ho na srovnani
            s bIF=($$$getSubTagStr(sT978,"c")'="")   
            s bSJR=($$$getSubTagStr(sT978,"s")'="")    
            s:(bSJR=1) sJESRJ=1
            s:(bIF=1) sJEIF=1
          }
        }
      } while (c'=0)      
    } 
  } 
 
  s sSCOPUSID=""
  s c=0
  d { 
   s sT014=$$$getTagXC(.handle,"014",.c) ; vsetky citacie
   continue:((sT014="")&&(c'=0))
   if (sT014'="")
   { ; pokud mame vyplnene data, muzeme provadet akce 
     if ($zcvt($$$getSubTagStr(sT014,"2"),"l")="scopus")     
     {
       s sSCOPUSID=$$$getSubTagStr(sT014,"a")
     }
   }
  } while (c'=0)    

  ; sysno;ustav;UTSCOPUS;rok;nazev periodika;ISSN; DruhDokumentu
  ; sT001,sUSTAV;sSCOPUSID;sRocnik; t200a; sISSN; sDRUHDOKUMENTU
  d:(sJESRJ=1) ##class(User.Util).xlogf(cesta_".csv",sT001_";"_sUSTAV_";"_sSCOPUSID_";"_sRocnik_";"_t200a_";"_sISSN_";"_sDRUHDOKUMENTU)
  d:((sJESRJ=1)&&(sJEIF=0)) ##class(User.Util).xlogf(cesta_"bezIF"_".csv",sT001_";"_sUSTAV_";"_sSCOPUSID_";"_sRocnik_";"_t200a_";"_sISSN_";"_sDRUHDOKUMENTU)
  q 0
]]></Implementation>
</Method>

<Method name="fixMetadata">
<Description><![CDATA[
<pre> hromadna oprava metadat - druhu dokumentu J na Ji
d ##class(User.CavS).fixMetadata()
02.06.15 - pridana metoda na upravu metadat statistik
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>repo="crepo1",test=1</FormalSpec>
<Implementation><![CDATA[
  q:repo=""
  
  s count=0, fixed=0, saved=0
  
  &sql(DECLARE C5 CURSOR FOR
    SELECT ID, CKey, RecKind, RecT001
    INTO :id, :key, :RecKind, :RecT001 
    FROM content.stat
    WHERE Repo = :repo AND RecClass = 'CavUnEpca' AND RecKind = 'J'
  )
  
  &sql(OPEN C5)
  for { &sql(FETCH C5) q:SQLCODE
    s count=count+1 
    w !,"-----------------------------------------------------------------"
    w !,"id=",id
    s obj=##class(content.stat).%OpenId(id)
    ;d $system.OBJ.Dump(obj)
    continue:'$isobject(obj)
    
    if (RecT001'="") && ##class(User.MARC).readX(.handle,"CavUnEpca",RecT001) {
    s s970b=##class(User.MARC).getTagX(.handle,"970b")
   
    if (s970b="J")
    { ; 01.06.15 tt; vyjimka pro CAV na indexaci druhu dokumentu - impaktovane clanky JI
      s idc=##class(User.MARC).recordIdX(.handle) 
      s dok="",dokx=""
      for { ; nalezeni vsech druhu dokumentu
       set dokx=$o(^$$$MarcIndexG("CavUnEpca",idc,"dk",dokx)) 
       q:(dokx="")  
       s dok=dok_" "_dokx
      }
      if ($f(dok," ji ")) 
      {
        s obj.RecKind="JI"
        s fixed=fixed+1
        if 'test && (obj.%Save()) {
           s saved=saved+1
        }
      }
    }
   }
   w !,"001: "_RecT001
   w !,"dk: "_dok
   w !,"hod: "_obj.RecKind
  }
  &sql(CLOSE C5)  
  w !!,"celkem=",count,", zmeneno=",fixed,", ulozeno=",saved
]]></Implementation>
</Method>

<Method name="exportXMLOpenAIRE">
<Description><![CDATA[
<pre> Vystup xml datacite

13.09.23 tt; zalozeno pro export xml do openaire - datacite 
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,pnWhat,pnOutFmt]]></FormalSpec>
<Implementation><![CDATA[
  s xmlchs=$$$GETSESSVAR("xmlchs")
  if xmlchs="" 
  {
    d ##class(i2.export).outputAdd("internal error - missing variable '_xmlchs'",pnOutFmt)
      q  
  }
  
  if (pnWhat=$$$I2ExportHdr)
  {
      s xmlns="https://purl.org/dc/elements/1.1/"
     d ##class(i2.export).outputAdd("<?xml version=""1.0"" encoding="""_xmlchs_"""?>"_$$$CRLF
                     _"<collection xmlns="""_xmlns_""">"_$$$CRLF,pnOutFmt)
      q
  }
  if pnWhat=$$$I2ExportFooter  
  {
      d ##class(i2.export).outputAdd("</collection>",pnOutFmt)
      q
  }
  if pnWhat'=$$$I2ExportBody zt "ER1" ; poistka chybne volanie
  
  ; 16.02.23 tt; znovu obnovena funkčnost kvůli openaire
  ; 29.11.22 tt; provedena změna hlavičky pro export do openaire + i2.ws.oai
  //d ##class(i2.export).outputAdd("<resource xsi:schemaLocation=""http://datacite.org/schema/kernel-3 http://schema.datacite.org/meta/kernel-3/metadata.xsd"">"_$$$CRLF,pnOutFmt)                          
  d ##class(CavUnEpca).exportDataciteXmlHandle(.handle, pnOutFmt,,"Openaire")
  //d ##class(i2.export).outputAdd("</resource>"_$$$CRLF,pnOutFmt)
]]></Implementation>
</Method>

<Method name="exportDCOpenAIRE">
<Description><![CDATA[
<pre> Vystup xml DublinCore

15.08.23 tt; provedena oprava dotahování identifikátorů
02.09.15 tt; zalozena metoda pro specialni export dc do OPENAIRE - cs29885 
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,pnWhat,pnOutFmt]]></FormalSpec>
<Implementation><![CDATA[
  s xmlchs=$$$GETSESSVAR("xmlchs")
  if xmlchs="" 
  {
    d ##class(i2.export).outputAdd("internal error - missing variable '_xmlchs'",pnOutFmt)
      q  
  }
  
  if (pnWhat=$$$I2ExportHdr)
  {
      s xmlns="https://purl.org/dc/elements/1.1/"
     d ##class(i2.export).outputAdd("<?xml version=""1.0"" encoding="""_xmlchs_"""?>"_$$$CRLF
                     _"<collection xmlns="""_xmlns_""">"_$$$CRLF,pnOutFmt)
      q
  }
  if pnWhat=$$$I2ExportFooter  
  {
      d ##class(i2.export).outputAdd("</collection>",pnOutFmt)
      q
  }
  if pnWhat'=$$$I2ExportBody zt "ER1" ; poistka chybne volanie
  
  ; 16.02.23 tt; znovu obnovena funkčnost kvůli openaire
  ; 29.11.22 tt; provedena změna hlavičky pro export do openaire + i2.ws.oai
  //d ##class(i2.export).outputAdd("<oai_dc:dc>"_$$$CRLF,pnOutFmt) 
  d ##class(i2.export).outputAdd("<oai_dc:dc"_$$$CRLF
             _"  xmlns:oai_dc=""http://www.openarchives.org/OAI/2.0/oai_dc/"""_$$$CRLF
             _"  xmlns:dc=""http://purl.org/dc/elements/1.1/"""_$$$CRLF
             _"  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"""_$$$CRLF
             _"  xsi:schemaLocation=""http://www.openarchives.org/OAI/2.0/oai_dc/"_$$$CRLF
             _"  http://www.openarchives.org/OAI/2.0/oai_dc.xsd"">"_$$$CRLF,pnOutFmt)                          
  d ..dublinCoreOpenAIRE(.ExpArr,.handle)
  d ##class(i2.export).evalExpArr(.ExpArr,"dc:",,,"2PO",pnOutFmt)
  d ##class(i2.export).outputAdd("</oai_dc:dc>"_$$$CRLF,pnOutFmt)
]]></Implementation>
</Method>

<Method name="dublinCoreOpenAIRE">
<Description><![CDATA[
<pre>Vytvori Export Array pro dublin core OpenAIRE

29.10.15 tt; upraven export projektu o 230b
08.09.15 tt; upraven export OpenAire
04.09.15 tt; zmeny podle zadani
02.09.15 tt; zalozena metoda
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pole,&handle:%Binary]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s sFormat=##class(User.MARC).recordDataFmtX(.handle)
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  s bExportAuth=0
  
  //d ##class(i2.export).createExpArrNode(.pole,.handle,"title","200#a")
  s sT200a=$$$getTagX(.handle,"200a")
  s:(sT200a'="") pole("title",1)=sT200a
  
  /// autori
  s c=0,sCount=1
  d {
    s sT7XX=$$$getTagXC(.handle,"70*",.c) ; vsetky citacie
    continue:((sT7XX="")&&(c'=0))
    if (sT7XX'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      s sTag=$e(sT7XX,1,3)
      continue:('$f("700,701",sTag))
      s sT7XXa=$$$getSubTagStr(sT7XX,"a")
      s sT7XXb=$$$getSubTagStr(sT7XX,"b")
      s:(('$f(sT7XXb,"."))&&(sT7XXb'="")) sT7XXb=($e(sT7XXb,1)_". ("_sT7XXb_")")
      s sT7XX4=$$$getSubTagStr(sT7XX,"4")
      //continue:((sT7XX4'="070")&&((sT7XX4'="")))
      s:((sT7XXa'="")&&(sT7XXb'="")) sT7XXb=", "_sT7XXb
      if ((sT7XXa'="")||(sT7XXb'=""))
      { ; pokud mame data, vyplnime
        s pole("creator",sCount)=(sT7XXa_sT7XXb)
        s sCount=sCount+1
        s bExportAuth=1
      }
    }
  } while (c'=0)
  /////////////////////////
  ; Projekt EU  C12 <dc:relation>info:eu-repo/grantAgreement/EC/FP7/283595/EU//OpenAIREplus</dc:relation>   poskytovatel EU, program, číslo
  s c=0,sCountRel=1
  d {
    s sTC12=$$$getTagXC(.handle,"C12",.c) ; vsetky citacie
    continue:((sTC12="")&&(c'=0))
    if (sTC12'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      s sTC123=$$$getSubTagStr(sTC12,"3")
      if (sTC123'="")
      { ; pokud mame data, vyplnime
        if ##class(User.MARC).readLX(.handleA,sTC123) 
        { 
          ; (C28$e/230$b/230$h)
          ; info:eu-repo/grantAgreement/EC/FP7/283595
          s sTAC28e=$$$getTagX(.handleA,"C28e")     
          s sTA230b=$$$getTagX(.handleA,"230b")
          s sTA230q=$$$getTagX(.handleA,"230q")
          s sTA230h=$tr($$$getTagX(.handleA,"230h"),"-","/")
          if ((sTAC28e'="")&&(sTA230h'=""))
          {
            //s pole("relation",sCountRel)=("info:eu-repo/grantAgreement/"_sTAC28e_"/"_sTA230b_sTA230h)
            s pole("relation",sCountRel)=("info:eu-repo/grantAgreement/"_sTAC28e_"/"_sTA230b_"/"_sTA230h_"/EU/"_"/"_sTA230q)
            s sCountRel=sCountRel+1
          }
        }      
      }
    }
  } while (c'=0) 
  
  ; Zpřístupnění FT dokumentu   C65a    <dc:rights>info:eu-repo/semantics/openAccess</dc:rights></code> "• info:eu-repo/semantics/closedAccess
  ; • info:eu-repo/semantics/embargoedAccess E
  ; • info:eu-repo/semantics/restrictedAccess R
  ; • info:eu-repo/semantics/openAccess  O
 ///d ##class(i2.export).createExpArrNode(.pole,.handle,"rights","C65#a")
  /////////////////////////////////////////////////////////////
  ; ziskame vsechny data k zaznamu v output
  d ##class(content.api).selectRecAll(.output,sClass,sT001)
    
  ; prochazime postupne cyklem vsech polozek k zaznamu
  s item="",sStav="",sDate=""     ; jedna polozka k zaznamu
  f { 
    s item=$o(output(item)) q:item=""
    s repo=output(item,"repository")   ; ziskame repository
    s key=output(item,"key")           ; klice
    ; nacteme delsi pomocna data k jednomu zaznamu
    
    d ##class(content.api).getBatch(.array,repo,key)                           ; ziskame informace z array    
    s sSTa="", sSTb="", sSTc=""
    s sPomStav=$tr(array("accession"),"X","R")
    s:('$f(sStav,sPomStav)) sStav=sStav_$c(31)_sPomStav
    s:('$f(sDate,array("dayfrom"))) sDate=sDate_$c(31)_array("dayfrom")  
  }  
  
  s sPocet=1
  for i=1:1:$l(sStav,$c(31))
  { ; prochazeni pres vsechny stavy
    s sStav1=$p(sStav,$c(31),i)
    continue:(sStav1="")
    s:(sStav1="E") pole("rights",sPocet)="info:eu-repo/semantics/embargoedAccess"
    s:(sStav1="R") pole("rights",sPocet)="info:eu-repo/semantics/restrictedAccess"
    s:(sStav1="O") pole("rights",sPocet)="info:eu-repo/semantics/openAccess"
    s sPocet=sPocet+1   
  }
  
  ///////////////////////////////////////////////////////////////////////////////////////////////
  ; Datum ukončení embarga      <dc:date>info:eu-repo/date/embargoEnd/2015-12-31</dc:date>
  s sPocetDate=1
  for i=1:1:$l(sDate,$c(31))
  { ; prochazeni pres vsechny stavy
    s sDate1=$p(sDate,$c(31),i)
    continue:(sDate1="")
    s pole("date",sPocetDate)="info:eu-repo/date/embargoEnd/"_$e(sDate1,1,4)_"-"_$e(sDate1,5,6)_"-"_$e(sDate1,7,8)  
    s sPocetDate=sPocetDate+1   
  }
  
  //////////////////////////////////////////////////////////////////////////////////////// 
  ;Další jedinečný identifikátor záznamu (DOI, UTWOS, SCOPUS, ISSN, ISBN)   14a, 17a,   "<dc:relation>info:eurepo/semantics/altIdentifier/doi/10.1234/789.1</dc:relation>
   //s sIdx=##class(i2.dblink).recordIdX(.handle) ; ziskame id zaznamu 
   /// 15.08.23 tt; provedena oprava dotahování identifikátorů
  s sIdx=##class(MARC).recordIdX(.handle)
  s sIssn=$o(^$$$MarcIndexG("CavUnEpca",sIdx,"issn",""))
  s seIssn=$o(^$$$MarcIndexG("CavUnEpca",sIdx,"zeissn",""))
  s sIsbn=$o(^$$$MarcIndexG("CavUnEpca",sIdx,"isbn",""))
  s sDoi=$$$getTagX(.handle,"017a")
  // https://guidelines.openaire.eu/en/latest/literature/field_alternativeidentifier.html
  
  s c=0
  d { ; 27.09.14 tt; pridano do exportu z kosiku csv rozliseni pro 014 - kod wos a scopus 
    s sT014=$$$getTagXC(.handle,"014",.c) ; vsetky citacie
    continue:((sT014="")&&(c'=0))
    s sT014a=$$$getSubTagStr(sT014,"a")
    if (sT014a'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      ; 24.01.15 tt; upraven format ID WOS a SCOPUS 
      if ($zcvt($$$getSubTagStr(sT014,"2"),"l")="wos")     
      { ; pokud mam ID pro wos, ulozim  si
        //s pole("relation",sCountRel)="info:eu-repo/semantics/altIdentifier/wos/"_sT014a
        //s sCountRel=sCountRel+1   
      }
      if ($zcvt($$$getSubTagStr(sT014,"2"),"l")="scopus")     
      { ; pro ID scopusu si take ulozim
        //s pole("relation",sPocet)="info:eu-repo/semantics/altIdentifier/scopus/"_sT014a
        //s sPocet=sPocet+1     
      }
      if ($zcvt($$$getSubTagStr(sT014,"2"),"l")="pubmed")     
      { ; pubmed
        s pole("relation",sCountRel)="info:eu-repo/semantics/altIdentifier/pmid/"_sT014a
        s sCountRel=sCountRel+1     
      }
    }
  } while (c'=0)  
   
  //if (sDoi'="") { s pole("relation",sCountRel)="info:eu-repo/semantics/altIdentifier/doi/"_sDoi, sCountRel=sCountRel+1}
  //if (sIssn'="") { s pole("relation",sCountRel)="info:eu-repo/semantics/altIdentifier/pissn/"_sIssn, sCountRel=sCountRel+1}
  //if (seIssn'="") { s pole("relation",sCountRel)="info:eu-repo/semantics/altIdentifier/eissn/"_seIssn, sCountRel=sCountRel+1}
  //if (sIsbn'="") { s pole("relation",sCountRel)="info:eu-repo/semantics/altIdentifier/isbn/"_sIsbn, sCountRel=sCountRel+1}
  ; 06.09.2015 tt doi, issn a isbn presunuto na 18
  /// https://guidelines.openaire.eu/en/latest/literature/field_resourceidentifier.html
  s sCountIdent=1
  if (sDoi'="") { s pole("identifier",sCountIdent)="info:doi:"_sDoi, sCountIdent=sCountIdent+1}
  if (sIssn'="") { s pole("identifier",sCountIdent)="urn:pissn:"_sIssn, sCountIdent=sCountIdent+1}
  if (seIssn'="") { s pole("identifier",sCountIdent)="urn:eissn:"_seIssn, sCountIdent=sCountIdent+1}
  if (sIsbn'="") { s pole("identifier",sCountIdent)="urn:isbn:"_sIsbn, sCountIdent=sCountIdent+1}

  /////////////////////////////////////////////////
  
  
  ; Předmět ( klíčová slova)    610a    "<dc:subject>polar oceanography; boundary current; masstransport; water masses;
  ; halocline; mesoscaleeddies</dc:subject>"
  //s s610a=$$$strswap($$$getTagXC(.handle,"610a",-1),$c(10),"; ")
  //s pole("subject",1)=s610a
  s c=0,sPocet=1
  d { ; 27.09.14 tt; pridano do exportu z kosiku csv rozliseni pro 014 - kod wos a scopus 
    s sT610=$$$getTagXC(.handle,"610",.c) ; vsetky citacie
    continue:((sT610="")&&(c'=0))
    s sT610a=$$$getSubTagStr(sT610,"a")
    if (sT610a'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      s pole("subject",sPocet)=sT610a
      s sPocet=sPocet+1
    }
  } while (c'=0) 


  ;Popis (anotace eng)  C15a, b dc:description
  s sPopis=""
  s s101a=$$$getTagX(.handle,"101a")
  if (s101a="eng") { s sPopis=$$$getTagX(.handle,"C15a") }
  else  { s sPopis=$$$getTagX(.handle,"C15b") }
  s:(sPopis'="") pole("description",1)=sPopis
  
  ; Editor (role)   700, 701 4  dc:contributor
  s c=0,sCount=1
  d {
    s sT7XX=$$$getTagXC(.handle,"70*",.c) ; vsetky citacie
    continue:((sT7XX="")&&(c'=0))
    if (sT7XX'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      s sTag=$e(sT7XX,1,3)
      continue:('$f("700,701",sTag))
      s sT7XXa=$$$getSubTagStr(sT7XX,"a")
      s sT7XXb=$$$getSubTagStr(sT7XX,"b")
      s:(('$f(sT7XXb,"."))&&(sT7XXb'="")) sT7XXb=($e(sT7XXb,1)_". ("_sT7XXb_")")
      s sT7XX4=$$$getSubTagStr(sT7XX,"4")
      continue:(sT7XX4'="340")
      s:((sT7XXa'="")&&(sT7XXb'="")) sT7XXb=", "_sT7XXb
      if ((sT7XXa'="")||(sT7XXb'=""))
      { ; pokud mame data, vyplnime
        s pole("contributor",sCount)=(sT7XXa_sT7XXb)
        s sCount=sCount+1
        s bExportAuth=1
      }
    }
  } while (c'=0)
  
  ; Nakladatel  210c    "dc:publisher
  d ##class(i2.export).createExpArrNode(.pole,.handle,"publisher","210#c")
  
  ; Datum vydání    463v (J), 210d (B, C…), C11c(P) dc:date
  s s970b=$$$getTagX(.handle,"970b"),datum=""
  if ($e(s970b,1)="J")
  { 
    s sCitation=$$$getTagX(.handle,"463/200v")
    d ##class(rep.epca.exportBase).parse463200v(sCitation,.rocnik,.cislo,.datum,.od,.do)    
  }
  elseif($e(s970b,1)="P")
  {
    s datum1=$$$getTagX(.handle,"C11c")   ; datum  
    s datum=$e(datum1,7,10)_"-"_$e(datum1,4,5)_"-"_$e(datum1,1,2)
  }
  else
  {
    s datum=$$$getTagX(.handle,"210d")   ; datum  
  }
  s:(datum="") datum=$$$getTagX(.handle,"463/210d")
  
  if (datum'="")
  { ; pocitadlo pouzito jiz vyse
    s pole("date",sPocetDate)=datum
    s sPocetDate=sPocetDate+1
  }
  
  ; Druh dokumentu  970b (B, C, K, M, J, V, P)  dc:type
  ;info:eu-repo/semantics/article - J
  ;info:eu-repo/semantics/book - B
  ;info:eu-repo/semantics/bookPart - M
  ;info:eu-repo/semantics/conferenceObject – C, K
  ;info:eu-repo/semantics/report - V
  ;info:eu-repo/semantics/patent - P 
  ;info:eu-repo/semantics/other – G, H, T (B), E, 
  if (s970b="J") { s pole("type",1)="info:eu-repo/semantics/article" }
  elseif (s970b="B") { s pole("type",1)="info:eu-repo/semantics/book" }
  elseif (s970b="M") { s pole("type",1)="info:eu-repo/semantics/bookPart" }
  elseif ((s970b="C")||(s970b="K")) { s pole("type",1)="info:eu-repo/semantics/conferenceObject" }
  elseif (s970b="V") { s pole("type",1)="info:eu-repo/semantics/report" }
  elseif (s970b="P") { s pole("type",1)="info:eu-repo/semantics/patent" }
  else { s pole("type",1)="info:eu-repo/semantics/other" } 
  s pole("type",2)="info:eu-repo/semantics/publishedVersion"
  
  ; Identifikace zdroje (handle)    C60a    <dc:identifier>https://hdl.handle.net/11104/0240210</dc:identifier>
  d ##class(i2.export).createExpArrNode(.pole,.handle,"identifier","C60#a")
  
  ; Jazyk 101a  101a    <dc:language>eng</dc:language>
  d ##class(i2.export).createExpArrNode(.pole,.handle,"language","101#a","E")

  ; Pro koho        <dc:audience>Researchers</dc:audience>
  s pole("audience",1)="Researchers"
]]></Implementation>
</Method>

<Method name="rightsDatabase">
<Description><![CDATA[
<pre> Metoda pro vyhodnoceni logicke baze podle zaznamu a uzivatele. Defaultne vsechno 
zakazane a budeme postupne povolovat podle pravidel
Parametry - aktualne zpracovavany handle

17.11.15 tt; zalozeno    
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Library.Binary]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
  s sDB="",pIdxUser=""

  s sT001=$$$HandleT001(handle)         ; ziskani t001
  s sClass=$$$HandleClass(handle)       ; ziskani tridy
  s sU99b=$$$getTagX(.handle,"U99b")                 ; spcecialni tag pridavany jen z formularu OHLASY v I3 formularich
  ; !!!doplnit ziskani uzivatele !!!
  if ($$$WeAreInCSPContext)
  {
    s secUser=##class(i2.ws.auth).getSessionUserName()
    s:(secUser'="") pIdxUser=##class(util.sec.security).securityGet(secUser,$$$secIsUser)
  }
  q:(pIdxUser="") sDB   ; pokud nemame login kontext - ukoncime  
  //s pIdxUser="cav_is_user*0000680"
  ; ziskani role podle uzivatele a zaznamu
 
  ; zjistime roli uzivatele na zaklade uzivatele a zaznamu
  s sRole=..GetRoleUser(pIdxUser, "", "", 0, .handle)
  
  ; zjistime prava uzivatele podle role na dany zaznam
  s sPrava=..GetAllOperation("", sRole, "", 0, .handle)
 
  ; nevim proc se pri kontrole prav vola zaznam nekolikrat a odmaze se i U99b. Proto si pro dany den
  ; poznamename, ze uzivatel muze pridavat ohlasy - plati to pro dany proces, takze snad bez nebezpeci    
  ; 27.11.15 tt; uprava vyhodnoceni prav kvuli I3web formularu  - OHLASY
  k ^$$$MarcTempG("CAVFORMI3_POMU99b",##class(User.Util).date($h-1))
  s:(sU99b) ^$$$MarcTempG("CAVFORMI3_POMU99b",##class(User.Util).date($h),$j,pIdxUser,sT001)=1
  if '(sU99b)
  {
    s sU99b=$g(^$$$MarcTempG("CAVFORMI3_POMU99b",##class(User.Util).date($h),$j,pIdxUser,sT001))
  }  
  
  if (sClass="CavUnEpca")
  { ; pro epca zaznamy  - CAV_UN_EPCA-d-BLw_CAV
    s sDB="CAV_UN_EPCA_NO"     ; defaultne vsechno zakazeme
    s:($f(sPrava,"w")) sDB="CAV_UN_EPCA_YES"  ; pokud ma uzivatel pravo zapisovat do databaze pripiseme
    s:($f(sPrava,"o")&&(sU99b="1")) sDB="CAV_UN_EPCA_YES"  ; pokud ma uzivatel pravo zapisovat do databaze pripiseme
    s:($$$HandleT001(handle)="new") sDB="CAV_UN_EPCA_YES" 
    s:($f(sRole,"s")) sDB="CAV_UN_EPCA_SUPER"   ; pro superuzivatele povolujeme vse
  }
  elseif (sClass="CavUnOhlCat")
  { ; pro ohlasy - CAV_UN_OHL_CAT-d-BLw_CAV
    s sDB="CAV_UN_OHL_CAT_NO"  ; defaultne vsechno zakazeme
    s:($f(sPrava,"w")) sDB="CAV_UN_OHL_CAT_YES"  ; pokud ma uzivatel pravo zapisovat do databaze pripiseme
    s:($$$HandleT001(handle)="new") sDB="CAV_UN_OHL_CAT_YES" 
    s:($f(sRole,"s")) sDB="CAV_UN_OHL_CAT_SUPER"   ; pro superuzivatele povolujeme vse
  }
  elseif (sClass="CavUnAuth")
  { ; pro autority  - CAV_UN_AUTH-a-Blr_Cav_Auth
    s sDB="CAV_UN_AUTH_NO"     ; defaultne vsechno zakazeme
    s:($f(sPrava,"w")) sDB="CAV_UN_AUTH_YES"  ; pokud ma uzivatel pravo zapisovat do databaze pripiseme
    s:($$$HandleT001(handle)="new") sDB="CAV_UN_AUTH_YES" 
    s:($f(sRole,"s")) sDB="CAV_UN_AUTH_SUPER"   ; pro superuzivatele povolujeme vse
  }  
  //s ^DK("TT",$zh,"stream")=sDB_"   "_pIdxUser_"   "_sT001
  q sDB
]]></Implementation>
</Method>

<Method name="GetAllOperation">
<Description><![CDATA[
<pre> Metoda ziskani moznych opetraci na zaklade role a zaznamu pro ruzne databaze
 Parametry: pIdxRecord - Idx zaznamu
            pRole      - seznam roli uzivatele z GetRoleUser
            pPar       - oddelene "-" zatim nepouzite
            pDeb       - moznos nastaveni debug modu - vypisy na standardni vystup
            handle     - zpracovavany handle misto pIdxRecord je tato moznost  
            

 Navratova hodnota  - radi se do retezce. Uzivetel tedy muze nabyvat vice moznych hodnot. Je potreba potom
                      pri zpracovani s tim pocitat!!!! Pokud je prazdne, zadna prava. Hodnoty:
                    "" - nema zadny vztah  - 0 (v CmSecurity n - nema prava)
                    w  - cteni a zapis
                    d  - delete
                    o  - pridavani ohlasu 
                    z  - zmena roku sberu (pridano 28.05.19)
                    k  - zmena druhu dokumentu (pridano 19.12.19)
                    c  - kopie datasetu
                    

01.12.22 tt; pridana funcnost vytvoreni kopie datasetu 
19.05.22 tt; pridáno mošnost pro super -k
19.12.19 tt; pridana zmena druhu dokumentu - k
09.11.15 tt; metoda zalozena kvuli rozsireni moznosti
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pIdxRecord="",pRole="",pPar="",pDeb=0,&handle]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s bRet="",sErr="",sPomUstavR="",sStateR=0
  w:(pDeb) !,"Zpracovani metodou GetAllOperation."
  
  if ($$$HandleT001(handle)'="")
  { ; pokud nam prijde handle, nemusime otevirat, ale  udelame jen Merge
    d ##class(User.MARC).mergeX(.handleR,.handle)
    s pIdxRecord="",sStateR=1
  }

  ; nacteme parametry
  s:(pIdxRecord'="") sErr=sErr_..GetRoleUserRec(.handleR, pIdxRecord, .sStateR)
  zt:(sErr'="") "ERROR-GetAllOperation:"_sErr ; poistka chybne volanie
  w:(pDeb&&sStateR) !,"Otevren zaznam databaze: "_pIdxRecord
   
  if (sStateR)
  { ; pokud existuje zaznam, pokusime se nacist
    s sClassR=$$$HandleClass(handleR)
    s sR970b=$$$getTagX(.handleR,"970b")
    s sRC99d=$$$getTagX(.handleR,"C99d")

    s:($f(pRole,"s")) bRet=bRet_"wdzk"  ; pro superuzivatele povolujeme vse

    if ('$f(pRole,"a"))
    { ; anonymni uzivatel muze jen zakladat, neupravovat
      
      if (sClassR="CavUnEpca")
      { ; pro epca zaznamy  - CAV_UN_EPCA-d-BLw_CAV
        ; sbornik 970b=BXXS nebo BXX
        ; periodiku 970b=BCA
        s sRC26=$$$getTagX(.handleR,"C26")
        s sRC26RIV=$$$getSubTagStr(sRC26,"b")              ; anonymni uzivatel
        s sRC26Rok=$$$getSubTagStr(sRC26,"d")              ; rok vykazovani
        s sR969f=$$$getTagX(.handle,"969f")
        s sC99d=$$$getTagX(.handle,"C99d")
        ; 14.03.17 tt; pridana logika pro datasety s U95a
        s sU95a=""        
        if ##class(User.MARC).readX(.hOld,"CavUnEpca",$$$HandleT001(handle))
        { ; handle - kontroluje se podle verze jiz ulozene v databazi, aby se podarilo ulozit zaznam
          s sU95a=$$$getTagX(.hOld,"U95a")                 ; priznak, ze u datasetu byl dan souhlas autorem+
        }
        //s sU99b=$$$getTagX(.handle,"U99b")                 ; spcecialni tag pridavany jen z formularu OHLASY v I3 formularich
        s sAktRokSb=##class(User.CavUnEpca).getAktRokZberu(.handle)
      
        s:(($f(pRole,"k"))&&((sR970b="BCA")||(sR970b="BXX"))) bRet=bRet_"w"
        s:((($f(pRole,"u")&&$f(pRole,"z"))||$f(pRole,"k"))&&(sR970b="BXXS")) bRet=bRet_"w"
        s:(($f(pRole,"h"))&&(sAktRokSb=sRC26Rok)&&((sR969f="N")||(sR969f="D"))&&(sU95a'=1)) bRet=bRet_"wd"
        if ($f(pRole,"c")&&($f(sC99d,"_EPCA_")))
        { ; pokud mame zpracovatele k zaznamu - zpracovatel daneho ustavu, muze
         // if (sRC26RIV=1)
          //{ ; zaznamy oznacene do RIV namuze mazat 
            s bRet=bRet_"wo" 
          // }
          //else 
          //{ ; jinak muze mazat jakekoli zaznamy
            ; zpracovatel muze mazat jakykoli zaznam v aktualnim roku sberu
            s:(sAktRokSb=sRC26Rok) bRet=bRet_"wdo"            
          //}     
          ; 04.05.19 tt; mazání: pokud je záznam neoznačen do RIV, tak zpracovatel jej může vždy smazat (nyní u záznamů jiného 
          ; než aktuálního roku sběru není tato možnost)  - ((sAktRokSb'=sRC26Rok)&& - zbytecna podminka    
          s:(sRC26RIV'=1) bRet=bRet_"wdo"    
          
          ; 28.05.19 tt; pridano pravo na zmenu roku sberu pro zpracovatele a superuzivatele
          ; 07.06.19 tt; odstranena podminka na rok sberu pri zmene roku sberu pro zpracovatele
          s:(('sRC26RIV)) bRet=bRet_"z"
          ; 31.07.19 tt; uprava podminky, aby bylo mozne zmenit i zaznamy do RIVu
          s:((sRC26Rok>=sAktRokSb)&&(sRC26RIV)) bRet=bRet_"z"
          
          ; 19.12.19 tt; pridana zmena druhu dokumentu
          s:(('sRC26RIV)) bRet=bRet_"k"
          s:((sRC26Rok>=sAktRokSb)&&(sRC26RIV)) bRet=bRet_"k"          
        }
        if ($f(pRole,"c")&&($f(sC99d,"DATA")))
        { ; pokud mame zpracovatele k zaznamu - zpracovatel daneho ustavu, muze
          s bRet=bRet_"wo" 
          ; zpracovatel muze mazat jakykoli zaznam v aktualnim roku sberu pokud neni vystaveny v ipacu
          if (((sR969f="N")||(sR969f="D"))&&(sU95a=1))
          { ; 14.03.17 tt; pridana logika pro datasety s U95a
            s:(sAktRokSb=sRC26Rok) bRet=bRet_"wdo" 
          }          
        }

        /// 01.12.22 tt; pridana funcnost vytvoreni kopie datasetu 
        /// pro autora, zpracovatele a super, pokud mame zaznam s posledni verzi, muzeme udelat kopii
        if (($f(pRole,"s")||$f(pRole,"h")||$f(pRole,"c"))&&($f(sC99d,"DATA"))&&(sR969f'="N")&&(sR969f'="D"))
        { ; pridana role pro kopie zaznamu
          s sKodVerze=##class(User.CavUnEpca).versionDataGetLastVersion(.handleR,"1")
          if (sKodVerze="")
          { // bud nam vrati posledni verze nase id, nebo nic, pokud verze nejsou
            s bRet=bRet_"c" 
          }
          elseif (($f(sKodVerze,$$$HandleT001(handleR))&&($p(sKodVerze,"#",1)'="")))
          { // bud nam vrati posledni verze nase id, nebo nic, pokud verze nejsou
            s bRet=bRet_"c" 
          }
        }
        
        ; vyhodnoceni pridavani ohlasu jen pro autora ve specialni formulari I3 - ohlasy
        s:($f(pRole,"b")) bRet=bRet_"o"
      }
      elseif (sClassR="CavUnOhlCat")
      { ; pro ohlasy - CAV_UN_OHL_CAT-d-BLw_CAV
        ; zatim nepovolim editaci zaznamu
        //s:($f($tr(pRole,"szcf","*"),"*")) bRet=bRet_"w"
        s:($f(pRole,"k")&&$f(pRole,"z")) bRet=bRet_"w"
        s:($f(pRole,"q")&&$f(pRole,"z")) bRet=bRet_"w"
        ; 25.02.20 tt; predalano pravo na editaci ohlasu na h - clovek, ktery zaznam vytvoril - 7 - upraveno k editaci KNAV-K -zpracovatel 
        s:($f(pRole,"h")) bRet=bRet_"w"   ; 16.06.20 tt; ohlas muze upravovat zpracovatel zaznamu, ktery jej vytvoril
      }
      elseif (sClassR="CavUnAuth")
      { ; pro autority  - CAV_UN_AUTH-a-Blr_Cav_Auth
        ; c99d =DFLT_UN_AUTH_200 - osobni jmeno
        ; c99d =DFLT_UN_AUTH_210_A - akce
        ; c99d =DFLT_UN_AUTH_210_W - pracoviste
        ; c99d =DFLT_UN_AUTH_210_I - instituce
        ; c99d =DFLT_UN_AUTH_230 - projekt
        ; zpracovatel muze editovat projekt, akci, instituci
        s:($f($tr(pRole,"szckf","*****"),"*")&&(
        (sRC99d="DFLT_UN_AUTH_230")||(sRC99d="DFLT_UN_AUTH_210_A")||(sRC99d="DFLT_UN_AUTH_210_I"))) bRet=bRet_"w"
        ; 31.01.18 tt; zakomentovano - prava autora a autority
        ; ten kdo zalozil muze autoritu autora - ustavu
        s:(($f(pRole,"h")&&$f(pRole,"z"))&&(
        (sRC99d="DFLT_UN_AUTH_200")||(sRC99d="DFLT_UN_AUTH_210_W"))) bRet=bRet_"w"
        
        if (($f(pRole,"c")||$f(pRole,"s"))&&(sRC99d="DFLT_UN_AUTH_200")) 
        { ; 02.01.24 tt; 2 - pokud mam zpracovatele, pridam priznak  - i k autorite - vymazeme - i super
          s:("n"=$zstrip(##class(User.MARC).getIdxValX(.handleR,"znnav"),"<>W")) bRet=bRet_"d"
        }
        ; pokud je toto moje osobni autorita
        s:(($f(pRole,"m"))&&(sRC99d="DFLT_UN_AUTH_200")) bRet=bRet_"w"
        ; pokud sedi zpracovatel s clovekem z ustavu, muze editovat autority a projekty
        s:(($f(pRole,"n"))&&($f(pRole,"z"))&&(
        (sRC99d="DFLT_UN_AUTH_200")||(sRC99d="DFLT_UN_AUTH_210_W"))) bRet=bRet_"w"
        ; 31.01.18 tt; pokud jsem zpracovatel a clovek z meho ustavu vytvoril nejakou autoritu, muzu editovat
        s:(($f(pRole,"o"))&&($f(pRole,"z"))&&(
        (sRC99d="DFLT_UN_AUTH_200")||(sRC99d="DFLT_UN_AUTH_210_W"))) bRet=bRet_"w"
      }
    } 
  }   
  w:(pDeb) !,"Konec zpracovani. Navrat: "_bRet
  q bRet                                  ; vratime vyslednou navratovou hodnotu
]]></Implementation>
</Method>

<Method name="GetRoleUser">
<Description><![CDATA[
<pre> Metoda ziskani informaci o typu uzivatele vuci zaznamu, vychazi ze FTgetIsUser, kterou uz nepouzivat
 Parametry: pIdxUser   - Idx uzivatele
            pIdxRecord - Idx zaznamu
            pPar      - oddelene "-" zatim nepouzite
            pDeb      - moznos nastaveni debug modu - vypisy na standardni vystup
            handle    - zpracovavany handle misto pIdxRecord je tato moznost  
         

 Navratova hodnota  - radi se do retezce. Uzivetel tedy muze nabyvat vice moznych hodnot. Je potreba potom
                      pri zpracovani s tim pocitat!!!! Hodnoty:
                    x - nema zadny vztah  - 0
                    b - jeden z autoru zaznamu, nebo clovek, ktery zaznam vytvoril - 1
                    c - zpracovatel k zaznamu - 2
                    d - clovek z ustavu zaznamu (ma stejny ustav) - 3
                    e - clovek ze spolupracujiciho ustavu - 4
                    f - zpracovatel ze spolupracujiciho zaznamu - 5
                    s - superuzivatel (muze byt i jen podle user) - 6 
                    h - clovek, ktery zaznam vytvoril - 7
                    a - anonymni uzivatel - pro parametr (jen podle User) - 8 
                    z - zpracovatel (jen podle User) - 9
                    m - pro CavUnAuth - autorita uzivatele
                    n - pro CavUnAuth - clovek z ustavu autority
                    o - pro CavUnAuth - zaznam vytvoreni nekym z ustavu, ve kterem jsem i ja
                    k nebo q - uzivatel (cavIsUser) je z KNAV-K
                    i - zobrazovat u uzivatele linky pro editaci a pripadne mazani I3 aplikaci 
                    u - uzivatel je z ustavu stejneho jako zaznam podle 999b

06.11.15 tt; metoda zalozena kvuli rozsireni moznosti
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pIdxUser="",pIdxRecord="",pPar="",pDeb=0,&handle]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s bRet="x",sErr="",sPomAuth="",sPomUstavR="",sStateU=0,sStateR=0,sUstavyIP=""
  
  if ($$$HandleT001(handle)'="")
  { ; pokud nam prijde handle, nemusime otevirat, ale  udelame jen Merge
    d ##class(User.MARC).mergeX(.handleR,.handle)
    s pIdxRecord="",sStateR=1
  }

  ; nacteme parametry
  //s sErr=..FTgetData(.handleU, pIdUser,.handleR,pIdRecord,.sState)  ; nacteme zaznamy
  s:(pIdxUser'="") sErr=..GetRoleUserRec(.handleU, pIdxUser, .sStateU)
  s:(pIdxRecord'="") sErr=sErr_..GetRoleUserRec(.handleR, pIdxRecord, .sStateR)
  zt:(sErr'="") "ERROR-GetRoleUser:"_sErr ; poistka chybne volanie
  w:(pDeb&&sStateU) !,"Otevren zaznam uzivatele: "_pIdxUser
  w:(pDeb&&sStateR) !,"Otevren zaznam databaze: "_pIdxRecord

  ; metoda, ktera vrati na zaklade IP adresy seznam ustavu, do ktereho clovek nalezi
  s:($$$WeAreInCSPContext) sUstavyIP=..FTgetIntranetUstav()
  w:(pDeb) !,"Ustavy podle IP adres: "_sUstavyIP
  
  s sU100="",sU100k="",sU100b="",sU600="",sU600a="",sU600b="",sU620a="",sU610b=""
  if (sStateU)
  { ; nejdriv vyhodnotime jen podle uzivatele    
    s sU100=$$$getTagX(.handleU,"100")               ; pole 100
    s sU100k=$$$getSubTagStr(sU100,"k")              ; anonymni uzivatel
    s sU100b=$$$getSubTagStr(sU100,"b")              ; anonymni uzivatel
    s sU600=$$$getTagX(.handleU,"600")               ; pole 600
    s sU600a=$$$getSubTagStr(sU600,"a")              ; link na nadrizenou jednotku
    s sU600b=$$$getSubTagStr(sU600,"b")              ; ustav uzivatele 
    s sU620a=$$$getTagX(.handleU,"620a")             ; link na autoritu
    s sU610b=$$$getTagX(.handleU,"610b")             ; priznak, ze se muze uzivatel hlasit pres ipac do formularu
    ; nacteme data z uzivatele
    s sU620=$$$getTagXC(.handleU,"620",-1)
    if (sU620'="")
    { ; pokud mame co zpracovavat, pokracujeme    
      f i=1:1:$l(sU620,$c(10)) 
      { ; cyklime pres vsechny opakovani 620
        s sU6201=$p(sU620,$c(10),i)
        ; seskladani vsech potencialnich linku na autoritu
        s sPomAuth=sPomAuth_$c(10)_$$$getSubTagStrC(sU6201,"a",-1)  ; ziskame vsechna podpole a      
      }   
    }  
    ; pridan priznak - zobrazovat u uzivatele linky pro editaci a pripadne mazani I3 aplikaci 
    s:(sU610b="SAFE") bRet=bRet_"i" 
    
    ;s:(sU600b="KNAV-K") bRet=bRet_"k"                           ; pridam priznak, ze uzivatel je z KNAV-K   
    s:(sU600b="KNAV-K") bRet=bRet_"q"                           ; pridam priznak, ze uzivatel je z KNAV-K  - jiny nez k kvuli omezeni vlastnosti 
    s:((sU600b'="") && (sU600a="")) bRet=bRet_"z"               ; je zpracovatel 
    s:(sU100k="2") bRet=bRet_"s"                                ; se superuzivatel

    ; 08.12.16 tt; upraveno porovnani anonymniho uzivatele - jsou vovoleny cisla, ktere se pri porovnani odfiltruji
    s sUT100btest=$tr(sU100b,"0123456789","")
    s:(($e(sUT100btest,($l(sUT100btest)-1),$l(sUT100btest))="-A") && (sU600a'="")) bRet=bRet_"a" ; osetreni pro anonymni uzivatele
    ; osetreni efektivity - pokud je superuzivatel, nema smysl dal zpracovavat
    w:(pDeb&&($f(bRet,"s"))) !,"Zpracovany data o uzivateli. Navrat : "_bRet
    q:($f(bRet,"s")) bRet                                       ; superuzivate vratime zrovna
    q:(sU100k=0) "x"                                            ; ukoncime, pokud neni uzivatel registrovany          
    w:(pDeb) !,"Zpracovany data o uzivateli. Navrat : "_bRet
  }  
  
  if (sStateR)
  { ; pokud existuje zaznam, pokusime se nacist
    s sClassR=$$$HandleClass(handleR)
    s sRT999e=$$$getTagX(.handleR,"999e")                ; ziskam si autora zaznamu
    s sRT999b=$$$getTagX(.handleR,"999b")                ; ustav zaznam
    ; autor zaznamu - zjisteni tvurce zazanmu
    s:(sRT999e=pIdxUser) bRet=bRet_"h"         ; 7 - pridame priznak ze clovek vytvoril zaznam
    ///       u - uzivatel je z ustavu stejneho jako zaznam podle 999b
    s:($zcvt(sRT999b,"L")=$zcvt($tr(sU600b,"-/*+?_",""),"L")) bRet=bRet_"u"    
     
    if (sClassR="CavUnEpca")
    { ; kontroly pro Epca tridu
      s sRTC26e=$$$getTagX(.handleR,"C26e")                ; ziskam pracoviste, ktere zaznam vykazuje
   
      s c=0
      d {
        s sTR7XX=$$$getTagXC(.handleR,"7**",.c) ; vsetky citacie
        continue:((sTR7XX="")&&(c'=0))
        if (sTR7XX'="")
        { ; pokud mame vyplnene data, muzeme provadet akce 
          s sTR7XXp=$$$getSubTagStr(sTR7XX,"p")         ; nacteme si ustav
          s sTR7XX3=$$$getSubTagStr(sTR7XX,"3")         ; nacteme link na autoritu
          s:(sTR7XXp'="") sPomUstavR=sPomUstavR_","_sTR7XXp
          s:(($f($c(10)_sPomAuth_$c(10),$c(10)_sTR7XX3_$c(10)))&&(sTR7XX3'="")) bRet=bRet_"b"
        }
        w:(pDeb) !,"Zpracovany autorske udaje. Navrat : "_bRet
      } while (c'=0)
    
      if (sUstavyIP'="")
      {
        for k=1:1:$l(sUstavyIP,",")
        {
          s sUstavyIP1=$p(sUstavyIP,",",k)
          continue:(sUstavyIP1="")               ; pokud nemame hodnotu, nemame co srovnavat 
          ; nastavime uzivatele na autora daneho ustavu
          s:($f(","_sPomUstavR_",",","_sUstavyIP1_",")) bRet=bRet_"e"         ; 4 - pokud mam cloveka ze spolupracujiciho ustavu
        }
        s:($f(","_sUstavyIP_",",sRTC26e)&&(sRTC26e'="")) bRet=bRet_"d"        ; 3 -  mam cloveka z ustavu
        w:(pDeb) !,"Zpracovany IP adresy. Navrat : "_bRet
      }
    
      // informace o cloveku ze spolupracujiciho ustavu /////////////////////////////
      s:($f(sPomUstavR,sU600b)&&(sU600b'="")) bRet=bRet_"e"                  ; 4 - pokud mam cloveka ze spolupracujiciho ustavu
      s:($f(sUstavyIP,sU600b)&&(sU600b'="")) bRet=bRet_"e"                   
      // informace o zpracovateli ze spolupracujiciho ustavu ////////////////////////
      s:(($f(sPomUstavR,sU600b))&&(sU600a="")&&(sU600b'="")) bRet=bRet_"f"   ; 5 - pokud mam zpracovatele, pridam priznak
      // informace o cloveku z ustavu ///////////////////////////////////////////////
      s:(sU600b=sRTC26e) bRet=bRet_"d"                                       ; 3 -  mam cloveka z ustavu
      // vyhodnotceni zpracovatele ///////////////////////////////////////////
      s:((sU600b=sRTC26e)&&(sU600a="")) bRet=bRet_"c"                        ; 2 - pokud mam zpracovatele, pridam priznak
    } ; konec zpracovani (sClassR="CavUnEpca")  
  
    if (sClassR="CavUnAuth")
    { ; kontroly pro auth tridu
      ///                     m - pro CavUnAuth - autorita
      s:($f($c(10)_sPomAuth_$c(10),"*"_$$$HandleT001(handle))) bRet=bRet_"m"
      s sRTC06d=$$$getTagX(.handleR,"C06d")                ; ziskam si ustav autora
      s:(sU600b=sRTC06d) bRet=bRet_"n"                                    ; mam cloveka z ustavu autority
      s sRT410a=$$$getTagXC(.handleR,"410a",-1)                           ; ziskam si ustav autority - pracoviste
      s:($f($c(10)_sRT410a_$c(10),$c(10)_sU600b_$c(10))) bRet=bRet_"n"    ; mam cloveka z ustavu autority

      ; zjistime si, jestli nejaky clovek z ustavu nam vytvarel nejakou autoritu
      s sRT999e=$$$getTagX(.handleR,"999e") 
      if ##class(User.MARC).readLX(.handleUSRA,sRT999e) 
      { 
        s sUSRAT600b=$$$getTagX(.handleUSRA,"600b") 
        ; pridan priznak, ze to vytvoril clovek z meho ustavu - kombinace se zpracovatelem 
        ; musi byt z jeho ustavu nebo pripadne byt bez pracoviste
        s:(sU600b=sUSRAT600b)&&((sU600b=sRTC06d)||(sRTC06d="")) bRet=bRet_"o"  

        if ((sU600b=sUSRAT600b)&&(sU600a="")) 
        {  ; 02.01.24 tt; 2 - pokud mam zpracovatele, pridam priznak  - i k autorite
           s bRet=bRet_"c"      
        }
      }
    }
  }    
  w:(pDeb) !,"Konec zpracovani. Navrat: "_bRet
  q bRet                                  ; vratime vyslednou navratovou hodnotu
]]></Implementation>
</Method>

<Method name="GetRoleUserRec">
<Description><![CDATA[
<pre> Metoda pro nacteni dat do handlu
 Parametry: Idx   - Id s lname (napr. "cav_is_user*0000016")
            pState    - stav otevirani zaznamu
                        0 - defaultni hodnota
                        1 - otevren zaznam

06.11.15 tt; metoda zalozena kvuli rozsireni moznosti
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle,Idx="",&pState]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s pState=0                ; nastavim defaultne na 0
  s sRet=""                 ; navratova hodnota
  if (Idx'="")
  { ; pokud mame id usera, nacteme informace
    if ('##class(MARC).readLX(.handle,Idx)) 
    { s sRet=sRet_"Error reading record for IDX="_Idx   }
    else
    { ; nastavime si priznak otevreni
      s pState=1             
    }
  }
  q sRet
]]></Implementation>
</Method>

<Method name="testGetRole">
<Description>
s sy="##class(User.Tmp1).tt(.handle)"   </Description>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 
  s pIdxUser="cav_is_user*0000016"
  //s pIdxRecord="cav_un_epca*0362688_2"
  s pIdxRecord="cav_un_auth*0313796"
  d ##class(MARC).readLX(.handle,pIdxRecord)
   //s pIdxRecord=""
  //d ##class(User.CavS).GetRoleUser(pIdxUser, pIdxRecord, "", 1, .handle)
    ; zjistime roli uzivatele na zaklade uzivatele a zaznamu
    
  s sRole=##class(User.CavS).GetRoleUser(pIdxUser, pIdxRecord, "", 1, .handle)
  
  ; zjistime prava uzivatele podle role na dany zaznam
  s sPrava=##class(User.CavS).GetAllOperation("", sRole, "", 1, .handle)
]]></Implementation>
</Method>

<Method name="ImpINCITES">
<Description>
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
 vystup pro INCITES - cs30452 - high

25.02.16 tt; zalozena metoda </Description>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 //d ##class(User.CavS).ImpINCITES()
 s file=##class(%FileCharacterStream).%New() ; otevreni vstupniho souboru
 s file.Filename="1autori-pro-export.txt"
 d file.TranslateTableSet("UTF8")  ; otevreni v UTF8
 ;d file.TranslateTableSet("CP1250")
 s sLine=file.ReadLine()           ; nacten prvni radek
 d ##class(User.Util).xlogf("CavINCITES.csv","Sysno autora;VlastníkZáznamu;RID;Jmeno_autora;Sysno_zaznamu;ZpZveřejnění;RokVydání;DOI;UT WOS;HANDLE")

 f
 { ; cyklus pres cely soubor
   s sLine=file.ReadLine()         ; cten 1 radek
   
   if (sLine'="")
   { ; pokud mame vyplneny radek, zpracovavame
     for i=1:1:$l(sLine,",")
     {
       s sT001A=$zstrip($p(sLine,",",i),"<>W")
       continue:(sT001A="")  ; pokud nemame data, nezpracovavame
       if ##class(User.MARC).readLX(.handleA,"cav_un_auth*"_sT001A)
       {
         w !,"Autorita: "_sT001A_"  -----------------------------------------------------"
         s catid=""
         f
         {
           s catid=##class(User.MARC).getIDByIndex("CavUnEpca","audk","cav_un_auth*"_sT001A,catid)
           q:(catid=0)
           s sT001C=##class(User.MARC).getT001(catid)
           w !,"       CavUnEpca*"_sT001C
           if ##class(User.MARC).readX(.handlec,"CavUnEpca",sT001C,"T")
           {
             d ..ImpINCITESLine(.handleA,.handlec)  
           }
           else
           {
              d ##class(User.Util).xlogf("CavINCITESErr.csv","--------------------------------------------------------------")
              d ##class(User.Util).xlogf("CavINCITESErr.csv","Nenacteno : "_"CavUnEpca*"_sT001C)

           }
         }    
        
       }
       else
       { ; chyba
         d ##class(User.Util).xlogf("CavINCITESErr.csv","--------------------------------------------------------------")
         d ##class(User.Util).xlogf("CavINCITESErr.csv","Nenacteno : "_"cav_un_auth*"_sT001A)
       }       
     }
   }   
   q:(file.AtEnd) ; pokud je konec souboru, ukoncime zpracovani
 }
 d file.%Close()                   ; zavreni souboru
]]></Implementation>
</Method>

<Method name="ImpINCITESLine">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handleA,&handleC]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
  s lnId=##class(User.MARC).recordIdX(.handleC)
  s sCT970b=$$$getTagX(.handleC,"970b") 
  q:((sCT970b'="J")&&(sCT970b'="JI")&&(sCT970b'="B")&&(sCT970b'="C")&&(sCT970b'="K")&&(sCT970b'="G")&&(sCT970b'="H")&&(sCT970b'="M"))
  
  s sCYEV=""
 // s sCYEV=$$$getTagX(.handleC,"210d") 
  //s:(sCYEV="") sCYEV=##class(User.MARC).getTagX(.handleC,"463/210d")
  ;2004-2016    
  s sCYEV=$zstrip($o(^ooDataTableI("CavUnEpca",lnId,"ye","")),"<>W")
  q:((sCYEV<2004)||(sCYEV>2016))
   
  ; 001;C06$d;C35$a;200$a,200$b; (AUTH)
  s sAT001=$$$HandleT001(handleA),sCT001=$$$HandleT001(handleC)
  s sATC06d=$$$getTagX(.handleA,"C06d") 
  
  s c=0,sATC35a=""
  d { 
    s sATC35=$$$getTagXC(.handleA,"035",.c) ; vsetky citacie
    continue:((sATC35="")&&(c'=0))
    if (sATC35'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      if (($$$getSubTagStr(sATC35,"2")="WOS"))
      {
        s sATC35a=$$$getSubTagStr(sATC35,"a")
      }
    }
  } while (c'=0)  
               
  //s sATC35a=$$$getTagX(.handleA,"035a") 
  s sAT200a=$$$getTagX(.handleA,"200a") 
  s sAT200b=$$$getTagX(.handleA,"200b") 
  
  ;Pracoviště C06$d     RID C35$a   Jmeno_autora 200$a, 200$b   
  ; Sysno_zaznamu (001)     
  ; ZpZveřejnění (970$b)    
  ; RokVydání 463$210$d(M, C, K), 463$v(J),210$d(B, G, H)   
  ; DOI (017$a$2=DOI)   
  s c=0,sDOI=""
  d { 
    s sT017=$$$getTagXC(.handleC,"017",.c) ; vsetky citacie
    continue:((sT017="")&&(c'=0))
    if (sT017'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      if (($$$getSubTagStr(sT017,"2")="DOI"))
      {
        s sDOI=$$$getSubTagStr(sT017,"a")
      }
    }
  } while (c'=0)  
   

  ; UT WOS (014$a $2=WOS)   
  s c=0,sWOS=""
  d { 
    s sT014=$$$getTagXC(.handleC,"014",.c) ; vsetky citacie
    continue:((sT014="")&&(c'=0))
    if (sT014'="")
    { ; pokud mame vyplnene data, muzeme provadet akce 
      if (($$$getSubTagStr(sT014,"2")="WOS"))
      {
        s sWOS=$$$getSubTagStr(sT014,"a")
      }
    }
  } while (c'=0)  
  s:(sWOS'="") sWOS="wos:"_sWOS
  
  ; HANDLE (C60$a)
  s sCTC60a=$$$getTagX(.handleC,"C60a") 
 
  // if T016
  s sCT16c=$$$getTagX(.handleC,"T16c") 
  s:((sCT970b="J")&&(sCT16c'="")) sCT970b="Ji"
   ; vypis do logu
  d ##class(User.Util).xlogf("CavINCITES.csv",sAT001_";"_sATC06d_";"_sATC35a_";"_sAT200a_", "_sAT200b_";"_sCT001_";"_sCT970b_";"_sCYEV_";"_sDOI_";"_sWOS_";"_sCTC60a)
]]></Implementation>
</Method>

<Method name="VysSpatneLinky">
<Description><![CDATA[
<pre> Metoda sloucici jako vstupni pro vystup problemovych zaznamu, ktere jsou ve 463 navazane na epca zaznam


Parametry
   pPar - parametry - oddelene carkou
          1. debag mod - jestli 1, vypisuji se pomocne texty - zatim nepouzity

16.12.16 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pEnvironment:%Binary,pPar:%String=""]]></FormalSpec>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
  s pP="",OFN="",pErr=""         ; pomocne promenne
  
  ; nacteni parametru, obecna metoda
  d ##class(User.CavS).repParO(.pP,pPar)                          
  ; vystupni soubor bude lehce oteviratelny v excelu
  s pP("Cesta")=##class(User.Util).strswap(pP("Cesta"),".htm","_2.txt")
  ; otevreni soubor  
  s pErr=pErr_##class(util.ie.CheckBase).repSoub(.pP,.OFN,1)    
  ; volani metody zpracovavajici vystup
  d ..VysSpatneLinkyN(.pP,.OFN)
  ; uzavreni souboru
  d ##class(util.ie.CheckBase).repSoub(.stPref,.OFN,0)     
  q ""                 ; konec
]]></Implementation>
</Method>

<Method name="VysSpatneLinkyN">
<Description><![CDATA[
<pre>
16.12.16 tt; zalozena metoda
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pP,&OFN]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 
 d OFN.WriteLine("Kontrolní výstup pro špatně navázané záznamy EPCA")     
 d OFN.WriteLine(" ")     
 d OFN.WriteLine(" ")     
    
 s id="", idx="", point=0, brk=0
 for  
 { ; cyklus pro prochazeni vyselektovanych zaznamu
    s idx=$o(^$$$ListsG($$$ListsActiveSel,$j,idx)),id=idx
    if $f(id,"*") s id=$p(id,"*",2)   ; odstranit triediaci prefix/sufix
    q:((id="") || brk)                ; ukoncime, jestli narazime na konec nebo chybu
      
    s sClass=##class(User.MARC).getCLASS(id)    ; ziskame aktualni tridu 
    s sT001=##class(User.MARC).getT001(id)      ; ziskame akualni id zaznamu
       
    if (##class(MARC).readX(.handle,sClass,sT001,"T")) 
    { 
      s sLX463=$$$getTagX(.handle,"463")
      s sLX463001=$$$getTagX(.handle,"463/001")
      if (sLX463001'="")
      { ; pokud ma clanek zdrojovy dokument
        if ##class(User.MARC).readLX(.handle4,sLX463001,"T")
        { ; nacteme 
          s C99d=$$$getTagX(.handle4,"C99d")          
          if ($f(C99d,"DFLT_CZ_EPCA"))
          {
            d OFN.WriteLine("--------------------------------------------------------------------") 
            d OFN.WriteLine(sT001_"   ("_sClass_")" )     
            d OFN.WriteLine(sLX463 )  
          }                 
        }
      }
    }
  }
]]></Implementation>
</Method>

<Method name="repPrehledZaz">
<Description><![CDATA[
<pre> Vystup pro upravy zaznamu pres klienta
parametry: pEnvironment  - prostredi
           pTyp          - typ informaci co zobrazujeme - C83 - zmenove soubory
                                                          C51 - mazaci soubory
                                                          969 - pridane soubory 
                     
           pPar          - dalsi mozne parametry


26.07.17 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pEnvironment:%Binary,pTyp="",pPar=""]]></FormalSpec>
<PublicList>sRetMsg</PublicList>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 s sPar="",sErr=""                             ; nadefinovani souboru
 s sPar("Par","Typ")=pTyp                      ; zjistime si typ spusteni vystupu
 s sPar("Par","Par")=pPar                      ; obecne parametry 
 
 d ##class(rep.html.base).repPar(.sPar,.pEnvironment)        ;nacteni parametru 
 s bUserIsAdmin=##class(User.CavUnEpca).userIsAdmin()        ; zjisteni, jesti ma uzivatel pravo delat vystup 
 
 if 'bUserIsAdmin
 { ; overeni, zda ma prihlaseny uzivatel pravo spoustet vystupy
   s sRetMsg=sRetMsg_"<br>"_$$$CRLF_"ERROR: Spuštění výstupu je dovoleno pouze administrátorovi systému<br>"_$$$CRLF
   q ""
 }

 s sPrip = "_2.txt",sKodovani="UTF8"     ; zmena typu vystupu podle predaneho parametru 
 if (sPar("SelKr",".PAR1")="V") { s sPrip = "_2.csv",sKodovani="CP1250"  }
 d ##class(rep.html.base).repSoubOC(.sRetMsg,sPar("Path"),.OFN,1,sPrip,sKodovani)   ; otevreni souboru
 d ..repPrehledZazAllR(.sPar,.OFN)                                        ; vlastni vypis a zmena dat
 
 d ##class(rep.html.base).repSoubOC(.sRetMsg,sPar("Path"),.OFN,0,sPrip)   ; zavreni souboru  
 d SetPDefIO^%NLS("UTF8",3)
 q ""                   ; musime vratit nejakou navratovou hotnotu
]]></Implementation>
</Method>

<Method name="repPrehledZazAllR">
<Description><![CDATA[
<pre> Hlavni metoda pro provedeni zmen a vypisu informaci nad jednotlivymi zaznamy.
parametry:  pPar  - globalni parametry
            OFN   - soubor 
 
27.07.17 tt; metoda zalozena
</pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pPar:%Binary,&OFN:%Binary]]></FormalSpec>
<Implementation><![CDATA[
  s idx="",id="", pErr=""    ; definice pomocnych promennych
  
  ; ruzne hlavicky pro ruzny typy vystupu
  d ..repPrehledZazVyp(.pPar, .OFN,"1") 
  
  f  
  { ; cyklus pro prochazeni vyselektovanych zaznamu
    s idx=$o(^$$$ListsG($$$ListsActiveSel,$j,idx)),id=idx
    if $f(id,"*") s id=$p(id,"*",2)      ; odstranit triediaci prefix/sufix
    q:(id="")                            ; ukoncime, jestli narazime na konec 
    
    k pP("Rec")                          ; promazeme docasne data z kaznamu     
    s del969=0                          
    if ('##class(User.MARC).getDATAX(.handle,id))
    { ; pokud se nam nepodarilo nacist data
      d OFN.WriteLine("Nebylo možné otevřít záznam s id:"_id)
    }
    else
    { ; mame nacteny handle, muzeme zacit zpracovavat zaznam po zaznamu
      s pPar("Rec","001")=$$$HandleT001(handle)            ; ziskani t001
      s pPar("Rec","C26e")=$$$getTagX(.handle,"C26e")   
      d ..repPrehledZazVyp(.pPar, .OFN,"4") 
         
      s nC=##class(User.MARC).recordLineCountX(.handle) ; ziskani poctu radku v zaznamu 
      f i=1:1:nC 
      { ; pres vsechny radky zaznamu pujdeme po jednom radku a budeme nahrazovat
        s lsLine=##class(User.MARC).getLineX(.handle,i) continue:lsLine="" 
        s sTag=$e(lsLine,1,3), sOldLine=lsLine
        
        if (pPar("SelKr","tag")=sTag)
        { ; pokud mame shodu tagu, nacitame informace
          s pPar("Rec","STa")=$$$getSubTagStr(lsLine,"a"), pPar("Rec","STb")=$$$getSubTagStr(lsLine,"b")         
          s pPar("Rec","STc")=$$$getSubTagStr(lsLine,"c"), pPar("Rec","STd")=$$$getSubTagStr(lsLine,"d")    
          s pPar("Rec","STe")=$$$getSubTagStr(lsLine,"e"), pPar("Rec","STf")=$$$getSubTagStr(lsLine,"f") 
          s pPar("Rec","STg")=$$$getSubTagStr(lsLine,"g")
          d ..repPrehledZazVyp(.pPar, .OFN,"2") 
          
          if ((pPar("SelKr",".PAR1")="W")||(pPar("SelKr",".PAR1")="T"))
          {
            if ((pPar("SelKr","tag")="C83")||(pPar("SelKr","tag")="C51")||(pPar("SelKr","tag")="969"))
            {
              s lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"f")
              ; vypis zmen
              d ..repPrehledZazVyp(.pPar, .OFN,"3",sOldLine,lsLine) 
      
              if ((pPar("SelKr","tag")="969")&&((lsLine="")))
              { ; dame si priznak, ze mame odmazat 969
                s lsLine=sOldLine
                s del969=1 
              }
            }            
          }
        }    
        d:(sOldLine'=lsLine) ##class(User.MARC).setLineX(.handle,i,lsLine) ; zapsani to radku
      }
      d ##class(User.MARC).recordDelEmptyST(.handle)    ; odmazani prazdnych subtagu
      d:(del969=1) $$$delTagX(.handle,"969") 
      
      if (pPar("SelKr",".PAR1")="W")
      { ; ulozime zmeneny handle
        s sc=##class(User.MARC).writeX(.handle,1,1,0,2_$c(10)_pPar("user_name")_$c(10)_$p(pPar("user_ip")," ##",1))
        if ('$$$ISOK(sc))
        { ; vypiseme si chybu
          s pErr=pErr_##class(User.ReportCommon).swapRetMsg1("ERRW001#"_pPar("Rec","001"))_"|"        
          s pErr=pErr_$p(sc,"|",2)_"|" 
          d OFN.WriteLine(pErr)
        }
      }
  } 
  //d OFN.WriteLine("</body>") ; konec html
}
]]></Implementation>
</Method>

<Method name="repPrehledZazVyp">
<Description><![CDATA[
<pre> Hlavni metoda pro provedeni zmen a vypisu informaci nad jednotlivymi zaznamy.
parametry:  pPar  - globalni parametry
            OFN   - soubor 
            pTyp  - typ vypisu
                    1 - zacatek souboru 
                    2 - vypis jednotlivych radku
                    3 - vyspi zmen
                    4 - zacatek zaznamu
            sOldLine - puvodni radek
            lsLine   - novy upraveny radek
 
27.07.17 tt; metoda zalozena
</pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pPar:%Binary,&OFN:%Binary,pTyp,sOldLine="",lsLine=""]]></FormalSpec>
<Implementation><![CDATA[
  if (pPar("SelKr",".PAR1")="V")
  { ; pokud mame vypis informaci, vlozime hlavicku csv
    if (pTyp=1)
    {
       d:(pPar("SelKr","tag")="C83") OFN.WriteLine("ustav;sysno;C83a;C83d;C83f;posk")
       d:(pPar("SelKr","tag")="C51") OFN.WriteLine("ustav;sysno;C51a;C51b;C51c;C51d;C51g;C51f;posk")
       d:(pPar("SelKr","tag")="969") OFN.WriteLine("ustav;sysno;969f")
    }
    if (pTyp=2)
    { ; vypis informaci do csv
      if (pPar("SelKr","tag")="C83")
      {
        s sPosk=$p(pPar("Rec","STa"),"/",5)
        s:(sPosk="") sPosk=$p(pPar("Rec","STa"),"-",2)
        d OFN.WriteLine(pPar("Rec","C26e")_";"_pPar("Rec","001")_";"_pPar("Rec","STa")_";"_pPar("Rec","STd")
                                      _";"_pPar("Rec","STf")_";"_sPosk)
      }
      if (pPar("SelKr","tag")="C51")
      {
        s sPosk=$p(pPar("Rec","STa"),"/",5)
        s:(sPosk="") sPosk=$p(pPar("Rec","STa"),"-",2)
        d OFN.WriteLine(pPar("Rec","C26e")_";"_pPar("Rec","001")_";"_pPar("Rec","STa")_";"_pPar("Rec","STb")_";"_$tr(pPar("Rec","STc"),";",",")
                                      _";"_pPar("Rec","STd")_";"_pPar("Rec","STg")_";"_pPar("Rec","STf")_";"_sPosk)
      }
      if (pPar("SelKr","tag")="969")
      {
        s sPosk=$p(pPar("Rec","STa"),"/",5)
        s:(sPosk="") sPosk=$p(pPar("Rec","STa"),"-",2)
        d OFN.WriteLine(pPar("Rec","C26e")_";"_pPar("Rec","001")_";"_pPar("Rec","STf"))
      }
    }
  }
  else
  {
    if (pTyp=1)
    {
       d OFN.WriteLine("")
       d:(pPar("SelKr","tag")="C83") OFN.WriteLine("   Hromadná deaktivace C83  ")
       d:(pPar("SelKr","tag")="C51") OFN.WriteLine("   Hromadná deaktivace C51  ")
       d:(pPar("SelKr","tag")="969") OFN.WriteLine("   Hromadná deaktivace 969f  ")
       d OFN.WriteLine("")
    }
    if (pTyp=4)
    {
       d OFN.WriteLine("")
       d OFN.WriteLine(" -------------------------------------------------------------------------- ")
       d OFN.WriteLine(" T001 = "_pPar("Rec","001"))
       d OFN.WriteLine("")
    }
    if (pTyp=3)
    {
       d OFN.WriteLine("")
       d OFN.WriteLine(" Původní řádek: "_sOldLine)
       d OFN.WriteLine(" Nový řádek:    "_lsLine)
       d OFN.WriteLine("")
    }
  }
]]></Implementation>
</Method>

<Method name="CitaceXml">
<Description>
Metoda pro filtrovani zaznamu pro citace v katalogu
Dokumentace: https://cosmo2/wiki/index.php/Citace_v_katalogu,_CitacePro

28.11.17 tt; pridana metoda pro export citaci v katalogu</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Library.Binary,pPonTag=""]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
   s dk="BK"

   ////////////////////////////////////////////////////
   s sRecKind=##class(i2.data.layer).kind(.handle)
   /// "book"         knihy
   ///  "music"        hudebniny (noty) 
   ///  "cartography"  kartografie (mapy)
   ///  "video"        video
   ///  "picture"      obrazky
   ///  "3d"           objekt
   ///  "sound"        zvukove dokumenty
   ///  "article"      clanky
   ///  "file"         pocitacovy soubor
   ///  "journal"      casopis

   s:(sRecKind="file") dk="AM"
   s:(sRecKind="book") dk="BK"
   s:(sRecKind="cartography") dk="MP"
   s:(sRecKind="article") dk="AN"
   s:(sRecKind="journal") dk="SE"
   //   BK, MU = Monografie
   //   ER = Elektronické periodikum
   //   DS, DP, BP, H, D, KP  = Akademická práce
   //   MP = Mapa
   //   AM, CF = El. médium
   //   SE = Periodikum
   //   MX = Smíšené dokumenty
   //   AN, RS, RM, RD = Článek nebo příspěvek ve sborníku (nutno rozlišit např. parametrem 773)
  
   s sClass=$$$HandleClass(handle)
   s idc=##class(User.MARC).recordIdX(.handle)       ; ziskani id
   s dokx="",dok=""
   
   for  
   { ; nalezeni vsech druhu dokumentu
     set dokx=$o(^$$$MarcIndexG(sClass,idc,"dk",dokx)) 
     q:(dokx="")
     s dok=dok_" "_dokx_" "
   }
  
    //   DS, DP, BP, H, D, KP  = Akademická práce
   ; média
   s:($f(dok," jxx ")) dk="AM"       ;  jxx - audioviz. a zvuk. dokumenty
   s:($f(dok," xelz ")) dk="AM"      ; xelz - elektronické zdroje 

   s:($f(dok," aat ")) dk="MP" ; aat - atlasy (nie geografické)
  
   ; diplomove prace
   s:($f(dok," dxx ")) dk="DP"   ; dxx - dedecké a vysokoškolské kvalifikačné práce
   s:($f(dok," ddz ")) dk="DS"   ; ddz - dizertačné práce doktorské (drsc.)
   s:($f(dok," dzb ")) dk="BP"   ; dzb - záverečné bakalárske práce
   s:($f(dok," dapz ")) dk="DP"  ; dapz - záverečné práce
   s:($f(dok," ddp ")) dk="DP"   ; ddp - diplomové práce
   s:($f(dok," dpg ")) dk="DS"   ; dpg - dizertačné práce doktorandské (phd./dr.)
   s:($f(dok," dkz ")) dk="DS"   ; dkz - dizertačné práce kandidátske (csc.)
   s:($f(dok," dhp ")) dk="H"    ; dhp - habilitačné práce
     
     
   s:($f(dok," aen ")) dk="MX"    ; aen -encyklopédie 
   s:($f(dok," aen ")) dk="MX"    ; aro - ročenky                     
    
   s:($f(dok," xcla ")) dk="AN"      
 
    /* 
       xszp - časopisy
       rbx - články z periodík
       rzb - články zo zborníko       
       fxx - firemná literatúra
       cxx - kartografické dokumenty
       amg - monografie
       app - príručky       
       ask - skriptá
       asl - slovníky
       xavs - správy výskumné
       atb - tabuľky
       auc - učebnice
       izxx - zákony / zákoníky
       azb - zbierky
       azn - zborníky
  */
  
  ; 23.01.18 tt; provedena uprava pro druh dokumentu C pro FMT
  s s970b=$$$getTagX(.handle,"970b")     ; zjisteni 970b
  s:(s970b="C") dk="PC"      
  
  d ##class(User.MARC).delTagX(.handle,"T**")            ; odmazani vsech Txx tagu
  d ##class(User.MARC).delTagX(.handle,"U**")            ; odmazani vsech Uxx tagu
  d ##class(User.MARC).delTagX(.handle,"C**")            ; odmazani vsech Cxx tagu
  d ##class(User.MARC).delTagX(.handle,"852")
  d ##class(User.MARC).delTagX(.handle,"928")
  d ##class(User.MARC).delTagX(.handle,"969")
  d ##class(User.MARC).delTagX(.handle,"999")            ; odmazani 999
  d ##class(User.MARC).recordDelEmptyST(.handle)    ; odmazani prazdnych subtagu
  s sAllEdi=""
  s s463=##class(MARC).getTagX(.handle,"463")
  if (s463'="")
  {
    if ##class(MARC).t4xx2handle(.handle4,s463)
    {
      s sAllEdi=$$$getTagXC(.handle4,"702",-1)  
      s:(sAllEdi'="") sAllEdi=$$$strswap(sAllEdi,"702  1 ","EDI  1 ")
    }
  } 
    
    

  

  d ##class(util.conv.UnToM21).UnToM21Hanlde(.handle,"CITACE_CONV_UN_TO_M21",($$$strswap(sClass,"Un","Us")_",,0"),2)
 
  //s dk="BK"
  d $$$setTagX(.handle,"FMT    "_dk)
  d $$$setTagX(.handle,"FMC    "_s970b)
  d:(sAllEdi'="") $$$setTagX(.handle,sAllEdi)
 q
]]></Implementation>
</Method>

<Method name="ZakUpravaDatC">
<Description><![CDATA[
<pre> Metoda pro zakaznickou upravu dat - postupne se bude doplnovat
 pnTyp - 0 - nedefinovano, nedelam nic
         1 - uprava na zacatku
         2 - uprava na konci

28.11.17 tt; pridana metoda pro export citaci v katalogu
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pnTyp=0</FormalSpec>
<PublicList>hanldeM21,hanldeUN,pPar,gsErr</PublicList>
<Implementation><![CDATA[
 if (pnTyp=1)
 {
  
 }
 if (pnTyp=2)
 {    
 } ; konec typu 2
]]></Implementation>
</Method>

<Method name="symExpKosik">
<Description><![CDATA[
<pre> Medota pro upravu handlu pri exportu z kosiku pro UNXML

Parametry: handle   - aktualni zpracovavany handle
26.02.19 tt; metoda zalozena                          
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Library.Binary]]></FormalSpec>
<Implementation><![CDATA[
 s c = ##class(User.MARC).recordLineCountX(.handle)
 s class=$$$HandleClass(handle)
 
 f i=1:1:c
 { ; pres vsechny radky zaznamu musime projit
   s lsLine = ##class(User.MARC).getLineX(.handle,i) continue:(lsLine = "") ; ziskame jeden radek
   s lsTag = $e(lsLine,1,3), lsLineO=lsLine          ; ziskame prefix tagu a udelame kopii radku
     
   if ((lsTag = "C06") || (class = "CavUnAuth"))   
   { ; v autoritach odstranime rodne cislo C06e  
     s lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"e")
   } 
   
   if (($e(lsTag,1) = "7") || (class = "CavUnEpca"))   
   {
     s sT70X3=$$$getSubTagStr(lsLine,"3") ; zjistime kod autority
     if (sT70X3'="")
     { ; pokud jsme ziskali kod autority
       if ##class(User.MARC).readLX(.handlea3,sT70X3)
       { ; pokud se nam podarilo autoritu otevrit
         s sA035x=$$$getTagXC(.handlea3,"035",-1)
         f k=1:1:$l(sA035x,$c(10))                  ; cyklus pres vsechny opakovani
         { ; pres vsechny opakovani 
           s sA035x1=$p(sA035x,$c(10),k)            ; vezmeme jedno opakovani  
           s sA035x1a=$$$getSubTagStr(sA035x1,"a")  ; ziskame kod
           s sA035x12=$$$getSubTagStr(sA035x1,"2")  ; ziskame kod           
           if sA035x12="WOS" { s lsLine=lsLine_$c(31)_"A"_sA035x1a }
           elseif sA035x12="ORCID" { s lsLine=lsLine_$c(31)_"B"_sA035x1a }          
           elseif sA035x12="SCOPUS" { s lsLine=lsLine_$c(31)_"C"_sA035x1a }
           elseif sA035x12="RIVID"{ s lsLine=lsLine_$c(31)_"D"_sA035x1a }
           elseif sA035x12="GOOGLEID" { s lsLine=lsLine_$c(31)_"E"_sA035x1a }          
         }
       }
     }  
   }   
   
   d:(lsLine '= lsLineO) ##class(User.MARC).setLineX(.handle,i,lsLine)    ; pokud doslo ke zmene, zapis.  
  }
  
  d ##class(User.MARC).recordDelEmptyST(.handle)    ; odmazani prazdnych subtagu
]]></Implementation>
</Method>

<Method name="VymazNenavAutorit">
<Description><![CDATA[
<pre> Zalozena metoda pro nalezeni autorit, ktere nejsou navazane na zadny zaznam a jejich vymaz. Metoda bude 
pravidelne spoustene v planovanych ulohach
Volano z planovanych uloh zback
Parametry - oddelene "-"
          - TEST - pouze testovaci spusteni  

Zadání: 1x měsíčně mazat autority, které nemají navázaný záznam.
        Ponechat autority autorů – s vyplněným C06d.
        Ponechat autority projektů, kde je vyplněn název 230a.

Navrat:
"1" ok, "0" chyba

d ##class(User.CavS).VymazNenavAutorit("TEST")
17.04.19 tt; zalozena metoda
<pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>params=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 s ret=1
 
 ; udelame selekt podle indexu znnav
 d ##class(User.Util).XselIndex("CavUnAuth znnav = n")  ; vyselektujeme nenavazane zaznamy
 
 s idx="",id="" 
 f  
 { ; cyklus pro prochazeni vyselektovanych zaznamu
   s idx=$o(^$$$ListsG($$$ListsActiveSel,$j,idx)),id=idx 
   q:(id="")                                            ; pokud nemame id, koncime
     
   ;Zpracovavani jednoho zaznamu
   if '##class(User.MARC).getDATAX(.handle,id,"T") s err="error: VymazNenavAutorit - record id:"_id_" not found!" w !,err continue   
   s sT001=$$$HandleT001(handle)                           ; ziskani t001
   s lsClass=$$$HandleClass(handle)

   ; vyhodnotime si podminky navazanosti a pro splneni podminek danych pro vyhodnoceni
   s sTC06d=$$$getTagX(.handle,"C06d")
   s sT230a=$$$getTagX(.handle,"230a")
   s sT200=$$$getTagX(.handle,"200")
   s sTC31=$$$getTagX(.handle,"C31")
   s sTC99d=$$$getTagX(.handle,"C99d")
    
   ; 09.07.20 tt; upraveny podminky pro vymaz autorit 
   continue:((sTC06d'="")&&(sT200'=""))      ///         Ponechat autority autorů – s vyplněným C06d.
   /// projekty smazat pokud nemaji vyplneny nazev (230a) a ustav (C31) nebo jen ustav (C31).
   continue:((sT230a'="")&&(sTC31'=""))      ///         Ponechat autority projektů, kde je vyplněn název 230a.
   continue:(($f(sTC99d,"230"))&&(sTC31'=""))
   continue:(($f(sTC99d,"210"))&&(sTC99d'="DFLT_UN_AUTH_210_A"))
    
   s sT001=$$$HandleT001(handle)
   s sLName=##class(User.Util).objectName2lname(lsClass)
   ; overime radeji auk indexy - pro jistotu, kdyby vznikl problem se spozdenou indexaci navazanych zanzmu
   s idNal="",bFing=0 
   
   for i=1:1:3
   { ; cyklus pres mozne navaznosti
     s sProhlTrida=$s(i=1:"CavUnAuth",i=2:"CavUnEpca",i=3:"CavUnOhlCat",1:"")
     f
     { ; jestli ja autorita navazana, mela by byt v auk
       s idNal=##class(User.MARC).getIDByIndex(sProhlTrida,"auk"," "_sLName_"*"_sT001,idNal)
       q:((idNal=0)||(bFing=1))
       s bFing=1
     }
     q:(bFing=1)
   }
   ; kontrola na moznost mazani - zaznam neobsahuje T04
   continue:(##class(User.SPIntegrit).allowDeleteAuthT04(id)'="")
   
   ; jen pro kontrolu vypis - jak zareaguje cele allowDelete
   continue:(##class(User.SPIntegrit).allowDeleteAuth(id)'="")
   
   continue:(bFing=1)                 ; pokud mame nalezenou hodnotu, pokracujeme
   w !,"----------------------------------------------------------------------------------"
   w !,"Výmaz záznamu "_lsClass_"*"_sT001_"."
   ; 26.04.19 tt; pridany rozsirene informace o zaznamech
   s sT2xx=$$$getTagX(.handle,"2**")
   w !," "_$$$strswap(sT2xx,$c(31),"$$")
   s sTC06=$$$getTagX(.handle,"C06")
   w !," "_$$$strswap(sTC06,$c(31),"$$")
   
   if '$f(params,"TEST")
   {
     s sc=##class(User.MARC).delete(lsClass,sT001,0,3)
     if '$$$ISOK(sc) 
     {
       s ret="ERRDEL001#"_lsClass_"/"_sT001_"#"_##class(Util).status2str(sc)
       w !,"Error: při výmazu záznamu došlo k chybě - "_lsClass_"/"_sT001_" - "_ret
       s ret=0
       continue
     }
     else { w !,"Úspěšně vymazán záznam: "_lsClass_"*"_sT001_"."}
   } 
   else
   {
       w !,"Pouze testovací spuštění. Záznam nevymazán."
   }
 } 
 
 d ##class(User.CavS).VymazNenavCatAutorit()

 q ret
]]></Implementation>
</Method>

<Method name="VymazNenavCatAutorit">
<Description><![CDATA[
<pre> Zalozena metoda pro nalezeni autorit, ktere nejsou navazane na zadny zaznam a jejich vymaz. Metoda bude 
pravidelne spoustene v planovanych ulohach
Volano z planovanych uloh zback
Parametry - oddelene "-"
          - TEST - pouze testovaci spusteni  

Zadání: 1x měsíčně mazat autority, které nemají navázaný záznam.
        Ponechat autority autorů – s vyplněným C06d.
        Ponechat autority projektů, kde je vyplněn název 230a.

Navrat:
"1" ok, "0" chyba

d ##class(User.CavS).VymazNenavCatAutorit("TEST")
17.04.19 tt; zalozena metoda
<pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>params=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 s ret=1
 
 ; udelame selekt podle indexu znnav
 d ##class(User.Util).XselIndex("CavUnEpca znnav = n")  ; vyselektujeme nenavazane zaznamy
 d ##class(User.Util).Xselect("&&CavUnEpca !dk = bxxs")
 
 s idx="",id="" 
 f  
 { ; cyklus pro prochazeni vyselektovanych zaznamu
   s idx=$o(^$$$ListsG($$$ListsActiveSel,$j,idx)),id=idx 
   q:(id="")                                            ; pokud nemame id, koncime
     
   ;Zpracovavani jednoho zaznamu
   if '##class(User.MARC).getDATAX(.handle,id,"T") s err="error: VymazNenavCatAutorit - record id:"_id_" not found!" w !,err continue   
   s sT001=$$$HandleT001(handle)                           ; ziskani t001
   s lsClass=$$$HandleClass(handle)

   ; vyhodnotime si podminky navazanosti a pro splneni podminek danych pro vyhodnoceni
   s sTC99d=$$$getTagX(.handle,"C99d")
   s sRok=(##class(User.CavUnEpca).getAktRokZberu(.handle)-1)
   s sTRok210d=$$$getTagX(.handle,"210d") 
   
   ; 09.07.20 tt; upraveny podminky pro vymaz autorit 
   continue:(sTC99d'="DFLT_CAT_BXXS")
   continue:((sTRok210d'="")&&('(sTRok210d<sRok)))

   s sT001=$$$HandleT001(handle)
   s sLName=##class(User.Util).objectName2lname(lsClass)
   ; overime radeji auk indexy - pro jistotu, kdyby vznikl problem se spozdenou indexaci navazanych zanzmu
   s idNal="",bFing=0 
   
   for i=1:1:3
   { ; cyklus pres mozne navaznosti
     s sProhlTrida=$s(i=1:"CavUnAuth",i=2:"CavUnEpca",i=3:"CavUnOhlCat",1:"")
     s idNal="" ; 02.01.24 tt; drobna uprava podminky pro hledani navaznosti
     f
     { ; jestli ja autorita navazana, mela by byt v auk
       s idNal=##class(User.MARC).getIDByIndex(sProhlTrida,"auk"," "_sLName_"*"_sT001,idNal)
       q:((idNal=0)||(bFing=1))
       s bFing=1
     }
     q:(bFing=1)
   }
   
   continue:(bFing=1)                 ; pokud mame nalezenou hodnotu, pokracujeme
 
   ; jen pro kontrolu vypis - jak zareaguje cele allowDelete
   continue:(##class(User.SPIntegrit).allowDeleteCat(id)'="")
   
   w !,"----------------------------------------------------------------------------------"
   w !,"Výmaz záznamu "_lsClass_"*"_sT001_"."

   s sT2xx=$$$getTagX(.handle,"2**")
   w !," "_$$$strswap(sT2xx,$c(31),"$$")
   w !," "_$$$strswap(sTRok210d,$c(31),"$$")

   if '$f(params,"TEST")
   {
     s sc=##class(User.MARC).delete(lsClass,sT001,0,3)
     if '$$$ISOK(sc) 
     {
       s ret="ERRDEL001#"_lsClass_"/"_sT001_"#"_##class(Util).status2str(sc)
       w !,"Error: při výmazu záznamu došlo k chybě - "_lsClass_"/"_sT001_" - "_ret
       s ret=0
       continue
     }
     else { w !,"Úspěšně vymazán záznam: "_lsClass_"*"_sT001_"."}
   } 
   else
   {
       w !,"Pouze testovací spuštění. Záznam nevymazán."
   }
 } 
 q ret
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
•   Připravit importní program pro naimportování do zdrojových dat. Zdrojové csv ve tvaru (001 autrity; Oddělení autora v CZE; Oddělení autora v ENG ; Zkratka oddělení v CZE; Zkratka oddělení v ENG)
•   Termín importu v polovině září, ostrý provoz so 24.9.
•   Možnost opakovat import dat 3*
•   Včetně vymazání původních hodnot při importu
*/
]]></Content>
</UDLText>

<Method name="ImpDataAuthOddel">
<Description>
03.10.19 tt; vytvoreno

medota slouzi import oddeleni do pracovist
 d ##class(User.CavS).ImpDataAuthOddel("UIACH_import_cosm.csv")
pFile        - nazev souboru
pOddelovac   - oddelovac jednotlivych hodnot v radku
pTest        - 1 - testovaci spusteni
             - 0 - ostre spusteni  </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFile="",pOddelovac=";",pTest=1</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 s file=##class(%FileCharacterStream).%New() ; otevreni vstupniho souboru
 s file.Filename=pFile
 s slogName=$p(pFile,".",1)_"Log.log"        ; log file 
 d file.TranslateTableSet("CP1250")            ; otevreni v UTF8
 s sLine=file.ReadLine()         ; cten 1 radek
 f
 { ; cyklus pres cely soubor
   if (file.AtEnd) q  
   s sLine=file.ReadLine()        
   
   s sLine=##class(User.Util).strswap(sLine,$c(13),"")
   s sLTest=sLine
   s sLTest=##class(User.Util).strswap(##class(User.Util).strswap(sLTest,";",""),"###***###","")
   s bVlozeni=0
   if ('$f(sLTest,"  ")'="")
   {
     d ##class(User.Util).xlogf(slogName,"------------------------------------------------------------") 
     d ##class(User.Util).xlogf(slogName,"radek:"_sLine) 
     ; 001 autrity; Oddělení autora v CZE; Oddělení autora v ENG ; Zkratka oddělení v CZE; Zkratka oddělení v ENG
     s sT001A=$tr($j($p(sLine,pOddelovac,1),7)," ",0)
     s sOddCz=$p(sLine,pOddelovac,5),sOddEng=$p(sLine,pOddelovac,6)    ; precteme nazvy oddeleni
     s sZOddCz=$p(sLine,pOddelovac,7),sZOddEng=$p(sLine,pOddelovac,8)  ; precneme zkratky oddeleni
     
     if ##class(User.MARC).existsT001("CavUnAuth",sT001A)
     {
       if ##class(User.MARC).readX(.handle,"CavUnAuth",sT001A)
       {
         s nC=##class(User.MARC).recordLineCountX(.handle) ; ziskani poctu radku v zaznamu 
         f i=1:1:nC 
         { ; pres vsechny radky zaznamu pujdeme po jednom radku a budeme nahrazovat
           s lsLine=##class(User.MARC).getLineX(.handle,i) continue:lsLine="" 
           s sTag=$e(lsLine,1,3), sOldLine=lsLine
           if (sTag="C06")&&(bVlozeni=0)
           { 
             ;  200    $$ai$$bOddělení autora v CZE#Oddělení autora v CZE#Author department in CZE$$cO$$d0
             ;  200    $$aj$$bOddělení autora v ENG#Oddělení autora v ENG#bAuthorisation in ENG$$cO$$d0
             ;  200    $$ak$$bZkratka oddělení v CZE#Zkratka oddělení v CZE#Shortcut in CZE$$cO$$d0
             ;  200    $$al$$bZkratka oddělení v ENG#Zkratka oddělení v ENG#Shortcut in ENG$$cO$$d0
             s:(sOddCz'="") lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"i"_sOddCz,"C06")
             s:(sOddEng'="") lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"j"_sOddEng,"C06")
             s:(sZOddCz'="") lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"k"_sZOddCz,"C06")
             s:(sZOddEng'="") lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"l"_sZOddEng,"C06")
             s bVlozeni=1
             d ##class(User.Util).xlogf(slogName,"Vlozeny hodnoty do existujiciho radku:") 
             d ##class(User.Util).xlogf(slogName,$$$strswap(lsLine,$c(31),"$$"))
           }    
           d:(sOldLine'=lsLine) ##class(User.MARC).setLineX(.handle,i,lsLine) ; zapsani to radku
         }
         if (bVlozeni=0)
         { ; nenasli jsme C06 - vlozime novou
           s sTagC06="C06    "
           s:(sOddCz'="") sTagC06 = ##class(User.MARC).setSubTagStr(sTagC06,$c(31)_"i"_sOddCz,"C06")
           s:(sOddEng'="") sTagC06 = ##class(User.MARC).setSubTagStr(sTagC06,$c(31)_"j"_sOddEng,"C06")
           s:(sZOddCz'="") sTagC06 = ##class(User.MARC).setSubTagStr(sTagC06,$c(31)_"k"_sZOddCz,"C06")
           s:(sZOddEng'="") sTagC06 = ##class(User.MARC).setSubTagStr(sTagC06,$c(31)_"l"_sZOddEng,"C06")
           d ##class(User.MARC).setTagX(.handle,sTagC06)  
           s bVlozeni=1
           d ##class(User.Util).xlogf(slogName,"Vlozeny hodnoty do noveho radku:") 
           d ##class(User.Util).xlogf(slogName,$$$strswap(sTagC06,$c(31),"$$"))   
         }    

         if ((bVlozeni=1)&&(pTest=0))
         { ; vlozeni upraveneho handlu
           s st=##class(User.MARC).writeX(.handle)
           if $$$ISERR(st)
           { ; vypis chyby
             d ##class(User.Util).xlogf(slogName,"ERROR:"_##class(User.Util).status2str(st))
           }
           else
           {
             d ##class(User.Util).xlogf(slogName,"Zapis hodnoty probehl v poradku") 
           }
         }
       }
       else { d ##class(User.Util).xlogf(slogName,"ERROR - Nebylo mozne otevrit zaznam: "_sT001A)  }
     }
     else
     { d ##class(User.Util).xlogf(slogName,"ERROR - Nenalezen zaznam: "_sT001A)  }
   }
   else
   { d ##class(User.Util).xlogf(slogName,"ERROR - radek bez informaci: "_sLine)  }   
 }
 
 d file.%Close()                   ; zavreni souboru
]]></Implementation>
</Method>

<Method name="deleteOddel">
<Description><![CDATA[
<pre> Medota vymaz oddeleni z autorit i Epca

d ^X("s CavUnAuth C06i")
s sy="##class(User.CavS).deleteOddel(.handle)"
d ^X("l @"_sy)
d ^X("g @"_sy)

d ^X("s CavUnEpca 70*i")
s sy="##class(User.CavS).deleteOddel(.handle)"
d ^X("l @"_sy)
d ^X("g @"_sy)

Parametry: handle   - aktualni zpracovavany handle
03.10.19 tt; metoda zalozena                          
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Library.Binary]]></FormalSpec>
<Implementation><![CDATA[
 s c = ##class(User.MARC).recordLineCountX(.handle)
 s class=$$$HandleClass(handle)
 
 f i=1:1:c
 { ; pres vsechny radky zaznamu musime projit
   s lsLine = ##class(User.MARC).getLineX(.handle,i) continue:(lsLine = "") ; ziskame jeden radek
   s lsTag = $e(lsLine,1,3), lsLineO=lsLine          ; ziskame prefix tagu a udelame kopii radku
     
   if ((lsTag = "C06") || (class = "CavUnAuth"))   
   { ; v autoritach odstranime podle pro oddeleni
     s lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"i")
     s lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"j")
     s lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"k")
     s lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"l")
   } 
   
   if (($e(lsTag,1,2) = "70") || (class = "CavUnEpca"))   
   {
     s lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"i")
     s lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"j")
     s lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"k")
     s lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"l")
   }   
   
   d:(lsLine '= lsLineO) ##class(User.MARC).setLineX(.handle,i,lsLine)    ; pokud doslo ke zmene, zapis.  
  }
  
  d ##class(User.MARC).recordDelEmptyST(.handle)    ; odmazani prazdnych subtagu
]]></Implementation>
</Method>

<Method name="ImpDataEPCAOddel">
<Description><![CDATA[
03.10.19 tt; vytvoreno

medota slouzi import oddeleni do pracovist do Epca zaznamu
pFile        - nazev souboru
pOddelovac   - oddelovac jednotlivych hodnot v radku

import dat z csv
s data=0
d ^X("s CavUnEpca ye > 2009")
d ^X("s &&CavUnEpca !pra = UIACH-O")
s sy="##class(User.CavS).ImpDataEPCAOddel(.handle,.data,""UIACH_import_EPCA.csv"")"
d ^X("l @"_sy)
d ^X("g @"_sy)
]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Binary,&data,pFile="",pOddelovac=";"]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 s slogName=$p(pFile,".",1)_"Log.log"        ; log file 

 if (data'=1)
 {
   s file=##class(%FileCharacterStream).%New() ; otevreni vstupniho souboru
   s file.Filename=pFile
   d file.TranslateTableSet("CP1250")          ; otevreni v UTF8
   s sLine=file.ReadLine()                     ; cten 1 radek
   d ##class(User.Util).xlogf(slogName,"------------------------------------------------------------") 
   d ##class(User.Util).xlogf(slogName,"Nacteni konfigurace: ") 

   f
   { ; cyklus pres cely soubor
     if (file.AtEnd) q  
     s sLine=file.ReadLine()        
   
     s sLine=##class(User.Util).strswap(sLine,$c(13),"")
     s sLTest=sLine
     s sLTest=##class(User.Util).strswap(##class(User.Util).strswap(sLTest,";",""),"###***###","")
     if ('$f(sLTest,"  ")'="")
     {
       d ##class(User.Util).xlogf(slogName,"radek:"_sLine) 
       ; Do záznamů s rokem vzniku 2010 a výše se naimportují oddělení dle tabulky:
       ; Pokud je v 700/701o=ENV, pak do 700/701i naimportuj Oddělení analytické chemie životního prostředí, 700/701j…..
      
       s sUstav=$zcvt($p(sLine,pOddelovac,1),"L"), sPuvOdd=$zcvt($p(sLine,pOddelovac,2),"L")
       s sOddCz=$p(sLine,pOddelovac,3), sOddEng=$p(sLine,pOddelovac,4)    ; precteme nazvy oddeleni
       s sZOddCz=$p(sLine,pOddelovac,5),sZOddEng=$p(sLine,pOddelovac,6)  ; precneme zkratky oddeleni
       s:(sOddCz'="") data(sUstav,sPuvOdd,"CZN")=sOddCz
       s:(sZOddCz'="") data(sUstav,sPuvOdd,"CZZ")=sZOddCz
       s:(sOddEng'="") data(sUstav,sPuvOdd,"ENGN")=sOddEng
       s:(sZOddEng'="") data(sUstav,sPuvOdd,"ENGZ")=sZOddEng
     }
   }
   s data=1
   d file.%Close()                   ; zavreni souboru
 }
 
 d ##class(User.Util).xlogf(slogName,"------------------------------------------------------------") 
 d ##class(User.Util).xlogf(slogName,"Zaznam: "_$$$HandleT001(handle)) 

 s nC=##class(User.MARC).recordLineCountX(.handle) ; ziskani poctu radku v zaznamu 
 f i=1:1:nC 
 { ; pres vsechny radky zaznamu pujdeme po jednom radku a budeme nahrazovat
   s lsLine=##class(User.MARC).getLineX(.handle,i) continue:lsLine="" 
   s sTag=$e(lsLine,1,3), sOldLine=lsLine
   
   if ($e(sTag,1)="7")  
   {
     s sUstav=$zcvt($$$getSubTagStr(lsLine,"p"),"L")
     s sPuvOdd=$zcvt($$$getSubTagStr(lsLine,"o"),"L")
     if ((sUstav'="")&&(sPuvOdd'=""))
     {
       ; vlozime hodnoty do zaznamu      
       s:($g(data(sUstav,sPuvOdd,"CZN"))'="") lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"i"_data(sUstav,sPuvOdd,"CZN"))
       s:($g(data(sUstav,sPuvOdd,"ENGN"))'="") lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"j"_data(sUstav,sPuvOdd,"ENGN"))
       s:($g(data(sUstav,sPuvOdd,"CZZ"))'="") lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"k"_data(sUstav,sPuvOdd,"CZZ"))
       s:($g(data(sUstav,sPuvOdd,"ENGZ"))'="") lsLine = ##class(User.MARC).setSubTagStr(lsLine,$c(31)_"l"_data(sUstav,sPuvOdd,"ENGZ"))
     }
   }  
   if (sOldLine'=lsLine)
   {
     d ##class(User.Util).xlogf(slogName,"Puvodni radek:  "_$$$strswap(sOldLine,$c(31),"$$")) 
     d ##class(User.Util).xlogf(slogName,"Novy radek:     "_$$$strswap(lsLine,$c(31),"$$"))
     d ##class(User.MARC).setLineX(.handle,i,lsLine) ; zapsani to radku
   }
 }
]]></Implementation>
</Method>

<Method name="ImpHod2020">
<Description>
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

Postup importu:
1. Smazat vsechno co je nastavene v autoritach (C48) a v zaznamech (700w,C64)
2. Import udaju do autorit (C48)
3. Dotazeni do pole 700w udaje o tymu (do zaznamu s vrocenim 2010-2014)
4. Import udaju z CSV do zaznamu (C64), C64a nastavit na "k hodnoceni!).

Import by mohl probihat v nejakych pravidelnych intervalech, aby byl v
ASEP aktualni stav.
27.02.20 tt; zalozeno

Importni metoda pro import dat z csv k hodnoceni.


d ##class(User.CavS).ImpHod2020("Tymy_zaznamy.csv","K","Tymy_zaznamy.log")
d ##class(User.CavS).ImpHod2020("Tymy_autori.csv","A","Tymy_autori.log")
pFile   - nazev souboru
pTyp    - A - autority - K - katalog
pLog    - log soubor</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFile:%String,pTyp:%Integer,pLog=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 s file=##class(%FileCharacterStream).%New() ; otevreni vstupniho souboru
 s file.Filename=pFile
 d file.TranslateTableSet("UTF8")  ; otevreni v UTF8
 ;d file.TranslateTableSet("CP1250")
 s sLine=file.ReadLine()           ; nacten prvni radek
 
 f
 { ; cyklus pres cely soubor
   s sLine=file.ReadLine()         ; cten 1 radek
   
   if (sLine'="")
   { ; pokud mame vyplneny radek, zpracovavame
     s sLine=$tr(sLine,$c(13),"")
     s sL1=$zstrip($p(sLine,";",1),"<>W"),sL2=$zstrip($p(sLine,";",2),"<>W"),sL3=$zstrip($p(sLine,";",3),"<>W"),sL4=$zstrip($p(sLine,";",4),"<>W")
     s sL5=$zstrip($p(sLine,";",5),"<>W"),sL6=$zstrip($p(sLine,";",6),"<>W"),sL7=$zstrip($p(sLine,";",7),"<>W"),sL8=$zstrip($p(sLine,";",8),"<>W")
    
     if (pTyp="K")
     {
       ; Tymy_zaznamy.csv
       ; sysno;tým;ústav;obor;podobor
       ; Asepové číslo;Označení výsledku k hodnocení C64a;Tým_eng C64b;Kód ASEP C64c;Číslo oboru C64d;Název disciplíny dle WoS C64e
       d ..ImpHod2020Kat(sL1,sL2,sL3,sL4,sL5,sL6,pLog,sLine)
     }
     if (pTyp="A")
     {
       ; Tymy_autori.csv
       ; Ústav;Ústav ASEP;Autor sysno;Autor;Název týmu anglicky C48$y;Oborová skupina C48$z;Zařazení pracovníka C48$k
       d ..ImpHod2020Auth(sL3,"",sL5,sL6,sL7,pLog,sLine)
     }
   }   
   q:(file.AtEnd) ; pokud je konec souboru, ukoncime zpracovani
 }
 d file.%Close()                   ; zavreni souboru
]]></Implementation>
</Method>

<Method name="ImpHod2020Kat">
<Description>
Import udaju do katalogu - C64
C64a =1
sysno;tým C64b;ústav C64c;obor C64d;podobor C64e
27.02.20 tt; zalozeno</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pT001="",pOznacHod="",pTym="",pUstav="",pObor="",pPodobor="",pLog="",pLine=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s sLogCsv=$$$strswap(pLog,".log","logCsv.csv")

 s err=""
 if ##class(User.MARC).readX(.handle,"CavUnEpca",pT001) 
 { ; pokusime se otevrit handle
   w !,"------------------------------------------------------------------------------"
   w !,"CavUnEpca*"_pT001

   s sCatT=""
   s sCatT=##class(User.MARC).setSubTagStr(sCatT,$c(31)_"a1","C64   ")
   s:(pOznacHod'="") sCatT=##class(User.MARC).setSubTagStr(sCatT,$c(31)_"a"_pOznacHod,"C64   ") 
   s:(pTym'="") sCatT=##class(User.MARC).setSubTagStr(sCatT,$c(31)_"b"_pTym,"C64   ") 
   s:(pUstav'="") sCatT=##class(User.MARC).setSubTagStr(sCatT,$c(31)_"c"_pUstav,"C64    ") 
   s:(pObor'="") sCatT=##class(User.MARC).setSubTagStr(sCatT,$c(31)_"d"_pObor,"C64    ") 
   s:(pPodobor'="") sCatT=##class(User.MARC).setSubTagStr(sCatT,$c(31)_"e"_pPodobor,"C64    ") 
   ; radky pouze pridavame (nemazeme puvodni). Provedeme jen kontrolu, jestli nahodou jiz neexistuji
   s sTagC64=$$$getTagXC(.handle,"C64",-1)

   ; vlozime radek a ulozime zaznam
   d:((sCatT'="")&&('$f($c(10)_sTagC64_$c(10),$c(10)_sCatT_$c(10)))) ##class(User.MARC).appendLineX(.handle,sCatT)
   w:(sTagC64'="") !,"Do exostujici:"_$$$strswap(sTagC64,$c(31),"$$")
   w !,"Pridano:"_$$$strswap(sCatT,$c(31),"$$")
   
   if ((sCatT'="")&&('$f($c(10)_sTagC64_$c(10),$c(10)_sCatT_$c(10))))
   {
     d ##class(User.MARC).recordSetupMarcSkipAllowSaveX(.handle,1)
     s st=##class(User.MARC).writeX(.handle,,,,3_$c(10)_"imp_sys"_$c(10)_"127.0.0.1")
     if '$$$ISOK(st) 
     { ; ulozime si chybu pro pozdejsi zpracovani
       s err="Error - write: (CavUnEpca/"_pT001_") - "_##class(User.Util).status2str(st)
       d ##class(User.Util).xlogf(sLogCsv,pLine_";Error;Nepodařilo se zapsat data do záznamu:"_##class(User.Util).status2str(st))
     }
     else
     {
       d ##class(User.Util).xlogf(sLogCsv,pLine_";OK;zápis dat do záznamu proběhl v pořádku")
     }
   }
   else
   {
     d ##class(User.Util).xlogf(sLogCsv,pLine_";OK;do záznamu již tyto hodnoty byly zapsány")   
   }
 }
 else
 { ; vypis, ze nam chybi autorita
   s err="Error - (CavUnEpca/"_pT001_") - nepodarilo se otevrit zaznam pro doplneni dat"
   d ##class(User.Util).xlogf(sLogCsv,pLine_";Error;(CavUnEpca/"_pT001_") - nepodarilo se otevrit zaznam pro doplneni dat")
 }
 
 if (pLog'="")
 { ; pokud mame log, piseme informace o improtu do logu
   d:(err'="") ##class(User.Util).xlogf(pLog,pT001_"#####"_err)
 }
 else 
 { ; pokud nemame log, vypisou se informace na standardni vystup
   w:(err'="") !,err       ; proveden vypis
 }
]]></Implementation>
</Method>

<Method name="ImpHod2020Auth">
<Description><![CDATA[
<pre> Import udaju do autority - C48 pro ucely hodnoceni
Parametry: pT001      - ID autority
           pTym       - nazev ci zkratky tymu
           pTymEng    - anglicky nazev ci zkratka tymu
           pOborSk    - oborova skupina
           pZarazeni  - zarazeni
           pLog       - log soubor. Pokud neni zadan, vypisuji se chyby na standardni vystup

Autor;Sysno autority;Tým C48x;Tým eng C48y;Oborová skupina C48z;Zařazení C48k
27.02.20 tt; zalozeno
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pT001="",pTym="",pTymEng="",pOborSk="",pZarazeni="",pLog="",pLine=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s:($l(pT001)<7) pT001=0_pT001
 s sLogCsv=$$$strswap(pLog,".log","logCsv.csv")
 
 s err=""
 if ##class(User.MARC).readX(.handle,"CavUnAuth",pT001) 
 { ; pokusime se otevrit handle
   w !,"------------------------------------------------------------------------------"
   w !,"CavUnAuth*"_pT001
   s sAutT=""
   s:(pTym'="") sAutT=##class(User.MARC).setSubTagStr(sAutT,$c(31)_"x"_pTym,"C48   ") 
   s:(pTymEng'="") sAutT=##class(User.MARC).setSubTagStr(sAutT,$c(31)_"y"_pTymEng,"C48    ") 
   s:(pOborSk'="") sAutT=##class(User.MARC).setSubTagStr(sAutT,$c(31)_"z"_pOborSk,"C48    ") 
   s:(pZarazeni'="") sAutT=##class(User.MARC).setSubTagStr(sAutT,$c(31)_"k"_pZarazeni,"C48    ") 
   ; radky pouze pridavame (nemazeme puvodni). Provedeme jen kontrolu, jestli nahodou jiz neexistuji
   s sTagC48=$$$getTagXC(.handle,"C48",-1)

   ; vlozime radek a ulozime zaznam
   d:((sAutT'="")&&('$f($c(10)_sTagC48_$c(10),$c(10)_sAutT_$c(10)))) ##class(User.MARC).appendLineX(.handle,sAutT)
   w:(sTagC48'="") !,"Do exostujici:"_$$$strswap(sTagC48,$c(31),"$$")
   w !,"Pridano:"_$$$strswap(sAutT,$c(31),"$$")
   
   if ((sAutT'="")&&('$f(($c(10)_sTagC48_$c(10)),($c(10)_sAutT_$c(10)))))
   {
     d ##class(User.MARC).recordSetupMarcSkipAllowSaveX(.handle,1)
     s st=##class(User.MARC).writeX(.handle,,,,3_$c(10)_"imp_sys"_$c(10)_"127.0.0.1")
     if '$$$ISOK(st) 
     { ; ulozime si chybu pro pozdejsi zpracovani
       s err="Error - write: (CavUnAuth/"_pT001_") - "_##class(User.Util).status2str(st)
       d ##class(User.Util).xlogf(sLogCsv,pLine_";Error;Chyba zápisu do autority:"_##class(User.Util).status2str(st))
     }
     else
     {
       d ##class(User.Util).xlogf(sLogCsv,pLine_";OK;Zapsána hodnota do záznamu autority")
     }
   }
   else
   {
     d ##class(User.Util).xlogf(sLogCsv,pLine_";OK;do záznamu již tyto hodnoty byly zapsány")   
   }
 }
 else
 { ; vypis, ze nam chybi autorita
   s err="Error - (CavUnAuth/"_pT001_") - nepodarilo se otevrit zaznam pro doplneni dat"
   d ##class(User.Util).xlogf(sLogCsv,pLine_";Error;(CavUnAuth/"_pT001_") - nepodarilo se otevrit zaznam pro doplneni dat")
 }
 
 if (pLog'="")
 { ; pokud mame log, piseme informace o improtu do logu
   d:(err'="") ##class(User.Util).xlogf(pLog,pT001_"#####"_err)
 }
 else 
 { ; pokud nemame log, vypisou se informace na standardni vystup
   w:(err'="") !,err       ; proveden vypis
 }
]]></Implementation>
</Method>

<Method name="DelDataHodnoceni">
<Description>
Vymazani dat pro hodnoceni - pozor, maze kompletne katalog: je mozne spustit jen pro dalsi hodnoceni
2.   Smazat obsah pole 700/701w v záznamu    
4.   Smazat obsah pole C71$9 – označení recenze k hodnocení
5.   smazat obsah pole 971$9 – označení citace k hodnocení
d ^X("s CavUnEpca")
d ^X("ex ZalCavUnEpca.txt")
d ^X("l @"_sy)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Library.String]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 s FileZal="CavUnEpcaLog.txt"
 ;s sy="##class(User.Tmp1).DelDataHodnoceni(.handle)"    
 ; d ^X("s CavUnEpca")
 ; d ^X("l @"_sy)
 s t001=$$$HandleT001(handle)
 d ##class(User.Util).xlogf(FileZal,"----------------------------------------------------")
 d ##class(User.Util).xlogf(FileZal,"CavUnEpca*"_t001)

 s sC64=$$$getTagX(.handle,"C64")
 if (sC64'="")
 {
   d ##class(User.Util).xlogf(FileZal,sC64)
   d ##class(User.MARC).delTagX(.handle,"C64")
 }
 
 s nC=##class(User.MARC).recordLineCountX(.handle) ; ziskani poctu radku v zaznamu 
 f i=1:1:nC 
 { ; pres vsechny radky zaznamu pujdeme po jednom radku a budeme nahrazovat
   s lsLine=##class(User.MARC).getLineX(.handle,i) continue:lsLine="" 
   s sTag=$e(lsLine,1,3), sOldLine=lsLine
   ; 2.   Smazat obsah pole 700/701w v záznamu    
   ; 4.   Smazat obsah pole C71$9 – označení recenze k hodnocení
   ; 5.   smazat obsah pole 971$9 – označení citace k hodnocení
   if ((sTag="700")||(sTag="701"))
   {
     if $f(lsLine,($c(31)_"w"))
     {
       d ##class(User.Util).xlogf(FileZal,lsLine)
       s lsLine=##class(User.MARC).setSubTagStr(lsLine,$c(31)_"w")   
     }   
   }
   if ((sTag="C71")||(sTag="971"))
   {
     if $f(lsLine,($c(31)_"9"))
     {
       d ##class(User.Util).xlogf(FileZal,lsLine)
       s lsLine=##class(User.MARC).setSubTagStr(lsLine,$c(31)_"9")   
     }   
   }   
    
   s:(lsLine="") lsLine="del"
   d:(sOldLine'=lsLine) ##class(User.MARC).setLineX(.handle,i,lsLine) ; zapsani to radku
 }
 d ##class(User.MARC).recordDelEmptyST(.handle)    ; odmazani prazdnych subtagu
]]></Implementation>
</Method>

<Method name="gEpca70Xw">
<Description><![CDATA[
<pre> 
 d ^X("s CavUnEpca ye bt 2015 2019")
 s sy="##class(User.CavS).gEpca70Xw(.handle)"      ; definovan symbolik
 d ^X("l @"_sy)                                    ; testovaci spusteni
 d ^X("g @"_sy)                                    ; ostre spusteni

28.01.15 tt; zalozena metoda
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Binary]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  s FileZal="CavUnEpcaAdd70Xw.txt"

  d ##class(User.Util).xlogf(FileZal,"-----------------------------------------------------------------------")
  d ##class(User.Util).xlogf(FileZal,sClass_sT001)
  s nC=##class(User.MARC).recordLineCountX(.handle) ; ziskani poctu radku v zaznamu 
  f i=1:1:nC 
  { ; pres vsechny radky zaznamu pujdeme po jednom radku a budeme nahrazovat
    s lsLine=##class(User.MARC).getLineX(.handle,i) continue:lsLine="" 
    s sTag=$e(lsLine,1,3)
    if ((sTag="700")||(sTag="701")||(sTag="702"))
    {
      s sST3=$$$getSubTagStr(lsLine,"3")    ; odkaz
      if ##class(User.MARC).readLX(.handleA,sST3) 
      {
        s tC48xall=$$$getTagXC(.handleA,"C48x",-1)
        ; zkusime dat anglicky nazev, pokud neni cesky
        s:(tC48xall="") tC48xall=$$$getTagXC(.handleA,"C48y",-1)
        
        if $f(tC48xall, $c(10))
        {
          d ##class(User.Util).xlogf(FileZal," ERROR: autoritni zaznam:"_sST3_" ma vice opakovani C48")
        }
        s tC48x=$p(tC48xall,$c(10),1)
        
        if (tC48x'="")
        { ; pridame do radku
          s lsLine=##class(User.MARC).setSubTagStr(lsLine,$c(31)_"w"_tC48x) 
          d ##class(User.Util).xlogf(FileZal," Vlozeno: $$w"_tC48x)
          d ##class(User.MARC).setLineX(.handle,i,lsLine) ; zapsani to radku    
        }
      }
    }      
  }
]]></Implementation>
</Method>

<Method name="nenavazaneCav">
<Description><![CDATA[
<pre> hledani navazani zaznamu
s sy="ret1=(##class(User.CavS).nenavazaneCav(.handle)>0)"
d ^X("s CavUnEpca tag = 978")
d ^X("s &&CavUnEpca 200a = NAZEV") 
d ^X("s &&CavUnEpca @"_sy)
d ^X("s &&CavUnEpca 'T04")

</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Binary]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[

 s lsClass=$$$HandleClass(handle),lnId=##class(MARC).recordIdX(.handle), sT001=$$$HandleT001(handle)
 s sLName=##class(User.Util).objectName2lname(lsClass)
  
 s idNal="",bFing=0 
 f
 { ; jestli ja autorita navazana, mela by byt v auk
   s idNal=##class(User.MARC).getIDByIndex("CavUnAuth","auk"," "_sLName_"*"_sT001,idNal)
   q:((idNal=0)||(bFing=1))
   s bFing=1
 }
 
 f
 {
   s idNal=##class(User.MARC).getIDByIndex("CavUnEpca","auk"," "_sLName_"*"_sT001,idNal)
   q:((idNal=0)||(bFing=1))
   s bFing=1
 }
 
 f
 {
   s idNal=##class(User.MARC).getIDByIndex("CavUnOhlCat","auk"," "_sLName_"*"_sT001,idNal)
   q:((idNal=0)||(bFing=1))
   s bFing=1
 }
 
 if bFing
 {
    q 0
 }
 else
 {
    q 1 
 }
]]></Implementation>
</Method>

<Method name="OpravaIssnEissn">
<Description>
JCR_2020_Q11.csv

d ##class(User.CavS).OpravaIssnEissn("JCR_2020_Q11.csv")
d ##class(User.CavS).OpravaIssnEissn("JCR_2020_Q21.csv")
d ##class(User.CavS).OpravaIssnEissn("JCR_2020_Q31.csv")
d ##class(User.CavS).OpravaIssnEissn("JCR_2020_Q41.csv")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFile:%String,pLog=""</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
 s file=##class(%FileCharacterStream).%New() ; otevreni vstupniho souboru
 s file.Filename=pFile
 d file.TranslateTableSet("UTF8")  ; otevreni v UTF8
 ;d file.TranslateTableSet("CP1250")
 s sLine=file.ReadLine()           ; nacten prvni radek
 s sT001o="",sT001=""
 
 f
 { ; cyklus pres cely soubor
   s sLine=file.ReadLine()         ; cten 1 radek
   
   if (sLine'="")
   { ; pokud mame vyplneny radek, zpracovavame
     s sNazev=$p(sLine,";",1),ISSN=$p(sLine,";",2),eISSN=$p(sLine,";",3)
     
     s:(ISSN'="") sT001=..write978FindR("CavUnEpca", .ISSN,sNazev,"-XSZP--ALLR-")
     s:(eISSN'="") sT001o=..write978FindR("CavUnEpca", .eISSN,sNazev,"-XSZP--ALLR-")

     s:((sT001'="")&&(sT001o'="")) sT001=sT001_";"_sT001o
     s:((sT001="")&&(sT001o'="")) sT001=sT001o
      
     for x=1:1:$l(sT001,";")
     {
       s sT001o=$p(sT001,";",x)
       continue:(sT001o="")
       s bzmena=0
       if ##class(User.MARC).readX(.handle,"CavUnEpca",sT001o) 
       { ; zpracovavani jednoho zaznamu          
        s s011=$$$getTagXC(.handle,"011",-1)
        if '$f(s011,$c(10))
        {
          s s011a=$$$getSubTagStr(s011,"a")
          s s011e=$$$getSubTagStr(s011,"e")
          if ((s011a="")&&(ISSN'=""))
          { 
            s s011=$$$setSubTagStr(s011,$c(31)_"a"_ISSN) 
            s bzmena=1
          }
          if ((s011e="")&&(eISSN'=""))
          { 
            s s011=$$$setSubTagStr(s011,$c(31)_"e"_eISSN) 
            s bzmena=1
          }
          d:(bzmena=1) $$$setTagX(.handle,s011)
        }
        s s200=$$$getTagX(.handle,"200")
        if (($$$getSubTagStr(s200,"a")="Nazev")&&(s200'=""))
        { 
           s s200=$$$setSubTagStr(s200,$c(31)_"a"_sNazev) 
           d $$$setTagX(.handle,s200)
           s bzmena=1
        } 
        
        if (bzmena=1)
        {
           w !," ------------------------------------------------------------------------------------"
           w !," uprava zaznamu "_$$$HandleT001(handle) 
           w !,s200,!,s011
           s st=##class(User.MARC).writeX(.handle,,,,3_$c(10)_"arl_doplneni_issn"_$c(10)_"127.0.0.1")
           if '$$$ISOK(st) 
           { ; ulozime si chybu pro pozdejsi zpracovani
              s err="Error - write: (CavUnEpca/"_pT001_") - "_##class(User.Util).status2str(st)
              ///d ##class(User.Util).xlogf(sLogCsv,pLine_";Error;Nepodařilo se zapsat data do záznamu:"_##class(User.Util).status2str(st))
           }
        }        
       }
     }
   }   
   q:(file.AtEnd) ; pokud je konec souboru, ukoncime zpracovani
 }
 d file.%Close()                   ; zavreni souboru
]]></Implementation>
</Method>

<Method name="write978FindR">
<Description><![CDATA[
///////////////////////////////////////////////////////////////////////////
<pre> Pomocna metoda pro write978DataLine, ktera najde konkretni zaznam ISSN
      Kontroluje vyplnenost 022 nebo 011
Parametry:
  pClass     - trida, ve ktere se budou aktualizovat data (priklad CavUnEpca)
  pISSN      - hledane issn
  pNazev     - nazev zaznamu k ISSN. Tato varianta se hleda u C32
  pPar        - parametry zpracovani oddelene "-"
              C32 - !!! nepouzivat - muselo by se dodelat - kontrolova shodu s C32a - pouzitelne jen s NEW
              NEW - pokud se nenajde v databazi podle ISSN zaznam, zalozi se novy podle sablony zaznamu z IctxUnTabelsd*GEN_NEW_SZP_978 
              XSZP - kontroluje se u vyhledaneho zaznamu podle ISSN, jestli je XSZP a jen k takovym se bude importovat IF 
              ALLR - naimportovat udaje (napr. IF) do vsech zaznamu, ktere splnuji kriteria
              UPDATE - pokud neni nalezena hodnota subtagu a subrag existuje s jinou hodnotou, tak pomoci teto
                       volby jinou hodnotu prepise
              NOT_UPDATE - hodnoty se importuji, pokud v zaznamu neni zadna hodnota pro tento subtag. Pokud tam uz subtag
                           existuje, nevhklada se nova hodnota at je jakakoli
              ADDALL - vzdy vlozi hodnotu subtagu, nezavisle na tom, jestli jiz v zaznamu je nebo ne. Nesmi byt jen prazdna
  pLog       - cesta s nazvem log file. Default ="writeDATA978.log"
 pLog1      - import ze vstupniho souboru - funguje korektne pri konfiguraci v souboru - novy zpusob, ktery jiz bude vyuzivat
 pLog2      - import ze vstupniho souboru - funguje korektne pri konfiguraci v souboru - novy zpusob, ktery jiz bude vyuzivat
  pDeb       - 2 - ostre spusteni
Navratova hodnota - jedna nalezena T001. Pokud vic, oddelovac je ;

19.08.13 tt; metoda zalozena
</pre>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClass,&pISSN,pNazev,pPar]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  s pISSN=$tr($zstrip(pISSN,"*WC"),"-","")  ; oceseme od prebytecnych znaku
  q:(pISSN="") ""                           ; pokud nemam ISSN, koncim
  s pISSN=$e(pISSN,1,4)_"-"_$e(pISSN,5,999) ; spravny tvar ISSN
  s sISSNfind=$zcvt(" "_pISSN,"L")          ; spravne formatovani hledaneho
  s sH="",sT001o="",sPomHod="",qT001=""     ; definice pomocnych promennych
  s sIctx=##class(User.Util).getClassPrefixParam(pClass)
  f    
  { ; nalezeni id existujiciho zaznamu - vsechny ISSN
    s sH=$o(^$$$MarcIndexG(pClass,"issn",sISSNfind,sH))
    q:(sH="")           ; pokud se nenasel zadny zaznam, tak ukonci      
    s sT001o=##class(User.MARC).getT001(sH)

    if (sT001o'="")
    { ; pokud mame data, zkontrolujeme zaznam
      if ##class(User.MARC).readX(.handle,pClass,sT001o,"T") 
      { ; zpracovavani jednoho zaznamu            
        s sRecIssn=$$$getTagXC(.handle,"022",-1)_$$$getTagXC(.handle,"011",-1)
        continue:(('$f(sRecIssn,$c(31)_"a"_pISSN))&&('$f(sRecIssn,$c(31)_"e"_pISSN)))        ; issn sa musi zhodovat
        if ($f("-"_pPar_"-","-XSZP-"))
        { ; podminka, jestli je dany zaznam souborny zaznam periodika
          s T00=$$$getTagX(.handle,"T00")
          continue:('$f(T00,$c(31)_"axszp"))       ; musi byt obsazeno
        }    
     

          
        if ($f("-"_pPar_"-","-ALLR-")) { s qT001=qT001_";"_sT001o }                            ; ulozime si vysledne 001
        else { s qT001=sT001o }
        
        s sPomHod=sH      ; pro test spravnosti ISSN zaznamu
      }
    }
  } 
 
  s:((qT001'="")&&($f("-"_pPar_"-","-ALLR-"))) $e(qT001,1)=""                             ; nahradime prvni znak - odstranime jej
  q qT001   ; navratova hodnota je bud prazdna, nebo je to 001 zaznamu
]]></Implementation>
</Method>

<Method name="zfVkladatel">
<Description><![CDATA[
<pre> Metoda pro zobrazeni udaju o vkladateli 
zobrazení vkladatele podle 999e – dotáhne se informace z is_user – 100a vše za oddělovačem „–„ + zobrazit datum vložení z 999 a zobrazovat jen zpracovateli nebo super uživateli. 
paremtry:  handle   - aktualni zpracovany handle
           params   - rozlicne parametry oddelene "-"
                    1. - prefix - muze byt zadan " : ", pak se takto vlozi, nebo U156. Pokud je prazdny, nebude prefix uveden
                    2. - 0 zobrazovat vkladatele jen z 999e/ 1 - jit si pro nej i do chronologie 
                    3. - retexec pred prefix - vyuzite ve zkracenem zf
          

Dokumentace: https://arl2.library.sk/wiki_arl/index.php/CAV/nab%C3%ADdka_2021#2.4._V.C3.BDstup_po.C4.8Dtu_z.C3.A1znam.C5.AF_v_xml_pro_jednotliv.C3.A9_.C3.BAstavy_a_poskytovatele_.28EXCEL.29_12
U229
01.12.23 tt; na zaklade pozadavku drobne upravy zakazky 2022 (29.11.23) upraveno
             provedena zmena, aby se vkladatele zobrazovali komukoli - zalomentovano - sUserR 
22.10.21 tt; zalozena metoda
<\pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Binary,params:%String=""]]></FormalSpec>
<Implementation><![CDATA[
  s sRes="",sJmeno="",sT999e="",sPrekPrefix=""
  s user=##class(i2.access).getLoginId()       ; ziskame id uzivatele
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  s idx=##class(User.Util).objectName2lname(sClass)_"*"_sT001
  s sT970b=$$$getTagX(.handle,"970b")
  s sPref=$p(params,"-",1)                     ; cteni parametru - prvni prefix
  s sChron=$p(params,"-",2)                    ; jestli jit i do chronologie
  s sRetPredPrefix=$p(params,"-",3)            ; jestli jit i do chronologie

  s:(sPref'="") sPrekPrefix=sPref                           
  s:($tr(sPref," :","")'="") sPrekPrefix=##class(rep.zf.tf).prefix(.handle,sPref)_": "
  
  ; 2 - zpracovatel k zaznamu
  ; 6 - superuzivatel
  //s sUserR=##class(User.CavS).FTgetIsUser(user,sT001) ; metoda pro vygenerovani role uzivatele
  if (sT970b="DATA")  
  { ; zobrazovat vkladatele jen pro data
    //if ((sUserR=2)||(sUserR=6)||(sUserR=5))
    //{ ; zpracovatelum ukazeme vkladatele
      s sT999e=$$$getTagX(.handle,"999e")

      if ((sT999e="")&&(sChron=1))
      { ; pokud nemame vyplneneho resitele - a mame hledat i v chronologii, mrkneme se tam
        s recID=""
        for
        {
          s recID=$o(^ooDataTableI("CmChronology","src"," "_idx,recID))
          q:((recID="")||(sT999e'=""))

          if ##class(User.MARC).getDATAX(.handlech,recID) 
          {
            s sT999e=$$$getTagX(.handlech,"999e")
          }
        }
      } 

     ; mame ziskaneho uzivatele, zkusime si tedka dotahnout informace z is user  
     if ##class(User.MARC).readLX(.handleU,sT999e)
     { ; pokud se nam podarilo otevrit uzivatele, nacteme 600b
       s sJmeno=$zstrip($p($$$getTagX(.handleU,"100a"),"-",2),"<>W")
       s:(sJmeno="") sJmeno=$$$getTagX(.handleU,"100c")  ; jmena mohou byt nekdy v podpoli c
     }
  // }
  
  ; pokud mame jmeno, zobrazime jej s prefixem z parametru  
  s:(sJmeno'="") sRes=sPrekPrefix_sJmeno
  }
   
  s:(sRes'="") sRes=sRetPredPrefix_sRes
  q sRes
]]></Implementation>
</Method>

<Method name="zfDatumZverejneni">
<Description><![CDATA[
<pre> Metoda pro zobrazeni datumu zverejneni
zobrazení vkladatele podle chronologie, kdy zaznam byl zverejnen
paremtry:  handle   - aktualni zpracovany handle
           params   - rozlicne parametry oddelene "-"
                    1. - prefix - muze byt zadan " : ", pak se takto vlozi, nebo U156. Pokud je prazdny, nebude prefix uveden
                    2. - vlozi retezec pred vysledek - vyuzito ve zkracenem zf, aby dal " : " a jeste prefix
                    3. - pokud parametr 1 - zobrazi se jen rok
          

Dokumentace: https://arl2.library.sk/wiki_arl/index.php/CAV/nab%C3%ADdka_2021#1.6._drobn.C3.A9_.C3.BApravy_zobrazen.C3.AD_14

01.12.23 tt; na zaklade pozadavku drobne upravy zakazky 2022 (29.11.23) upraveno
01.11.23 tt; cs122294 - odstraneni prebytecnych mezer
09.11.21 tt; zalozena metoda
<\pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&handle:%Binary,params:%String=""]]></FormalSpec>
<Implementation><![CDATA[
  s sRes="",sDatum="",sDatum1="",sT999e="",sPrekPrefix=""
  //s user=##class(i2.access).getLoginId()       ; ziskame id uzivatele
  s sT001=$$$HandleT001(handle)                ; ziskame si T001 zaznamu
  s sClass=$$$HandleClass(handle)              ; ziskame tridu zaznamu
  s idx=##class(User.Util).objectName2lname(sClass)_"*"_sT001
  s sT970b=$$$getTagX(.handle,"970b")
  s sPref=$p(params,"-",1)                     ; cteni parametru - prvni prefix
  s sTextPref=$p(params,"-",2)                     ; retezec, ktery se vlozi na zacatek
  s sShowYear=$p(params,"-",3)                     ; zobrazit jen rok

  s:(sPref'="") sPrekPrefix=sPref                           
  s:($tr(sPref," :","")'="") sPrekPrefix=##class(rep.zf.tf).prefix(.handle,sPref)_": "
  
  ; pojistka, kdyby nebyla zadna chronologie
  s sDatum1=$$$getTagX(.handle,"100a")
  if (sShowYear="1") { s sDatum1=$e(sDatum1,1,4) }
  else { s sDatum1=+$e(sDatum1,7,8)_"."_+$e(sDatum1,5,6)_"."_$e(sDatum1,1,4) }
  
  
  if ((sT970b="DATA") && ($$$getTagX(.handle,"969f")="")) 
  { ; zobrazovat vkladatele jen pro data
  
    s recID=""
    for
    { ; prochazime chronologii od nejnovejsich
      s recID=$o(^ooDataTableI("CmChronology","src"," "_idx,recID),-1)
      q:((recID="")||(sDatum'=""))

      if ##class(User.MARC).getDATAX(.handlech,recID) 
      { ; nacteme zaznam chronologie 
        s sT969f=$$$getTagX(.handlech,"969f")
        if (sT969f'="") 
        { ; pokud mam 969f vyplnene, je to datum, kdy bylo odstraneno
          s sDatum=$$$getTagX(.handlech,"C97a")
          if (sShowYear="1") { s sDatum=$e(sDatum,1,4)}
          else { s sDatum=+$e(sDatum,7,8)_"."_+$e(sDatum,5,6)_"."_$e(sDatum,1,4) }
           
        }
        else
        {
          s sDatum1=$$$getTagX(.handlech,"C97a")
          if (sShowYear="1") { s sDatum1=$e(sDatum1,1,4) }
          else { s sDatum1=+$e(sDatum1,7,8)_"."_+$e(sDatum1,5,6)_"."_$e(sDatum1,1,4) }
          
        }
      }
    }
  
    ; pokud mame jmeno, zobrazime jej s prefixem z parametru  
    s:(sDatum="") sDatum=sDatum1
    if (sDatum'="")
    {       
      s sRes=sTextPref_sPrekPrefix_sDatum
    }
  }
  q sRes
]]></Implementation>
</Method>

<Method name="ImpC86QTC">
<Description><![CDATA[
<pre> import QTC do tagu C86
tag C86 by měl být neopakovatelný, tedy hodnota se vždy přehraje
prvni sloupec roku je ignorovan

13.02.24 tt; zalozena metoda pro pravidelny import
</pre> ]]></Description>
<ClassMethod>1</ClassMethod>
<ProcedureBlock>1</ProcedureBlock>
<Implementation><![CDATA[
  ;d ##class(User.CavS).ImpC86QTC()
  s file=##class(%FileCharacterStream).%New() ; otevreni vstupniho souboru
  s file.Filename="editacni_import_QTC_zavorky_2023.csv"
  s log="editacni_import_QTC_zavorky_2023.log"
  s log1="editacni_import_QTC_zavorky_2023_log.csv"
  d file.TranslateTableSet("UTF8")            ; otevreni v UTF8
  s sLine=file.ReadLine()                     ; prvni radek preskocen
  
  for 
  {
    if (file.AtEnd) q  
    s sLine=file.ReadLine()                   ; cten 1 radek 
    continue:($tr(sLine,"; .,","")="")        ; pokud nemam data, koncim
    d ##class(User.Util).xlogf(log,"--------------------------------------------------------")
    d ##class(User.Util).xlogf(log,sLine)

    ; Sysno;N.A.;DT;Obor
    ; N.A.=C86$b;DT=C86$c;Obor=C86$d
    s sLine=$$$strswap(sLine,$c(13),"")
    s sKod=$tr($j($p(sLine,";",2),7)," ","0")
    s sSTb=$p(sLine,";",3)
    s sSTc=$p(sLine,";",4)
    s sSTd=$p(sLine,";",5)
    if ##class(User.MARC).readX(.handle,"CavUnEpca",sKod)
    {
      d ##class(User.Util).xlogf(log,"Nacten zaznam: "_sKod)
      s sZmena=0
      
      s sC86=$$$getTagX(.handle,"C86")
      s sC86All=$$$getTagXC(.handle,"C86",-1)
      s sC86Old=sC86
      if (sC86'="")
      {
        if sC86'=""
        {
          s:(sSTb'="") sC86=##class(User.MARC).setSubTagStr(sC86,$c(31)_"b"_sSTb)   
          s:(sSTc'="") sC86=##class(User.MARC).setSubTagStr(sC86,$c(31)_"c"_sSTc)   
          s:(sSTd'="") sC86=##class(User.MARC).setSubTagStr(sC86,$c(31)_"d"_sSTd)   
        }
        if (($zstrip(sC86Old,"<>W")'=$zstrip(sC86,"<>W"))||(sC86All'=sC86))
        { 
          d ##class(User.MARC).setTagX(.handle,sC86) ; zapsani upraveneho tagu do handlu
          d ##class(User.Util).xlogf(log,"Probehla zmena C86:")
          d ##class(User.Util).xlogf(log,"Z:  "_$$$strswap(sC86Old,$c(31),"$$"))
          d ##class(User.Util).xlogf(log,"Na: "_$$$strswap(sC86,$c(31),"$$"))
          d:($f(sC86All,$c(10))) ##class(User.Util).xlogf(log,"Odstraneno vice opakovani C86")         
          s sZmena=1
        }
      }  
      else
      {
        d ##class(User.MARC).setTagX(.handle,"C86    "_$c(31)_"b"_sSTb_$c(31)_"c"_sSTc_$c(31)_"d"_sSTd) 
        d ##class(User.Util).xlogf(log,"Pridana nova C86:")
        d ##class(User.Util).xlogf(log,"C86    $$b"_sSTb_"$$c"_sSTc_"$$d"_sSTd)
        s sZmena=1
      }     
      
      if (sZmena=1)
      {
        d ##class(User.MARC).recordSetupMarcSkipAllowSaveX(.handle)
        s st=##class(User.MARC).writeX(.handle)
        if '$$$ISOK(st) 
        {
          d ##class(User.Util).xlogf(log,"ERROR: Chyba zapisu handlu "_st)            
          d ##class(User.Util).xlogf(log1,sLine_";"_"ERROR: Chyba zapisu handlu "_st)            
        }
        else
        {
           d ##class(User.Util).xlogf(log,"Zmena zaznamu probehla v poradku!")
           d ##class(User.Util).xlogf(log1,sLine_";"_"Zmena zaznamu probehla v poradku!") 
        }
      }
      else
      {  d ##class(User.Util).xlogf(log1,sLine_";"_"Neprobehla zmena, data jsou zrejme uz v zaznamu") }

    }
    else
    {
      d ##class(User.Util).xlogf(log,"ERROR: chybi 001 - "_sKod)
      d ##class(User.Util).xlogf(log1,sLine_";"_"ERROR: chybi 001 - "_sKod) 
    }
  }
  d file.%Close()
]]></Implementation>
</Method>
</Class>
</Export>
